/src/test/java/junit/tests/AllTests.java
========================================
 [Lines 11 - 13 ] {
    junit.textui.TestRunner.run(suite());
}
 [Lines 15 - 21 ] {
    TestSuite suite = new TestSuite("Framework Tests");
    suite.addTest(junit.tests.framework.AllTests.suite());
    suite.addTest(junit.tests.runner.AllTests.suite());
    suite.addTest(junit.tests.extensions.AllTests.suite());
    return suite;
}

/src/test/java/junit/tests/framework/AllTests.java
==================================================
 [Lines 11 - 13 ] {
    junit.textui.TestRunner.run(suite());
}
 [Lines 15 - 29 ] {
    TestSuite suite = new TestSuite("Framework Tests");
    suite.addTestSuite(TestCaseTest.class);
    // Tests suite building, so can't use automatic test extraction
    suite.addTest(SuiteTest.suite());
    suite.addTestSuite(TestListenerTest.class);
    suite.addTestSuite(AssertionFailedErrorTest.class);
    suite.addTestSuite(AssertTest.class);
    suite.addTestSuite(TestImplementorTest.class);
    suite.addTestSuite(NoArgTestCaseTest.class);
    suite.addTestSuite(ComparisonCompactorTest.class);
    suite.addTestSuite(ComparisonFailureTest.class);
    suite.addTestSuite(DoublePrecisionAssertTest.class);
    suite.addTestSuite(FloatAssertTest.class);
    return suite;
}

/src/test/java/junit/tests/framework/OverrideTestCase.java
==========================================================
 [Lines 8 - 9 ] {
}

/src/test/java/junit/tests/framework/AssertionFailedErrorTest.java
==================================================================
 [Lines 9 - 12 ] {
    AssertionFailedError error = new AssertionFailedError();
    assertNull(error.getMessage());
}
 [Lines 14 - 17 ] {
    AssertionFailedError error = new AssertionFailedError(ARBITRARY_MESSAGE);
    assertEquals(ARBITRARY_MESSAGE, error.getMessage());
}
 [Lines 19 - 22 ] {
    AssertionFailedError error = new AssertionFailedError(null);
    assertEquals("", error.getMessage());
}

/src/test/java/junit/tests/framework/Failure.java
=================================================
 [Lines 10 - 12 ] {
    fail();
}

/src/test/java/junit/tests/framework/AssertTest.java
====================================================
 [Lines 18 - 27 ] {
    // We have to throw the exception manually.
    try {
        fail();
    } catch (AssertionFailedError e) {
        return;
    }
    throw new AssertionFailedError();
}
 [Lines 29 - 39 ] {
    // We have to throw the exception manually.
    try {
        fail();
    } catch (AssertionFailedError e) {
        assertEquals("junit.framework.AssertionFailedError", e.toString());
        return;
    }
    throw new AssertionFailedError();
}
 [Lines 41 - 51 ] {
    // We have to throw the exception manually.
    try {
        fail("woops!");
    } catch (AssertionFailedError e) {
        assertEquals("junit.framework.AssertionFailedError: woops!", e.toString());
        return;
    }
    throw new AssertionFailedError();
}
 [Lines 53 - 62 ] {
    Object o = new Object();
    assertEquals(o, o);
    try {
        assertEquals(new Object(), new Object());
    } catch (AssertionFailedError e) {
        return;
    }
    fail();
}
 [Lines 64 - 66 ] {
    assertEquals((Object) null, (Object) null);
}
 [Lines 68 - 70 ] {
    assertEquals("a", "a");
}
 [Lines 72 - 78 ] {
    try {
        assertEquals(null, "foo");
        fail();
    } catch (ComparisonFailure e) {
    }
}
 [Lines 80 - 87 ] {
    try {
        assertEquals("foo", null);
        fail();
    } catch (ComparisonFailure e) {
        // why no assertion?
        e.getMessage();
    }
}
 [Lines 89 - 97 ] {
    try {
        assertEquals(null, new Object());
    } catch (AssertionFailedError e) {
        // why no assertion?
        e.getMessage();
        return;
    }
    fail();
}
 [Lines 99 - 107 ] {
    assertNull(null);
    try {
        assertNull(new Object());
    } catch (AssertionFailedError e) {
        return;
    }
    fail();
}
 [Lines 109 - 117 ] {
    assertNotNull(new Object());
    try {
        assertNotNull(null);
    } catch (AssertionFailedError e) {
        return;
    }
    fail();
}
 [Lines 119 - 127 ] {
    assertTrue(true);
    try {
        assertTrue(false);
    } catch (AssertionFailedError e) {
        return;
    }
    fail();
}
 [Lines 129 - 137 ] {
    assertFalse(false);
    try {
        assertFalse(true);
    } catch (AssertionFailedError e) {
        return;
    }
    fail();
}
 [Lines 139 - 148 ] {
    Object o = new Object();
    assertSame(o, o);
    try {
        assertSame(new Integer(1), new Integer(1));
    } catch (AssertionFailedError e) {
        return;
    }
    fail();
}
 [Lines 150 - 161 ] {
    assertNotSame(new Integer(1), null);
    assertNotSame(null, new Integer(1));
    assertNotSame(new Integer(1), new Integer(1));
    try {
        Integer obj = new Integer(1);
        assertNotSame(obj, obj);
    } catch (AssertionFailedError e) {
        return;
    }
    fail();
}
 [Lines 163 - 170 ] {
    try {
        assertNotSame(null, null);
    } catch (AssertionFailedError e) {
        return;
    }
    fail();
}

/src/test/java/junit/tests/framework/NoTestCases.java
=====================================================
 [Lines 9 - 10 ] {
}

/src/test/java/junit/tests/framework/ComparisonFailureTest.java
===============================================================
 [Lines 9 - 12 ] {
    ComparisonFailure failure = new ComparisonFailure("warning", "Mary had a little lamb", "Mary had the little lamb");
    assertEquals("warning expected:<Mary had [a] little lamb> but was:<Mary had [the] little lamb>", failure.getMessage());
}
 [Lines 15 - 22 ] {
    try {
        assertEquals("a", "b");
    } catch (ComparisonFailure e) {
        return;
    }
    fail();
}
 [Lines 24 - 34 ] {
    try {
        assertEquals("woops!", "a", "b");
    } catch (ComparisonFailure e) {
        if (!e.toString().startsWith("junit.framework.ComparisonFailure: woops! expected:<")) {
            fail("Unexpected message: " + e);
        }
        return;
    }
    fail();
}
 [Lines 36 - 46 ] {
    try {
        assertEquals("a", "b");
    } catch (ComparisonFailure e) {
        if (!e.toString().startsWith("junit.framework.ComparisonFailure: expected:<")) {
            fail("Unexpected message: " + e);
        }
        return;
    }
    fail();
}

/src/test/java/junit/tests/framework/ThreeTestCases.java
========================================================
 [Lines 9 - 10 ] {
}
 [Lines 12 - 13 ] {
}
 [Lines 15 - 16 ] {
}

/src/test/java/junit/tests/framework/NotPublicTestCase.java
===========================================================
 [Lines 9 - 10 ] {
}
 [Lines 12 - 13 ] {
}

/src/test/java/junit/tests/framework/TestCaseTest.java
======================================================
 [Lines 19 - 21 ] {
    fTornDown = true;
}
 [Lines 24 - 26 ] {
    throw new Error("running");
}
 [Lines 29 - 34 ] {
    // This test wins the award for twisted snake tail eating while
    // writing self tests. And you thought those weird anonymous
    // inner classes were bad...
    assertEquals("testCaseToString(junit.tests.framework.TestCaseTest)", toString());
}
 [Lines 36 - 44 ] {
    TestCase error = new TestCase("error") {

        @Override
        protected void runTest() {
            throw new Error();
        }
    };
    verifyError(error);
}
 [Lines 46 - 61 ] {
    TornDown fails = new TornDown() {

        @Override
        protected void tearDown() {
            super.tearDown();
            throw new Error();
        }

        @Override
        protected void runTest() {
            throw new Error();
        }
    };
    verifyError(fails);
    assertTrue(fails.fTornDown);
}
 [Lines 63 - 75 ] {
    TestCase fails = new TestCase("success") {

        @Override
        protected void setUp() {
            throw new Error();
        }

        @Override
        protected void runTest() {
        }
    };
    verifyError(fails);
}
 [Lines 77 - 84 ] {
    TestCase success = new TestCase("success") {

        @Override
        protected void runTest() {
        }
    };
    verifySuccess(success);
}
 [Lines 86 - 94 ] {
    TestCase failure = new TestCase("failure") {

        @Override
        protected void runTest() {
            fail();
        }
    };
    verifyFailure(failure);
}
 [Lines 96 - 100 ] {
    TornDown fails = new TornDown();
    verifyError(fails);
    assertTrue(fails.fTornDown);
}
 [Lines 102 - 114 ] {
    TestCase fails = new TestCase("success") {

        @Override
        protected void tearDown() {
            throw new Error();
        }

        @Override
        protected void runTest() {
        }
    };
    verifyError(fails);
}
 [Lines 116 - 125 ] {
    TornDown fails = new TornDown() {

        @Override
        protected void setUp() {
            throw new Error();
        }
    };
    verifyError(fails);
    assertTrue(!fails.fTornDown);
}
 [Lines 127 - 131 ] {
    WasRun test = new WasRun();
    test.run();
    assertTrue(test.fWasRun);
}
 [Lines 133 - 147 ] {
    // With 1.4, we should
    // wrap the exception thrown while running with the exception thrown
    // while tearing down
    Test t = new TornDown() {

        @Override
        public void tearDown() {
            throw new Error("tearingDown");
        }
    };
    TestResult result = new TestResult();
    t.run(result);
    TestFailure failure = result.errors().nextElement();
    assertEquals("running", failure.thrownException().getMessage());
}
 [Lines 149 - 167 ] {
    final Exception running = new Exception("Running");
    TestCase t = new TestCase() {

        @Override
        protected void runTest() throws Throwable {
            throw running;
        }

        @Override
        protected void tearDown() throws Exception {
            throw new Error("Tearing down");
        }
    };
    try {
        t.runBare();
    } catch (Throwable thrown) {
        assertSame(running, thrown);
    }
}
 [Lines 169 - 176 ] {
    Test t = new TestSuite(NoArgTestCaseTest.class);
    TestResult result = new TestResult();
    t.run(result);
    assertTrue(result.runCount() == 1);
    assertTrue(result.failureCount() == 0);
    assertTrue(result.errorCount() == 0);
}
 [Lines 178 - 183 ] {
    TestCase t = new TestCase() {
    };
    TestResult result = t.run();
    assertEquals(1, result.failureCount());
}
 [Lines 185 - 190 ] {
    TestResult result = test.run();
    assertTrue(result.runCount() == 1);
    assertTrue(result.failureCount() == 0);
    assertTrue(result.errorCount() == 1);
}
 [Lines 192 - 197 ] {
    TestResult result = test.run();
    assertTrue(result.runCount() == 1);
    assertTrue(result.failureCount() == 1);
    assertTrue(result.errorCount() == 0);
}
 [Lines 199 - 204 ] {
    TestResult result = test.run();
    assertTrue(result.runCount() == 1);
    assertTrue(result.failureCount() == 0);
    assertTrue(result.errorCount() == 0);
}

/src/test/java/junit/tests/framework/InheritedTestCase.java
===========================================================
 [Lines 7 - 8 ] {
}

/src/test/java/junit/tests/framework/OneTestCase.java
=====================================================
 [Lines 9 - 10 ] {
}
 [Lines 12 - 13 ] {
}
 [Lines 15 - 16 ] {
}

/src/test/java/junit/tests/framework/TestListenerTest.java
==========================================================
 [Lines 19 - 21 ] {
    fErrorCount++;
}
 [Lines 23 - 25 ] {
    fFailureCount++;
}
 [Lines 27 - 29 ] {
    fEndCount++;
}
 [Lines 32 - 40 ] {
    fResult = new TestResult();
    fResult.addListener(this);
    fStartCount = 0;
    fEndCount = 0;
    fFailureCount = 0;
    fErrorCount = 0;
}
 [Lines 42 - 44 ] {
    fStartCount++;
}
 [Lines 46 - 56 ] {
    TestCase test = new TestCase("noop") {

        @Override
        public void runTest() {
            throw new Error();
        }
    };
    test.run(fResult);
    assertEquals(1, fErrorCount);
    assertEquals(1, fEndCount);
}
 [Lines 58 - 68 ] {
    TestCase test = new TestCase("noop") {

        @Override
        public void runTest() {
            fail();
        }
    };
    test.run(fResult);
    assertEquals(1, fFailureCount);
    assertEquals(1, fEndCount);
}
 [Lines 70 - 79 ] {
    TestCase test = new TestCase("noop") {

        @Override
        public void runTest() {
        }
    };
    test.run(fResult);
    assertEquals(1, fStartCount);
    assertEquals(1, fEndCount);
}

/src/test/java/junit/tests/framework/SuiteTest.java
===================================================
 [Lines 16 - 18 ] {
    super(name);
}
 [Lines 21 - 23 ] {
    fResult = new TestResult();
}
 [Lines 25 - 42 ] {
    TestSuite suite = new TestSuite("Suite Tests");
    // build the suite manually, because some of the suites are testing
    // the functionality that automatically builds suites
    suite.addTest(new SuiteTest("testNoTestCases"));
    suite.addTest(new SuiteTest("testOneTestCase"));
    suite.addTest(new SuiteTest("testNotPublicTestCase"));
    suite.addTest(new SuiteTest("testNotVoidTestCase"));
    suite.addTest(new SuiteTest("testNotExistingTestCase"));
    suite.addTest(new SuiteTest("testInheritedTests"));
    suite.addTest(new SuiteTest("testOneTestCaseEclipseSeesSameStructureAs381"));
    suite.addTest(new SuiteTest("testNoTestCaseClass"));
    suite.addTest(new SuiteTest("testShadowedTests"));
    suite.addTest(new SuiteTest("testAddTestSuite"));
    suite.addTest(new SuiteTest("testCreateSuiteFromArray"));
    return suite;
}
 [Lines 44 - 49 ] {
    TestSuite suite = new TestSuite(InheritedTestCase.class);
    suite.run(fResult);
    assertTrue(fResult.wasSuccessful());
    assertEquals(2, fResult.runCount());
}
 [Lines 51 - 56 ] {
    Test t = new TestSuite(NoTestCaseClass.class);
    t.run(fResult);
    // warning test
    assertEquals(1, fResult.runCount());
    assertTrue(!fResult.wasSuccessful());
}
 [Lines 58 - 64 ] {
    Test t = new TestSuite(NoTestCases.class);
    t.run(fResult);
    // warning test
    assertTrue(fResult.runCount() == 1);
    assertTrue(fResult.failureCount() == 1);
    assertTrue(!fResult.wasSuccessful());
}
 [Lines 66 - 72 ] {
    Test t = new SuiteTest("notExistingMethod");
    t.run(fResult);
    assertTrue(fResult.runCount() == 1);
    assertTrue(fResult.failureCount() == 1);
    assertTrue(fResult.errorCount() == 0);
}
 [Lines 74 - 78 ] {
    TestSuite suite = new TestSuite(NotPublicTestCase.class);
    // 1 public test case + 1 warning for the non-public test case
    assertEquals(2, suite.countTestCases());
}
 [Lines 80 - 83 ] {
    TestSuite suite = new TestSuite(NotVoidTestCase.class);
    assertTrue(suite.countTestCases() == 1);
}
 [Lines 85 - 92 ] {
    TestSuite t = new TestSuite(OneTestCase.class);
    t.run(fResult);
    assertTrue(fResult.runCount() == 1);
    assertTrue(fResult.failureCount() == 0);
    assertTrue(fResult.errorCount() == 0);
    assertTrue(fResult.wasSuccessful());
}
 [Lines 94 - 97 ] {
    TestSuite t = new TestSuite(ThreeTestCases.class);
    assertEquals(3, Collections.list(t.tests()).size());
}
 [Lines 99 - 103 ] {
    TestSuite suite = new TestSuite(OverrideTestCase.class);
    suite.run(fResult);
    assertEquals(1, fResult.runCount());
}
 [Lines 105 - 110 ] {
    TestSuite suite = new TestSuite();
    suite.addTestSuite(OneTestCase.class);
    suite.run(fResult);
    assertEquals(1, fResult.runCount());
}
 [Lines 112 - 117 ] {
    TestSuite suite = new TestSuite(OneTestCase.class, DoublePrecisionAssertTest.class);
    assertEquals(2, suite.testCount());
    assertEquals("junit.tests.framework.DoublePrecisionAssertTest", ((TestSuite) suite.testAt(1)).getName());
    assertEquals("junit.tests.framework.OneTestCase", ((TestSuite) suite.testAt(0)).getName());
}

/src/test/java/junit/tests/framework/FloatAssertTest.java
=========================================================
 [Lines 11 - 17 ] {
    try {
        assertEquals(1.234f, Float.NaN, 0.0);
        fail();
    } catch (AssertionFailedError e) {
    }
}
 [Lines 19 - 25 ] {
    try {
        assertEquals(Float.NaN, 1.234f, 0.0);
        fail();
    } catch (AssertionFailedError e) {
    }
}
 [Lines 27 - 29 ] {
    assertEquals(Float.NaN, Float.NaN, 0.0);
}
 [Lines 31 - 37 ] {
    try {
        assertEquals(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY, 0.0);
        fail();
    } catch (AssertionFailedError e) {
    }
}
 [Lines 39 - 45 ] {
    try {
        assertEquals(Float.POSITIVE_INFINITY, 1.23f, 0.0);
        fail();
    } catch (AssertionFailedError e) {
    }
}
 [Lines 47 - 49 ] {
    assertEquals(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 0.0);
}
 [Lines 51 - 53 ] {
    assertEquals(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 0.0);
}
 [Lines 55 - 61 ] {
    try {
        assertEquals(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);
        fail();
    } catch (AssertionFailedError e) {
    }
}

/src/test/java/junit/tests/framework/NotVoidTestCase.java
=========================================================
 [Lines 9 - 11 ] {
    return 1;
}
 [Lines 13 - 14 ] {
}

/src/test/java/junit/tests/framework/TestImplementorTest.java
=============================================================
 [Lines 15 - 17 ] {
    fTestCase = testCase;
}
 [Lines 19 - 21 ] {
    return 2;
}
 [Lines 23 - 33 ] {
    result.startTest(this);
    Protectable p = new Protectable() {

        public void protect() throws Throwable {
            fTestCase.runBare();
            fTestCase.runBare();
        }
    };
    result.runProtected(this, p);
    result.endTest(this);
}
 [Lines 38 - 45 ] {
    TestCase testCase = new TestCase() {

        @Override
        public void runTest() {
        }
    };
    fTest = new DoubleTestCase(testCase);
}
 [Lines 47 - 53 ] {
    TestResult result = new TestResult();
    fTest.run(result);
    assertEquals(fTest.countTestCases(), result.runCount());
    assertEquals(0, result.errorCount());
    assertEquals(0, result.failureCount());
}

/src/test/java/junit/tests/framework/NoArgTestCaseTest.java
===========================================================
 [Lines 6 - 7 ] {
// If this compiles, the no arg ctor is there
}

/src/test/java/junit/tests/framework/ComparisonCompactorTest.java
=================================================================
 [Lines 8 - 11 ] {
    String failure = new ComparisonCompactor(0, "b", "c").compact("a");
    assertTrue("a expected:<[b]> but was:<[c]>".equals(failure));
}
 [Lines 13 - 16 ] {
    String failure = new ComparisonCompactor(1, "ba", "bc").compact(null);
    assertEquals("expected:<b[a]> but was:<b[c]>", failure);
}
 [Lines 18 - 21 ] {
    String failure = new ComparisonCompactor(1, "ab", "cb").compact(null);
    assertEquals("expected:<[a]b> but was:<[c]b>", failure);
}
 [Lines 23 - 26 ] {
    String failure = new ComparisonCompactor(1, "ab", "ab").compact(null);
    assertEquals("expected:<ab> but was:<ab>", failure);
}
 [Lines 28 - 31 ] {
    String failure = new ComparisonCompactor(0, "abc", "adc").compact(null);
    assertEquals("expected:<...[b]...> but was:<...[d]...>", failure);
}
 [Lines 33 - 36 ] {
    String failure = new ComparisonCompactor(1, "abc", "adc").compact(null);
    assertEquals("expected:<a[b]c> but was:<a[d]c>", failure);
}
 [Lines 38 - 41 ] {
    String failure = new ComparisonCompactor(1, "abcde", "abfde").compact(null);
    assertEquals("expected:<...b[c]d...> but was:<...b[f]d...>", failure);
}
 [Lines 43 - 46 ] {
    String failure = new ComparisonCompactor(2, "ab", "abc").compact(null);
    assertEquals("expected:<ab[]> but was:<ab[c]>", failure);
}
 [Lines 48 - 51 ] {
    String failure = new ComparisonCompactor(0, "bc", "abc").compact(null);
    assertEquals("expected:<[]...> but was:<[a]...>", failure);
}
 [Lines 53 - 56 ] {
    String failure = new ComparisonCompactor(2, "bc", "abc").compact(null);
    assertEquals("expected:<[]bc> but was:<[a]bc>", failure);
}
 [Lines 58 - 61 ] {
    String failure = new ComparisonCompactor(0, "abc", "abbc").compact(null);
    assertEquals("expected:<...[]...> but was:<...[b]...>", failure);
}
 [Lines 63 - 66 ] {
    String failure = new ComparisonCompactor(2, "abc", "abbc").compact(null);
    assertEquals("expected:<ab[]c> but was:<ab[b]c>", failure);
}
 [Lines 68 - 71 ] {
    String failure = new ComparisonCompactor(0, "abcdde", "abcde").compact(null);
    assertEquals("expected:<...[d]...> but was:<...[]...>", failure);
}
 [Lines 73 - 76 ] {
    String failure = new ComparisonCompactor(2, "abcdde", "abcde").compact(null);
    assertEquals("expected:<...cd[d]e> but was:<...cd[]e>", failure);
}
 [Lines 78 - 81 ] {
    String failure = new ComparisonCompactor(0, "a", null).compact(null);
    assertEquals("expected:<a> but was:<null>", failure);
}
 [Lines 83 - 86 ] {
    String failure = new ComparisonCompactor(2, "a", null).compact(null);
    assertEquals("expected:<a> but was:<null>", failure);
}
 [Lines 88 - 91 ] {
    String failure = new ComparisonCompactor(0, null, "a").compact(null);
    assertEquals("expected:<null> but was:<a>", failure);
}
 [Lines 93 - 96 ] {
    String failure = new ComparisonCompactor(2, null, "a").compact(null);
    assertEquals("expected:<null> but was:<a>", failure);
}
 [Lines 98 - 101 ] {
    String failure = new ComparisonCompactor(10, "S&P500", "0").compact(null);
    assertEquals("expected:<[S&P50]0> but was:<[]0>", failure);
}

/src/test/java/junit/tests/framework/Success.java
=================================================
 [Lines 11 - 12 ] {
}
 [Lines 14 - 15 ] {
}

/src/test/java/junit/tests/framework/NoTestCaseClass.java
=========================================================
 [Lines 7 - 8 ] {
}

/src/test/java/junit/tests/framework/package-info.java
======================================================

/src/test/java/junit/tests/framework/DoublePrecisionAssertTest.java
===================================================================
 [Lines 11 - 17 ] {
    try {
        assertEquals(1.234, Double.NaN, 0.0);
        fail();
    } catch (AssertionFailedError e) {
    }
}
 [Lines 19 - 25 ] {
    try {
        assertEquals(Double.NaN, 1.234, 0.0);
        fail();
    } catch (AssertionFailedError e) {
    }
}
 [Lines 27 - 29 ] {
    assertEquals(Double.NaN, Double.NaN, 0.0);
}
 [Lines 31 - 37 ] {
    try {
        assertEquals(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0.0);
        fail();
    } catch (AssertionFailedError e) {
    }
}
 [Lines 39 - 45 ] {
    try {
        assertEquals(Double.POSITIVE_INFINITY, 1.23, 0.0);
        fail();
    } catch (AssertionFailedError e) {
    }
}
 [Lines 47 - 49 ] {
    assertEquals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 0.0);
}
 [Lines 51 - 53 ] {
    assertEquals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 0.0);
}

/src/test/java/junit/tests/runner/AllTests.java
===============================================
 [Lines 11 - 13 ] {
    junit.textui.TestRunner.run(suite());
}
 [Lines 15 - 24 ] {
    // Collect tests manually because we have to test class collection code
    TestSuite suite = new TestSuite("Framework Tests");
    suite.addTestSuite(StackFilterTest.class);
    suite.addTestSuite(ResultTest.class);
    suite.addTestSuite(BaseTestRunnerTest.class);
    suite.addTestSuite(TextFeedbackTest.class);
    suite.addTestSuite(TextRunnerSingleMethodTest.class);
    suite.addTestSuite(TextRunnerTest.class);
    return suite;
}
 [Lines 26 - 29 ] {
    String version = System.getProperty("java.version");
    return version.startsWith("1.1");
}

/src/test/java/junit/tests/runner/BaseTestRunnerTest.java
=========================================================
 [Lines 13 - 15 ] {
    fRunFailed = true;
}
 [Lines 18 - 19 ] {
}
 [Lines 22 - 23 ] {
}
 [Lines 26 - 27 ] {
}
 [Lines 31 - 33 ] {
    return null;
}
 [Lines 36 - 39 ] {
    BaseTestRunner runner = new MockRunner();
    // Used to throw NullPointerException
    runner.getTest("junit.tests.runner.BaseTestRunnerTest$NonStatic");
}
 [Lines 42 - 44 ] {
    return new TestSuite();
}
 [Lines 47 - 51 ] {
    MockRunner runner = new MockRunner();
    runner.getTest(DoesntExtendTestCase.class.getName());
    assertFalse(runner.fRunFailed);
}

/src/test/java/junit/tests/runner/TextFeedbackTest.java
=======================================================
 [Lines 19 - 21 ] {
    super(writer);
}
 [Lines 26 - 28 ] {
    return "0";
}
 [Lines 31 - 33 ] {
    TestRunner.run(TextFeedbackTest.class);
}
 [Lines 36 - 39 ] {
    output = new ByteArrayOutputStream();
    runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));
}
 [Lines 41 - 45 ] {
    String expected = expected(new String[] { "", "Time: 0", "", "OK (0 tests)", "" });
    runner.doRun(new TestSuite());
    assertEquals(expected, output.toString());
}
 [Lines 48 - 58 ] {
    String expected = expected(new String[] { ".", "Time: 0", "", "OK (1 test)", "" });
    TestSuite suite = new TestSuite();
    suite.addTest(new TestCase() {

        @Override
        public void runTest() {
        }
    });
    runner.doRun(suite);
    assertEquals(expected, output.toString());
}
 [Lines 60 - 75 ] {
    String expected = expected(new String[] { "..", "Time: 0", "", "OK (2 tests)", "" });
    TestSuite suite = new TestSuite();
    suite.addTest(new TestCase() {

        @Override
        public void runTest() {
        }
    });
    suite.addTest(new TestCase() {

        @Override
        public void runTest() {
        }
    });
    runner.doRun(suite);
    assertEquals(expected, output.toString());
}
 [Lines 77 - 95 ] {
    String expected = expected(new String[] { ".F", "Time: 0", "Failures here", "", "FAILURES!!!", "Tests run: 1,  Failures: 1,  Errors: 0", "" });
    ResultPrinter printer = new TestResultPrinter(new PrintStream(output)) {

        @Override
        public void printFailures(TestResult result) {
            getWriter().println("Failures here");
        }
    };
    runner.setPrinter(printer);
    TestSuite suite = new TestSuite();
    suite.addTest(new TestCase() {

        @Override
        public void runTest() {
            throw new AssertionFailedError();
        }
    });
    runner.doRun(suite);
    assertEquals(expected, output.toString());
}
 [Lines 97 - 115 ] {
    String expected = expected(new String[] { ".E", "Time: 0", "Errors here", "", "FAILURES!!!", "Tests run: 1,  Failures: 0,  Errors: 1", "" });
    ResultPrinter printer = new TestResultPrinter(new PrintStream(output)) {

        @Override
        public void printErrors(TestResult result) {
            getWriter().println("Errors here");
        }
    };
    runner.setPrinter(printer);
    TestSuite suite = new TestSuite();
    suite.addTest(new TestCase() {

        @Override
        public void runTest() throws Exception {
            throw new Exception();
        }
    });
    runner.doRun(suite);
    assertEquals(expected, output.toString());
}
 [Lines 117 - 124 ] {
    OutputStream expected = new ByteArrayOutputStream();
    PrintStream expectedWriter = new PrintStream(expected);
    for (int i = 0; i < lines.length; i++) {
        expectedWriter.println(lines[i]);
    }
    return expected.toString();
}

/src/test/java/junit/tests/runner/StackFilterTest.java
======================================================
 [Lines 14 - 41 ] {
    StringWriter swin = new StringWriter();
    PrintWriter pwin = new PrintWriter(swin);
    pwin.println("junit.framework.AssertionFailedError");
    pwin.println("	at junit.framework.Assert.fail(Assert.java:144)");
    pwin.println("	at junit.framework.Assert.assert(Assert.java:19)");
    pwin.println("	at junit.framework.Assert.assert(Assert.java:26)");
    pwin.println("	at MyTest.f(MyTest.java:13)");
    pwin.println("	at MyTest.testStackTrace(MyTest.java:8)");
    pwin.println("	at java.lang.reflect.Method.invoke(Native Method)");
    pwin.println("	at junit.framework.TestCase.runTest(TestCase.java:156)");
    pwin.println("	at junit.framework.TestCase.runBare(TestCase.java:130)");
    pwin.println("	at junit.framework.TestResult$1.protect(TestResult.java:100)");
    pwin.println("	at junit.framework.TestResult.runProtected(TestResult.java:118)");
    pwin.println("	at junit.framework.TestResult.run(TestResult.java:103)");
    pwin.println("	at junit.framework.TestCase.run(TestCase.java:121)");
    pwin.println("	at junit.framework.TestSuite.runTest(TestSuite.java:157)");
    pwin.println("	at junit.framework.TestSuite.run(TestSuite.java, Compiled Code)");
    pwin.println("	at junit.swingui.TestRunner$17.run(TestRunner.java:669)");
    fUnfiltered = swin.toString();
    StringWriter swout = new StringWriter();
    PrintWriter pwout = new PrintWriter(swout);
    pwout.println("junit.framework.AssertionFailedError");
    pwout.println("	at MyTest.f(MyTest.java:13)");
    pwout.println("	at MyTest.testStackTrace(MyTest.java:8)");
    fFiltered = swout.toString();
}
 [Lines 43 - 45 ] {
    assertEquals(fFiltered, BaseTestRunner.getFilteredTrace(fUnfiltered));
}

/src/test/java/junit/tests/runner/ResultTest.java
=================================================
 [Lines 20 - 24 ] {
    JUnitCore runner = new JUnitCore();
    Result result = runner.run(AnnotationTest.FailureTest.class);
    assertResultSerializable(result);
}
 [Lines 26 - 30 ] {
    JUnitCore runner = new JUnitCore();
    Result result = runner.run(Success.class);
    assertResultSerializable(result);
}
 [Lines 32 - 46 ] {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    new ObjectOutputStream(byteArrayOutputStream).writeObject(result);
    byte[] bytes = byteArrayOutputStream.toByteArray();
    ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));
    Result fromStream = (Result) objectInputStream.readObject();
    assertSerializedCorrectly(result, fromStream);
    InputStream resource = getClass().getResourceAsStream(getName());
    assertNotNull("Could not read resource " + getName(), resource);
    objectInputStream = new ObjectInputStream(resource);
    fromStream = (Result) objectInputStream.readObject();
    assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream);
}
 [Lines 58 - 60 ] {
    this.delegate = delegate;
}
 [Lines 63 - 65 ] {
    return delegate.getRunCount();
}
 [Lines 68 - 70 ] {
    return delegate.getFailureCount();
}
 [Lines 73 - 75 ] {
    return 2;
}
 [Lines 78 - 80 ] {
    return delegate.getFailures();
}
 [Lines 83 - 85 ] {
    return delegate.getIgnoreCount();
}
 [Lines 88 - 109 ] {
    assertNotNull(fromStream);
    // Exceptions don't implement equals() so we need to compare field by field
    assertEquals("failureCount", result.getFailureCount(), fromStream.getFailureCount());
    assertEquals("ignoreCount", result.getIgnoreCount(), fromStream.getIgnoreCount());
    assertEquals("runTime", result.getRunTime(), fromStream.getRunTime());
    assertEquals("failures", result.getFailures().size(), fromStream.getFailures().size());
    int index = 0;
    for (Failure failure : result.getFailures()) {
        Failure failureFromStream = fromStream.getFailures().get(index);
        String messagePrefix = String.format("failures[%d]", index++);
        assertEquals(messagePrefix + ".description", failure.getDescription(), failureFromStream.getDescription());
        Throwable exception = failure.getException();
        Throwable exceptionFromStream = failureFromStream.getException();
        assertEquals(messagePrefix + ".exception", exception.getClass(), exceptionFromStream.getClass());
        assertEquals(messagePrefix + ".exception", exception.getMessage(), exceptionFromStream.getMessage());
    }
}

/src/test/java/junit/tests/runner/TextRunnerSingleMethodTest.java
=================================================================
 [Lines 19 - 21 ] {
    TextRunnerSingleMethodTest.fgWasInvoked = true;
}
 [Lines 23 - 25 ] {
    fail("Shouldn't get here.");
}
 [Lines 28 - 37 ] {
    TestRunner t = new TestRunner();
    t.setPrinter(new ResultPrinter(new PrintStream(new ByteArrayOutputStream())));
    String[] args = { "-m", "junit.tests.runner.TextRunnerSingleMethodTest$InvocationTest.testWasInvoked" };
    fgWasInvoked = false;
    t.start(args);
    assertTrue(fgWasInvoked);
}

/src/test/java/junit/tests/runner/TextRunnerTest.java
=====================================================
 [Lines 15 - 17 ] {
    execTest("junit.tests.framework.Failure", false);
}
 [Lines 19 - 21 ] {
    execTest("junit.tests.framework.Success", true);
}
 [Lines 23 - 25 ] {
    execTest("junit.tests.BogusDude", false);
}
 [Lines 27 - 42 ] {
    String java = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
    String cp = System.getProperty("java.class.path");
    //use -classpath for JDK 1.1.7 compatibility
    String[] cmd = { java, "-classpath", cp, "junit.textui.TestRunner", testClass };
    Process p = Runtime.getRuntime().exec(cmd);
    InputStream i = p.getInputStream();
    while ((i.read()) != -1) //System.out.write(b);
    ;
    assertTrue((p.waitFor() == 0) == success);
    if (success) {
        assertTrue(p.exitValue() == 0);
    } else {
        assertFalse(p.exitValue() == 0);
    }
}
 [Lines 44 - 59 ] {
    PrintStream oldOut = System.out;
    System.setOut(new PrintStream(new OutputStream() {

        @Override
        public void write(int arg0) throws IOException {
        }
    }));
    try {
        TestResult result = junit.textui.TestRunner.run(new TestSuite());
        assertTrue(result.wasSuccessful());
    } finally {
        System.setOut(oldOut);
    }
}

/src/test/java/junit/tests/runner/package-info.java
===================================================

/src/test/java/junit/tests/extensions/AllTests.java
===================================================
 [Lines 11 - 13 ] {
    junit.textui.TestRunner.run(suite());
}
 [Lines 15 - 21 ] {
    // Collect tests manually because we have to test class collection code
    TestSuite suite = new TestSuite("Framework Tests");
    suite.addTestSuite(ExtensionTest.class);
    suite.addTestSuite(ActiveTestTest.class);
    suite.addTestSuite(RepeatedTestTest.class);
    return suite;
}

/src/test/java/junit/tests/extensions/ActiveTestTest.java
=========================================================
 [Lines 16 - 17 ] {
}
 [Lines 20 - 27 ] {
    Test test = createActiveTestSuite();
    TestResult result = new TestResult();
    test.run(result);
    assertEquals(100, result.runCount());
    assertEquals(0, result.failureCount());
    assertEquals(0, result.errorCount());
}
 [Lines 29 - 36 ] {
    Test test = new RepeatedTest(createActiveTestSuite(), 5);
    TestResult result = new TestResult();
    test.run(result);
    assertEquals(500, result.runCount());
    assertEquals(0, result.failureCount());
    assertEquals(0, result.errorCount());
}
 [Lines 38 - 45 ] {
    Test test = new RepeatedTest(createActiveTestSuite(), 0);
    TestResult result = new TestResult();
    test.run(result);
    assertEquals(0, result.runCount());
    assertEquals(0, result.failureCount());
    assertEquals(0, result.errorCount());
}
 [Lines 47 - 54 ] {
    Test test = new RepeatedTest(createActiveTestSuite(), 1);
    TestResult result = new TestResult();
    test.run(result);
    assertEquals(100, result.runCount());
    assertEquals(0, result.failureCount());
    assertEquals(0, result.errorCount());
}
 [Lines 56 - 62 ] {
    ActiveTestSuite suite = new ActiveTestSuite();
    for (int i = 0; i < 100; i++) {
        suite.addTest(new SuccessTest());
    }
    return suite;
}

/src/test/java/junit/tests/extensions/RepeatedTestTest.java
===========================================================
 [Lines 18 - 19 ] {
}
 [Lines 22 - 27 ] {
    super(name);
    fSuite = new TestSuite();
    fSuite.addTest(new SuccessTest());
    fSuite.addTest(new SuccessTest());
}
 [Lines 29 - 35 ] {
    Test test = new RepeatedTest(fSuite, 1);
    assertEquals(2, test.countTestCases());
    TestResult result = new TestResult();
    test.run(result);
    assertEquals(2, result.runCount());
}
 [Lines 37 - 43 ] {
    Test test = new RepeatedTest(fSuite, 3);
    assertEquals(6, test.countTestCases());
    TestResult result = new TestResult();
    test.run(result);
    assertEquals(6, result.runCount());
}
 [Lines 45 - 51 ] {
    Test test = new RepeatedTest(fSuite, 0);
    assertEquals(0, test.countTestCases());
    TestResult result = new TestResult();
    test.run(result);
    assertEquals(0, result.runCount());
}
 [Lines 53 - 61 ] {
    try {
        new RepeatedTest(fSuite, -1);
    } catch (IllegalArgumentException e) {
        assertTrue(e.getMessage().contains(">="));
        return;
    }
    fail("Should throw an IllegalArgumentException");
}

/src/test/java/junit/tests/extensions/ExtensionTest.java
========================================================
 [Lines 17 - 19 ] {
    super(test);
}
 [Lines 22 - 24 ] {
    fTornDown = true;
}
 [Lines 27 - 40 ] {
    TestCase test = new TestCase("failure") {

        @Override
        public void runTest() {
            fail();
        }
    };
    TestSetup wrapper = new TestSetup(test);
    TestResult result = new TestResult();
    wrapper.run(result);
    assertTrue(!result.wasSuccessful());
}
 [Lines 42 - 68 ] {
    TestCase failure = new TestCase("failure") {

        @Override
        public void runTest() {
            fail();
        }
    };
    TestCase error = new TestCase("error") {

        @Override
        public void runTest() {
            throw new Error();
        }
    };
    TestSuite suite = new TestSuite();
    suite.addTest(failure);
    suite.addTest(error);
    TestSetup wrapper = new TestSetup(suite);
    TestResult result = new TestResult();
    wrapper.run(result);
    assertEquals(1, result.failureCount());
    assertEquals(1, result.errorCount());
}
 [Lines 70 - 85 ] {
    WasRun test = new WasRun();
    TornDown wrapper = new TornDown(test) {

        @SuppressWarnings("deprecation")
        @Override
        public void setUp() {
            fail();
        }
    };
    TestResult result = new TestResult();
    wrapper.run(result);
    assertTrue(!wrapper.fTornDown);
}
 [Lines 87 - 103 ] {
    WasRun test = new WasRun();
    TestSetup wrapper = new TestSetup(test) {

        @SuppressWarnings("deprecation")
        @Override
        public void setUp() {
            fail();
        }
    };
    TestResult result = new TestResult();
    wrapper.run(result);
    assertTrue(!test.fWasRun);
    assertTrue(!result.wasSuccessful());
}

/src/test/java/junit/tests/extensions/package-info.java
=======================================================

/src/test/java/junit/tests/WasRun.java
======================================
 [Lines 13 - 15 ] {
    fWasRun = true;
}

/src/test/java/junit/tests/package-info.java
============================================

/src/test/java/junit/samples/AllTests.java
==========================================
 [Lines 11 - 13 ] {
    junit.textui.TestRunner.run(suite());
}
 [Lines 15 - 21 ] {
    TestSuite suite = new TestSuite("All JUnit Tests");
    suite.addTest(ListTest.suite());
    suite.addTest(new TestSuite(junit.samples.money.MoneyTest.class));
    suite.addTest(junit.tests.AllTests.suite());
    return suite;
}

/src/test/java/junit/samples/ListTest.java
==========================================
 [Lines 17 - 19 ] {
    junit.textui.TestRunner.run(suite());
}
 [Lines 22 - 28 ] {
    fEmpty = new ArrayList<Integer>();
    fFull = new ArrayList<Integer>();
    fFull.add(1);
    fFull.add(2);
    fFull.add(3);
}
 [Lines 30 - 32 ] {
    return new TestSuite(ListTest.class);
}
 [Lines 34 - 40 ] {
    int size = fFull.size();
    for (int i = 0; i < 100; i++) {
        fFull.add(new Integer(i));
    }
    assertTrue(fFull.size() == 100 + size);
}
 [Lines 42 - 45 ] {
    assertTrue(fFull.contains(1));
    assertTrue(!fEmpty.contains(1));
}
 [Lines 47 - 57 ] {
    int i = fFull.get(0);
    assertTrue(i == 1);
    try {
        fFull.get(fFull.size());
    } catch (IndexOutOfBoundsException e) {
        return;
    }
    fail("Should raise an ArrayIndexOutOfBoundsException");
}
 [Lines 59 - 64 ] {
    fFull.removeAll(fFull);
    fEmpty.removeAll(fEmpty);
    assertTrue(fFull.isEmpty());
    assertTrue(fEmpty.isEmpty());
}
 [Lines 66 - 69 ] {
    fFull.remove(new Integer(3));
    assertTrue(!fFull.contains(3));
}

/src/test/java/junit/samples/SimpleTest.java
============================================
 [Lines 15 - 18 ] {
    fValue1 = 2;
    fValue2 = 3;
}
 [Lines 20 - 44 ] {
    /*
           * the dynamic way
           */
    return new TestSuite(SimpleTest.class);
}
 [Lines 46 - 50 ] {
    double result = fValue1 + fValue2;
    // forced failure result == 5
    assertTrue(result == 6);
}
 [Lines 54 - 58 ] {
    int zero = 0;
    int result = 8 / zero;
    // avoid warning for not using result
    unused = result;
}
 [Lines 60 - 67 ] {
    assertEquals(12, 12);
    assertEquals(12L, 12L);
    assertEquals(new Long(12), new Long(12));
    assertEquals("Size", 12, 13);
    assertEquals("Capacity", 12.0, 11.99, 0.0);
}
 [Lines 69 - 71 ] {
    junit.textui.TestRunner.run(suite());
}

/src/test/java/junit/samples/money/MoneyTest.java
=================================================
 [Lines 14 - 16 ] {
    junit.textui.TestRunner.run(MoneyTest.class);
}
 [Lines 19 - 27 ] {
    f12CHF = new Money(12, "CHF");
    f14CHF = new Money(14, "CHF");
    f7USD = new Money(7, "USD");
    f21USD = new Money(21, "USD");
    fMB1 = MoneyBag.create(f12CHF, f7USD);
    fMB2 = MoneyBag.create(f14CHF, f21USD);
}
 [Lines 29 - 35 ] {
    // {[12 CHF][7 USD]} *2 == {[24 CHF][14 USD]}
    IMoney expected = MoneyBag.create(new Money(24, "CHF"), new Money(14, "USD"));
    assertEquals(expected, fMB1.multiply(2));
    assertEquals(fMB1, fMB1.multiply(1));
    assertTrue(fMB1.multiply(0).isZero());
}
 [Lines 37 - 41 ] {
    // {[12 CHF][7 USD]} negate == {[-12 CHF][-7 USD]}
    IMoney expected = MoneyBag.create(new Money(-12, "CHF"), new Money(-7, "USD"));
    assertEquals(expected, fMB1.negate());
}
 [Lines 43 - 47 ] {
    // {[12 CHF][7 USD]} + [14 CHF] == {[26 CHF][7 USD]}
    IMoney expected = MoneyBag.create(new Money(26, "CHF"), new Money(7, "USD"));
    assertEquals(expected, fMB1.add(f14CHF));
}
 [Lines 49 - 53 ] {
    // {[12 CHF][7 USD]} - {[14 CHF][21 USD] == {[-2 CHF][-14 USD]}
    IMoney expected = MoneyBag.create(new Money(-2, "CHF"), new Money(-14, "USD"));
    assertEquals(expected, fMB1.subtract(fMB2));
}
 [Lines 55 - 59 ] {
    // {[12 CHF][7 USD]} + {[14 CHF][21 USD]} == {[26 CHF][28 USD]}
    IMoney expected = MoneyBag.create(new Money(26, "CHF"), new Money(28, "USD"));
    assertEquals(expected, fMB1.add(fMB2));
}
 [Lines 61 - 64 ] {
    assertTrue(fMB1.subtract(fMB1).isZero());
    assertTrue(MoneyBag.create(new Money(0, "CHF"), new Money(0, "USD")).isZero());
}
 [Lines 66 - 70 ] {
    // [12 CHF] + [7 USD] == {[12 CHF][7 USD]}
    IMoney expected = MoneyBag.create(f12CHF, f7USD);
    assertEquals(expected, f12CHF.add(f7USD));
}
 [Lines 72 - 75 ] {
    IMoney bag = MoneyBag.create(f12CHF, f7USD);
    assertFalse(bag.equals(new Money(12, "DEM").add(f7USD)));
}
 [Lines 77 - 86 ] {
    assertTrue(!fMB1.equals(null));
    assertEquals(fMB1, fMB1);
    IMoney equal = MoneyBag.create(new Money(12, "CHF"), new Money(7, "USD"));
    assertTrue(fMB1.equals(equal));
    assertTrue(!fMB1.equals(f12CHF));
    assertTrue(!f12CHF.equals(fMB1));
    assertTrue(!fMB1.equals(fMB2));
}
 [Lines 88 - 91 ] {
    IMoney equal = MoneyBag.create(new Money(12, "CHF"), new Money(7, "USD"));
    assertEquals(fMB1.hashCode(), equal.hashCode());
}
 [Lines 93 - 100 ] {
    assertTrue(!f12CHF.equals(null));
    Money equalMoney = new Money(12, "CHF");
    assertEquals(f12CHF, f12CHF);
    assertEquals(f12CHF, equalMoney);
    assertEquals(f12CHF.hashCode(), equalMoney.hashCode());
    assertTrue(!f12CHF.equals(f14CHF));
}
 [Lines 102 - 106 ] {
    assertTrue(!f12CHF.equals(null));
    Money equal = new Money(12, "CHF");
    assertEquals(f12CHF.hashCode(), equal.hashCode());
}
 [Lines 108 - 111 ] {
    IMoney money = MoneyBag.create(new Money(26, "CHF"), new Money(28, "CHF"));
    assertEquals(new Money(54, "CHF"), money);
}
 [Lines 113 - 117 ] {
    // {[12 CHF][7 USD]} - [12 CHF] == [7 USD]
    Money expected = new Money(7, "USD");
    assertEquals(expected, fMB1.subtract(f12CHF));
}
 [Lines 119 - 124 ] {
    // {[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]
    IMoney ms1 = MoneyBag.create(new Money(12, "CHF"), new Money(3, "USD"));
    Money expected = new Money(4, "USD");
    assertEquals(expected, fMB1.subtract(ms1));
}
 [Lines 126 - 131 ] {
    // [12 CHF] - {[12 CHF][3 USD]} == [-3 USD]
    IMoney ms1 = MoneyBag.create(new Money(12, "CHF"), new Money(3, "USD"));
    Money expected = new Money(-3, "USD");
    assertEquals(expected, f12CHF.subtract(ms1));
}
 [Lines 133 - 135 ] {
    assertEquals("[12 CHF]", f12CHF.toString());
}
 [Lines 137 - 141 ] {
    // [12 CHF] + [14 CHF] == [26 CHF]
    Money expected = new Money(26, "CHF");
    assertEquals(expected, f12CHF.add(f14CHF));
}
 [Lines 143 - 147 ] {
    // [14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}
    IMoney expected = MoneyBag.create(new Money(26, "CHF"), new Money(7, "USD"));
    assertEquals(expected, f14CHF.add(fMB1));
}
 [Lines 149 - 153 ] {
    // [14 CHF] *2 == [28 CHF]
    Money expected = new Money(28, "CHF");
    assertEquals(expected, f14CHF.multiply(2));
}
 [Lines 155 - 159 ] {
    // [14 CHF] negate == [-14 CHF]
    Money expected = new Money(-14, "CHF");
    assertEquals(expected, f14CHF.negate());
}
 [Lines 161 - 165 ] {
    // [14 CHF] - [12 CHF] == [2 CHF]
    Money expected = new Money(2, "CHF");
    assertEquals(expected, f14CHF.subtract(f12CHF));
}

/src/test/java/junit/samples/money/MoneyBag.java
================================================
 [Lines 20 - 25 ] {
    MoneyBag result = new MoneyBag();
    m1.appendTo(result);
    m2.appendTo(result);
    return result.simplify();
}
 [Lines 27 - 29 ] {
    return m.addMoneyBag(this);
}
 [Lines 31 - 33 ] {
    return MoneyBag.create(m, this);
}
 [Lines 35 - 37 ] {
    return MoneyBag.create(s, this);
}
 [Lines 39 - 43 ] {
    for (Money each : aBag.fMonies) {
        appendMoney(each);
    }
}
 [Lines 45 - 58 ] {
    if (aMoney.isZero())
        return;
    IMoney old = findMoney(aMoney.currency());
    if (old == null) {
        fMonies.add(aMoney);
        return;
    }
    fMonies.remove(old);
    Money sum = (Money) old.add(aMoney);
    if (sum.isZero()) {
        return;
    }
    fMonies.add(sum);
}
 [Lines 61 - 82 ] {
    if (isZero()) {
        if (anObject instanceof IMoney) {
            return ((IMoney) anObject).isZero();
        }
    }
    if (anObject instanceof MoneyBag) {
        MoneyBag aMoneyBag = (MoneyBag) anObject;
        if (aMoneyBag.fMonies.size() != fMonies.size()) {
            return false;
        }
        for (Money each : fMonies) {
            if (!aMoneyBag.contains(each)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
 [Lines 84 - 91 ] {
    for (Money each : fMonies) {
        if (each.currency().equals(currency)) {
            return each;
        }
    }
    return null;
}
 [Lines 93 - 97 ] {
    Money found = findMoney(m.currency());
    if (found == null)
        return false;
    return found.amount() == m.amount();
}
 [Lines 100 - 106 ] {
    int hash = 0;
    for (Money each : fMonies) {
        hash ^= each.hashCode();
    }
    return hash;
}
 [Lines 108 - 110 ] {
    return fMonies.size() == 0;
}
 [Lines 112 - 120 ] {
    MoneyBag result = new MoneyBag();
    if (factor != 0) {
        for (Money each : fMonies) {
            result.appendMoney((Money) each.multiply(factor));
        }
    }
    return result;
}
 [Lines 122 - 128 ] {
    MoneyBag result = new MoneyBag();
    for (Money each : fMonies) {
        result.appendMoney((Money) each.negate());
    }
    return result;
}
 [Lines 130 - 135 ] {
    if (fMonies.size() == 1) {
        return fMonies.iterator().next();
    }
    return this;
}
 [Lines 137 - 139 ] {
    return add(m.negate());
}
 [Lines 142 - 150 ] {
    StringBuilder sb = new StringBuilder();
    sb.append("{");
    for (Money each : fMonies) {
        sb.append(each);
    }
    sb.append("}");
    return sb.toString();
}
 [Lines 152 - 154 ] {
    m.appendBag(this);
}

/src/test/java/junit/samples/money/Money.java
=============================================
 [Lines 14 - 17 ] {
    fAmount = amount;
    fCurrency = currency;
}
 [Lines 22 - 24 ] {
    return m.addMoney(this);
}
 [Lines 26 - 31 ] {
    if (m.currency().equals(currency())) {
        return new Money(amount() + m.amount(), currency());
    }
    return MoneyBag.create(this, m);
}
 [Lines 33 - 35 ] {
    return s.addMoney(this);
}
 [Lines 37 - 39 ] {
    return fAmount;
}
 [Lines 41 - 43 ] {
    return fCurrency;
}
 [Lines 46 - 58 ] {
    if (isZero()) {
        if (anObject instanceof IMoney) {
            return ((IMoney) anObject).isZero();
        }
    }
    if (anObject instanceof Money) {
        Money aMoney = (Money) anObject;
        return aMoney.currency().equals(currency()) && amount() == aMoney.amount();
    }
    return false;
}
 [Lines 61 - 66 ] {
    if (fAmount == 0) {
        return 0;
    }
    return fCurrency.hashCode() + fAmount;
}
 [Lines 68 - 70 ] {
    return amount() == 0;
}
 [Lines 72 - 74 ] {
    return new Money(amount() * factor, currency());
}
 [Lines 76 - 78 ] {
    return new Money(-amount(), currency());
}
 [Lines 80 - 82 ] {
    return add(m.negate());
}
 [Lines 85 - 87 ] {
    return "[" + amount() + " " + currency() + "]";
}
 [Lines 89 - 91 ] {
    m.appendMoney(this);
}

/src/test/java/junit/samples/money/IMoney.java
==============================================

/src/test/java/junit/samples/money/package-info.java
====================================================

/src/test/java/junit/samples/package-info.java
==============================================

/src/test/java/org/junit/experimental/categories/CategoryFilterFactoryTest.java
===============================================================================
 [Lines 28 - 35 ] {
    FilterFactoryParams params = new FilterFactoryParams(createSuiteDescription(testName.getMethodName()), CategoryFilterFactoryStub.class.getName());
    Filter filter = categoryFilterFactory.createFilter(params);
    assertThat(filter, instanceOf(DummyFilter.class));
}
 [Lines 38 - 46 ] {
    FilterFactoryParams params = new FilterFactoryParams(createSuiteDescription(testName.getMethodName()), "NonExistentFilter");
    expectedException.expect(FilterFactory.FilterNotCreatedException.class);
    categoryFilterFactory.createFilter(params);
}
 [Lines 50 - 52 ] {
    return new DummyFilter();
}
 [Lines 57 - 59 ] {
    return false;
}
 [Lines 62 - 64 ] {
    return null;
}

/src/test/java/org/junit/validator/AnnotationsValidatorTest.java
================================================================
 [Lines 27 - 29 ] {
    return asList(new Exception(ANNOTATED_CLASS_CALLED));
}
 [Lines 32 - 34 ] {
    return asList(new Exception(ANNOTATED_FIELD_CALLED));
}
 [Lines 37 - 39 ] {
    return asList(new Exception(ANNOTATED_METHOD_CALLED));
}
 [Lines 51 - 52 ] {
}
 [Lines 60 - 61 ] {
}
 [Lines 67 - 68 ] {
}
 [Lines 72 - 75 ] {
    assertClassHasFailureMessage(AnnotationValidatorClassTest.class, ExampleAnnotationValidator.ANNOTATED_CLASS_CALLED);
}
 [Lines 78 - 81 ] {
    assertClassHasFailureMessage(AnnotationValidatorMethodTest.class, ExampleAnnotationValidator.ANNOTATED_METHOD_CALLED);
}
 [Lines 84 - 87 ] {
    assertClassHasFailureMessage(AnnotationValidatorFieldTest.class, ExampleAnnotationValidator.ANNOTATED_FIELD_CALLED);
}
 [Lines 90 - 97 ] {
    AnnotationsValidator validator = new AnnotationsValidator();
    Collection<Exception> errors = validator.validateTestClass(new TestClass(klass));
    assertThat(errors.size(), is(1));
    assertThat(errors.iterator().next().getMessage(), is(expectedFailure));
}

/src/test/java/org/junit/validator/PublicClassValidatorTest.java
================================================================
 [Lines 21 - 27 ] {
    TestClass testClass = new TestClass(PublicClass.class);
    List<Exception> validationErrors = validator.validateTestClass(testClass);
    assertThat(validationErrors, is(equalTo(Collections.<Exception>emptyList())));
}
 [Lines 34 - 40 ] {
    TestClass testClass = new TestClass(NonPublicClass.class);
    List<Exception> validationErrors = validator.validateTestClass(testClass);
    assertThat("Wrong number of errors.", validationErrors.size(), is(equalTo(1)));
}

/src/test/java/org/junit/validator/AnnotationValidatorFactoryTest.java
======================================================================
 [Lines 16 - 20 ] {
    ValidateWith validateWith = SampleTestWithValidator.class.getAnnotation(ValidateWith.class);
    AnnotationValidator annotationValidator = new AnnotationValidatorFactory().createAnnotationValidator(validateWith);
    assertThat(annotationValidator, is(instanceOf(Validator.class)));
}
 [Lines 30 - 36 ] {
    ValidateWith validateWith = SampleTestWithValidatorThatThrowsException.class.getAnnotation(ValidateWith.class);
    exception.expect(RuntimeException.class);
    exception.expectMessage("Exception received when creating AnnotationValidator class " + "org.junit.validator.AnnotationValidatorFactoryTest$ValidatorThatThrowsException");
    new AnnotationValidatorFactory().createAnnotationValidator(validateWith);
}
 [Lines 43 - 45 ] {
    throw new InstantiationException("Simulating exception in test");
}

/src/test/java/org/junit/runner/JUnitCommandLineParseResultTest.java
====================================================================
 [Lines 23 - 28 ] {
    String[] restOfArgs = jUnitCommandLineParseResult.parseOptions("--0", "--1", "--", "--2", "--3");
    assertThat(restOfArgs, is(new String[] { "--2", "--3" }));
}
 [Lines 31 - 38 ] {
    String value = IncludeCategories.class.getName() + "=" + DummyCategory0.class.getName();
    jUnitCommandLineParseResult.parseOptions("--filter=" + value);
    List<String> specs = jUnitCommandLineParseResult.getFilterSpecs();
    assertThat(specs, hasItems(value));
}
 [Lines 41 - 48 ] {
    jUnitCommandLineParseResult.parseOptions("--filter");
    Runner runner = jUnitCommandLineParseResult.createRequest(new Computer()).getRunner();
    Description description = runner.getDescription().getChildren().get(0);
    assertThat(description.toString(), containsString("initializationError"));
}
 [Lines 51 - 58 ] {
    String value = IncludeCategories.class.getName() + "=" + DummyCategory0.class.getName();
    jUnitCommandLineParseResult.parseOptions("--filter", value);
    List<String> specs = jUnitCommandLineParseResult.getFilterSpecs();
    assertThat(specs, hasItems(value));
}
 [Lines 61 - 67 ] {
    String[] restOfArgs = jUnitCommandLineParseResult.parseOptions(new String[] { "--0", "--1", "2", "3" });
    assertThat(restOfArgs, is(new String[] { "2", "3" }));
}
 [Lines 70 - 80 ] {
    String unknownOption = "--unknown-option";
    jUnitCommandLineParseResult.parseOptions(new String[] { unknownOption });
    Runner runner = jUnitCommandLineParseResult.createRequest(new Computer()).getRunner();
    Description description = runner.getDescription().getChildren().get(0);
    assertThat(description.toString(), containsString("initializationError"));
}
 [Lines 83 - 92 ] {
    jUnitCommandLineParseResult.parseOptions(new String[] { "--filter=" + FilterFactoryStub.class.getName() });
    Runner runner = jUnitCommandLineParseResult.createRequest(new Computer()).getRunner();
    Description description = runner.getDescription().getChildren().get(0);
    assertThat(description.toString(), containsString("initializationError"));
}
 [Lines 95 - 105 ] {
    String nonExistentFilterFactory = "NonExistentFilterFactory";
    jUnitCommandLineParseResult.parseOptions(new String[] { "--filter=" + nonExistentFilterFactory });
    Runner runner = jUnitCommandLineParseResult.createRequest(new Computer()).getRunner();
    Description description = runner.getDescription().getChildren().get(0);
    assertThat(description.toString(), containsString("initializationError"));
}
 [Lines 108 - 117 ] {
    jUnitCommandLineParseResult.parseParameters(new String[] { DummyTest.class.getName() });
    List<Class<?>> classes = jUnitCommandLineParseResult.getClasses();
    Class<?> testClass = classes.get(0);
    assertThat(testClass.getName(), is(DummyTest.class.getName()));
}
 [Lines 120 - 130 ] {
    String unknownTestClass = "UnknownTestClass";
    jUnitCommandLineParseResult.parseParameters(new String[] { unknownTestClass });
    Runner runner = jUnitCommandLineParseResult.createRequest(new Computer()).getRunner();
    Description description = runner.getDescription().getChildren().get(0);
    assertThat(description.toString(), containsString("initializationError"));
}
 [Lines 133 - 135 ] {
    throw new FilterNotCreatedException(new Exception("stub"));
}
 [Lines 143 - 144 ] {
}

/src/test/java/org/junit/runner/notification/ConcurrentRunNotifierTest.java
===========================================================================
 [Lines 35 - 37 ] {
    fTestStarted.incrementAndGet();
}
 [Lines 41 - 64 ] {
    ConcurrentRunListener listener1 = new ConcurrentRunListener();
    ConcurrentRunListener listener2 = new ConcurrentRunListener();
    fNotifier.addListener(listener1);
    fNotifier.addListener(listener2);
    final int numParallelTests = 4;
    ExecutorService pool = Executors.newFixedThreadPool(numParallelTests);
    for (int i = 0; i < numParallelTests; ++i) {
        pool.submit(new Runnable() {

            public void run() {
                fNotifier.fireTestStarted(null);
            }
        });
    }
    pool.shutdown();
    assertTrue(pool.awaitTermination(TIMEOUT, TimeUnit.SECONDS));
    fNotifier.removeListener(listener1);
    fNotifier.removeListener(listener2);
    assertThat(listener1.fTestStarted.get(), is(numParallelTests));
    assertThat(listener2.fTestStarted.get(), is(numParallelTests));
}
 [Lines 70 - 72 ] {
    this.throwFromTestStarted = throwFromTestStarted;
}
 [Lines 75 - 79 ] {
    if (throwFromTestStarted) {
        throw new Exception();
    }
}
 [Lines 82 - 84 ] {
    hasTestFailure = true;
}
 [Lines 91 - 140 ] {
    int totalListenersFailures = 0;
    Random random = new Random(42);
    ExaminedListener[] examinedListeners = new ExaminedListener[1000];
    for (int i = 0; i < examinedListeners.length; ++i) {
        boolean fail = random.nextDouble() >= 0.5d;
        if (fail) {
            ++totalListenersFailures;
        }
        examinedListeners[i] = new ExaminedListener(fail);
    }
    final AtomicBoolean condition = new AtomicBoolean(true);
    final CyclicBarrier trigger = new CyclicBarrier(2);
    final CountDownLatch latch = new CountDownLatch(10);
    ExecutorService notificationsPool = Executors.newFixedThreadPool(4);
    notificationsPool.submit(new Callable<Void>() {

        public Void call() throws Exception {
            trigger.await();
            while (condition.get()) {
                fNotifier.fireTestStarted(null);
                latch.countDown();
            }
            fNotifier.fireTestStarted(null);
            return null;
        }
    });
    // Wait for callable to start
    trigger.await(TIMEOUT, TimeUnit.SECONDS);
    // Wait for callable to fire a few events
    latch.await(TIMEOUT, TimeUnit.SECONDS);
    for (ExaminedListener examinedListener : examinedListeners) {
        addListener(examinedListener);
    }
    notificationsPool.shutdown();
    condition.set(false);
    assertTrue(notificationsPool.awaitTermination(TIMEOUT, TimeUnit.SECONDS));
    if (totalListenersFailures != 0) {
        // If no listener failures, then all the listeners do not report any failure.
        int countTestFailures = examinedListeners.length - countReportedTestFailures(examinedListeners);
        assertThat(totalListenersFailures, is(countTestFailures));
    }
}
 [Lines 148 - 155 ] {
    new AbstractConcurrentFailuresTest() {

        @Override
        protected void addListener(ExaminedListener listener) {
            fNotifier.addListener(listener);
        }
    }.test();
}
 [Lines 162 - 169 ] {
    new AbstractConcurrentFailuresTest() {

        @Override
        protected void addListener(ExaminedListener listener) {
            fNotifier.addFirstListener(listener);
        }
    }.test();
}
 [Lines 171 - 179 ] {
    int count = 0;
    for (ExaminedListener listener : listeners) {
        if (listener.hasTestFailure) {
            ++count;
        }
    }
    return count;
}

/src/test/java/org/junit/runner/notification/RunNotifierTest.java
=================================================================
 [Lines 19 - 26 ] {
    FailureListener failureListener = new FailureListener();
    fNotifier.addListener(new CorruptListener());
    fNotifier.addListener(failureListener);
    fNotifier.fireTestFailure(new Failure(null, null));
    assertNotNull("The FailureListener registered no failure.", failureListener.failure);
}
 [Lines 29 - 34 ] {
    // see issues 209 and 395
    fNotifier.addListener(new CorruptListener());
    fNotifier.addListener(new FailureListener());
    fNotifier.addListener(new CorruptListener());
    fNotifier.fireTestRunFinished(new Result());
}
 [Lines 38 - 40 ] {
    throw new RuntimeException();
}
 [Lines 43 - 45 ] {
    throw new RuntimeException();
}
 [Lines 49 - 58 ] {
    CountingListener listener = new CountingListener();
    assertThat(listener.fTestStarted.get(), is(0));
    fNotifier.addListener(listener);
    fNotifier.fireTestStarted(null);
    assertThat(listener.fTestStarted.get(), is(1));
    fNotifier.removeListener(listener);
    fNotifier.fireTestStarted(null);
    assertThat(listener.fTestStarted.get(), is(1));
}
 [Lines 61 - 70 ] {
    CountingListener listener = new CountingListener();
    assertThat(listener.fTestStarted.get(), is(0));
    fNotifier.addFirstListener(listener);
    fNotifier.fireTestStarted(null);
    assertThat(listener.fTestStarted.get(), is(1));
    fNotifier.removeListener(listener);
    fNotifier.fireTestStarted(null);
    assertThat(listener.fTestStarted.get(), is(1));
}
 [Lines 73 - 82 ] {
    ThreadSafeListener listener = new ThreadSafeListener();
    assertThat(listener.fTestStarted.get(), is(0));
    fNotifier.addListener(listener);
    fNotifier.fireTestStarted(null);
    assertThat(listener.fTestStarted.get(), is(1));
    fNotifier.removeListener(listener);
    fNotifier.fireTestStarted(null);
    assertThat(listener.fTestStarted.get(), is(1));
}
 [Lines 85 - 94 ] {
    ThreadSafeListener listener = new ThreadSafeListener();
    assertThat(listener.fTestStarted.get(), is(0));
    fNotifier.addFirstListener(listener);
    fNotifier.fireTestStarted(null);
    assertThat(listener.fTestStarted.get(), is(1));
    fNotifier.removeListener(listener);
    fNotifier.fireTestStarted(null);
    assertThat(listener.fTestStarted.get(), is(1));
}
 [Lines 97 - 100 ] {
    ThreadSafeListener listener = new ThreadSafeListener();
    ;
    assertSame(listener, new RunNotifier().wrapIfNotThreadSafe(listener));
}
 [Lines 103 - 107 ] {
    CountingListener listener = new CountingListener();
    RunListener wrappedListener = new RunNotifier().wrapIfNotThreadSafe(listener);
    assertThat(wrappedListener, instanceOf(SynchronizedRunListener.class));
}
 [Lines 113 - 115 ] {
    this.failure = failure;
}
 [Lines 122 - 124 ] {
    fTestStarted.incrementAndGet();
}

/src/test/java/org/junit/runner/notification/SynchronizedRunListenerTest.java
=============================================================================
 [Lines 28 - 32 ] {
    fMethod = method;
    fName = method.getName();
    fParameterTypes = Arrays.asList(method.getParameterTypes());
}
 [Lines 35 - 37 ] {
    return fMethod.toString();
}
 [Lines 40 - 42 ] {
    return fName.hashCode();
}
 [Lines 45 - 54 ] {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof MethodSignature)) {
        return false;
    }
    MethodSignature that = (MethodSignature) obj;
    return fName.equals(that.fName) && fParameterTypes.equals(that.fParameterTypes);
}
 [Lines 57 - 63 ] {
    Set<MethodSignature> methods = new HashSet<MethodSignature>();
    for (Method method : type.getDeclaredMethods()) {
        methods.add(new MethodSignature(method));
    }
    return methods;
}
 [Lines 66 - 72 ] {
    Set<MethodSignature> runListenerMethods = getAllDeclaredMethods(RunListener.class);
    Set<MethodSignature> synchronizedRunListenerMethods = getAllDeclaredMethods(SynchronizedRunListener.class);
    assertTrue(synchronizedRunListenerMethods.containsAll(runListenerMethods));
}
 [Lines 77 - 79 ] {
    fName = name;
}
 [Lines 82 - 84 ] {
    return "NamedListener";
}
 [Lines 87 - 89 ] {
    return fName.hashCode();
}
 [Lines 92 - 101 ] {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof NamedListener)) {
        return false;
    }
    NamedListener that = (NamedListener) obj;
    return this.fName.equals(that.fName);
}
 [Lines 105 - 124 ] {
    NamedListener listener1 = new NamedListener("blue");
    NamedListener listener2 = new NamedListener("blue");
    NamedListener listener3 = new NamedListener("red");
    assertTrue(listener1.equals(listener1));
    assertTrue(listener2.equals(listener2));
    assertTrue(listener3.equals(listener3));
    assertFalse(listener1.equals(null));
    assertFalse(listener1.equals(new Object()));
    assertTrue(listener1.equals(listener2));
    assertTrue(listener2.equals(listener1));
    assertFalse(listener1.equals(listener3));
    assertFalse(listener3.equals(listener1));
    assertEquals(listener1.hashCode(), listener2.hashCode());
    assertNotEquals(listener1.hashCode(), listener3.hashCode());
}
 [Lines 127 - 132 ] {
    NamedListener listener = new NamedListener("blue");
    assertEquals("NamedListener", listener.toString());
    assertEquals("NamedListener (with synchronization wrapper)", wrap(listener).toString());
}
 [Lines 135 - 145 ] {
    NamedListener listener1 = new NamedListener("blue");
    NamedListener listener2 = new NamedListener("blue");
    NamedListener listener3 = new NamedListener("red");
    assertEquals(wrap(listener1), wrap(listener1));
    assertEquals(wrap(listener1), wrap(listener2));
    assertNotEquals(wrap(listener1), wrap(listener3));
    assertNotEquals(wrap(listener1), listener1);
    assertNotEquals(listener1, wrap(listener1));
}
 [Lines 148 - 151 ] {
    NamedListener listener = new NamedListener("blue");
    assertEquals(listener.hashCode(), wrap(listener).hashCode());
}
 [Lines 153 - 155 ] {
    return new SynchronizedRunListener(listener, this);
}

/src/test/java/org/junit/runner/RunnerSpy.java
==============================================
 [Lines 12 - 14 ] {
    invokedTestClass = testClass;
}
 [Lines 16 - 19 ] {
    invokedTestClass = testClass;
    invokedRunnerBuilder = runnerBuilder;
}
 [Lines 22 - 24 ] {
    return DESCRIPTION;
}
 [Lines 27 - 28 ] {
}
 [Lines 30 - 32 ] {
    return invokedRunnerBuilder;
}
 [Lines 34 - 36 ] {
    return invokedTestClass;
}

/src/test/java/org/junit/runner/FilterOptionIntegrationTest.java
================================================================
 [Lines 29 - 31 ] {
    jUnitCore.addListener(testListener);
}
 [Lines 34 - 49 ] {
    Result result = runJUnit(DummyTestClass.class.getName(), DummyTestClass0.class.getName(), DummyTestClass1.class.getName(), DummyTestClass01.class.getName(), DummyTestClass0TestMethod1.class.getName());
    assertWasRun(DummyTestClass.class);
    assertWasRun(DummyTestClass0.class);
    assertWasRun(DummyTestClass1.class);
    assertWasRun(DummyTestClass01.class);
    assertWasRun(DummyTestClass0TestMethod1.class);
    assertThat("runCount does not match", result.getRunCount(), is(5));
    assertThat("failureCount does not match", result.getFailureCount(), is(0));
}
 [Lines 52 - 68 ] {
    Result result = runJUnit(EXCLUDES_DUMMY_CATEGORY_1, DummyTestClass.class.getName(), DummyTestClass0.class.getName(), DummyTestClass1.class.getName(), DummyTestClass01.class.getName(), DummyTestClass0TestMethod1.class.getName());
    assertWasRun(DummyTestClass.class);
    assertWasRun(DummyTestClass0.class);
    assertWasNotRun(DummyTestClass1.class);
    assertWasNotRun(DummyTestClass01.class);
    assertWasNotRun(DummyTestClass0TestMethod1.class);
    assertThat("runCount does not match", result.getRunCount(), is(2));
    assertThat("failureCount does not match", result.getFailureCount(), is(0));
}
 [Lines 71 - 87 ] {
    Result result = runJUnit(INCLUDES_DUMMY_CATEGORY_0, DummyTestClass.class.getName(), DummyTestClass0.class.getName(), DummyTestClass1.class.getName(), DummyTestClass01.class.getName(), DummyTestClass0TestMethod1.class.getName());
    assertWasNotRun(DummyTestClass.class);
    assertWasRun(DummyTestClass0.class);
    assertWasNotRun(DummyTestClass1.class);
    assertWasRun(DummyTestClass01.class);
    assertWasRun(DummyTestClass0TestMethod1.class);
    assertThat("runCount does not match", result.getRunCount(), is(3));
    assertThat("failureCount does not match", result.getFailureCount(), is(0));
}
 [Lines 90 - 107 ] {
    Result result = runJUnit(INCLUDES_DUMMY_CATEGORY_0, EXCLUDES_DUMMY_CATEGORY_1, DummyTestClass.class.getName(), DummyTestClass0.class.getName(), DummyTestClass1.class.getName(), DummyTestClass01.class.getName(), DummyTestClass0TestMethod1.class.getName());
    assertWasNotRun(DummyTestClass.class);
    assertWasRun(DummyTestClass0.class);
    assertWasNotRun(DummyTestClass1.class);
    assertWasNotRun(DummyTestClass01.class);
    assertWasNotRun(DummyTestClass0TestMethod1.class);
    assertThat("runCount does not match", result.getRunCount(), is(1));
    assertThat("failureCount does not match", result.getFailureCount(), is(0));
}
 [Lines 109 - 111 ] {
    return jUnitCore.runMain(new TestSystem(), args);
}
 [Lines 113 - 115 ] {
    assertTrue(testClass.getName() + " expected to finish but did not", testListener.wasRun(testClass));
}
 [Lines 117 - 121 ] {
    assertFalse(testClass.getName() + " expected not to have been started but was", testListener.wasRun(testClass));
}
 [Lines 128 - 130 ] {
    finishedTests.add(description.getClassName());
}
 [Lines 132 - 134 ] {
    return finishedTests.contains(testClass.getName());
}
 [Lines 137 - 139 ] {
    startedTests.add(description.getClassName());
}
 [Lines 141 - 143 ] {
    return startedTests.contains(testClass.getName());
}
 [Lines 145 - 147 ] {
    return testStarted(testClass) && testFinished(testClass);
}
 [Lines 152 - 153 ] {
}
 [Lines 159 - 160 ] {
}
 [Lines 166 - 167 ] {
}
 [Lines 173 - 174 ] {
}
 [Lines 181 - 182 ] {
}

/src/test/java/org/junit/runner/FilterFactoriesTest.java
========================================================
 [Lines 24 - 26 ] {
    return Request.aClass(DummySuite.class);
}
 [Lines 29 - 35 ] {
    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteRequest(), ExcludeCategories.class.getName() + "=" + DummyCategory.class.getName());
    assertThat(filter.describe(), startsWith("excludes "));
}
 [Lines 38 - 43 ] {
    Filter filter = FilterFactories.createFilterFromFilterSpec(createSuiteRequest(), FilterFactoryStub.class.getName());
    assertThat(filter, instanceOf(DummyFilter.class));
}
 [Lines 46 - 57 ] {
    Request request = createSuiteRequest();
    Description description = request.getRunner().getDescription();
    Filter filter = FilterFactories.createFilterFromFilterSpec(request, FilterFactoryStub.class.getName());
    // This assumption tested in shouldCreateFilterWithNoArguments()
    assumeThat(filter, instanceOf(DummyFilter.class));
    DummyFilter dummyFilter = (DummyFilter) filter;
    assertThat(dummyFilter.getTopLevelDescription(), is(description));
}
 [Lines 60 - 68 ] {
    Filter filter = FilterFactories.createFilter(FilterFactoryStub.class, new FilterFactoryParams(Description.createSuiteDescription(testName.getMethodName()), ""));
    assertThat(filter, instanceOf(DummyFilter.class));
}
 [Lines 71 - 75 ] {
    expectedException.expect(FilterFactory.FilterNotCreatedException.class);
    FilterFactories.createFilterFactory(NonFilterFactory.class.getName());
}
 [Lines 78 - 82 ] {
    expectedException.expect(FilterFactory.FilterNotCreatedException.class);
    FilterFactories.createFilterFactory(NonInstantiableFilterFactory.class);
}
 [Lines 88 - 89 ] {
}
 [Lines 91 - 93 ] {
    throw new FilterNotCreatedException(new Exception("not implemented"));
}
 [Lines 97 - 99 ] {
    return new DummyFilter(params.getTopLevelDescription());
}
 [Lines 105 - 107 ] {
    fTopLevelDescription = topLevelDescription;
}
 [Lines 109 - 111 ] {
    return fTopLevelDescription;
}
 [Lines 114 - 116 ] {
    return false;
}
 [Lines 119 - 121 ] {
    return null;
}
 [Lines 134 - 135 ] {
}

/src/test/java/org/junit/runner/JUnitCoreTest.java
==================================================
 [Lines 12 - 19 ] {
    JUnitCore jUnitCore = new JUnitCore();
    Result result = jUnitCore.runMain(new TestSystem(), "NonExistentTest");
    assertThat(result.getFailureCount(), is(1));
    assertThat(result.getFailures().get(0).getException(), instanceOf(IllegalArgumentException.class));
}

/src/test/java/org/junit/tests/AllTests.java
============================================
 [Lines 243 - 245 ] {
    return new JUnit4TestAdapter(AllTests.class);
}

/src/test/java/org/junit/tests/running/methods/TimeoutTest.java
===============================================================
 [Lines 31 - 33 ] {
    fail();
}
 [Lines 37 - 43 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(FailureWithTimeoutTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(1, result.getFailureCount());
    assertEquals(AssertionError.class, result.getFailures().get(0).getException().getClass());
}
 [Lines 47 - 49 ] {
    throw new NullPointerException();
}
 [Lines 53 - 59 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(FailureWithTimeoutRunTimeExceptionTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(1, result.getFailureCount());
    assertEquals(NullPointerException.class, result.getFailures().get(0).getException().getClass());
}
 [Lines 63 - 64 ] {
}
 [Lines 68 - 73 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(SuccessWithTimeoutTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(0, result.getFailureCount());
}
 [Lines 77 - 79 ] {
    Thread.sleep(40000);
}
 [Lines 84 - 90 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(TimeoutFailureTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(1, result.getFailureCount());
    assertEquals(InterruptedException.class, result.getFailures().get(0).getException().getClass());
}
 [Lines 94 - 96 ] {
    infiniteLoop();
}
 [Lines 98 - 105 ] {
    for (; ; ) {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
        }
    }
}
 [Lines 109 - 116 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(InfiniteLoopTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(1, result.getFailureCount());
    Throwable exception = result.getFailures().get(0).getException();
    assertTrue(exception.getMessage().contains("test timed out after 100 milliseconds"));
}
 [Lines 120 - 122 ] {
    infiniteLoop();
}
 [Lines 124 - 126 ] {
    for (; ; ) ;
}
 [Lines 131 - 139 ] {
    // "prime the pump": running these beforehand makes the runtimes more predictable
    //                   (because of class loading?)
    JUnitCore.runClasses(InfiniteLoopTest.class, ImpatientLoopTest.class);
    long longTime = runAndTime(InfiniteLoopTest.class);
    long shortTime = runAndTime(ImpatientLoopTest.class);
    long difference = longTime - shortTime;
    assertTrue(String.format("Difference was %sms", difference), difference < 200);
}
 [Lines 141 - 147 ] {
    JUnitCore core = new JUnitCore();
    long startTime = System.currentTimeMillis();
    core.run(clazz);
    long totalTime = System.currentTimeMillis() - startTime;
    return totalTime;
}
 [Lines 149 - 154 ] {
    Writer buffer = new StringWriter();
    PrintWriter writer = new PrintWriter(buffer);
    exception.printStackTrace(writer);
    return buffer.toString();
}
 [Lines 157 - 164 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(InfiniteLoopTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(1, result.getFailureCount());
    Throwable exception = result.getFailures().get(0).getException();
    // Make sure we have the stalled frame on the stack somewhere
    assertThat(stackForException(exception), containsString("infiniteLoop"));
}
 [Lines 171 - 173 ] {
    fStall = stall;
}
 [Lines 175 - 182 ] {
    if (fStall)
        for (; ; ) ;
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
    }
}
 [Lines 185 - 197 ] {
    Thread t1 = new Thread(new ThreadTest(false), "timeout-thr1");
    Thread t2 = new Thread(new ThreadTest(!mainThreadStalls), "timeout-thr2");
    Thread t3 = new Thread(new ThreadTest(false), "timeout-thr3");
    t1.start();
    t2.start();
    t3.start();
    if (mainThreadStalls)
        for (; ; ) ;
    t1.join();
    t2.join();
    t3.join();
}
 [Lines 208 - 210 ] {
    (new InfiniteLoopMultithreaded()).failure(false);
}
 [Lines 221 - 223 ] {
    (new InfiniteLoopMultithreaded()).failure(true);
}
 [Lines 227 - 238 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(InfiniteLoopWithStuckThreadTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(2, result.getFailureCount());
    Throwable[] exception = new Throwable[2];
    for (int i = 0; i < 2; i++) exception[i] = result.getFailures().get(i).getException();
    assertThat(exception[0].getMessage(), containsString("test timed out after 100 milliseconds"));
    assertThat(stackForException(exception[0]), containsString("Thread.join"));
    assertThat(exception[1].getMessage(), containsString("Appears to be stuck in thread timeout-thr2"));
}
 [Lines 241 - 249 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(InfiniteLoopStuckInMainThreadTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(1, result.getFailureCount());
    Throwable exception = result.getFailures().get(0).getException();
    assertThat(exception.getMessage(), containsString("test timed out after 100 milliseconds"));
    assertThat(exception.getMessage(), not(containsString("Appears to be stuck")));
}
 [Lines 252 - 256 ] {
    TestResult result = new TestResult();
    new JUnit4TestAdapter(InfiniteLoopTest.class).run(result);
    assertEquals(1, result.errorCount());
}
 [Lines 262 - 270 ] {
    for (; ; ) {
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
        // ok, tests are over
        }
    }
}
 [Lines 273 - 275 ] {
    afterWasCalled = true;
}
 [Lines 279 - 282 ] {
    JUnitCore.runClasses(WillTimeOut.class);
    assertThat(WillTimeOut.afterWasCalled, is(true));
}
 [Lines 289 - 295 ] {
    try {
        // long enough to suspend thread execution
        Thread.sleep(200);
    } catch (InterruptedException e) {
    // Don't care
    }
}
 [Lines 299 - 304 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(TimeOutZero.class);
    assertEquals("Should run the test", 1, result.getRunCount());
    assertEquals("Test should not have failed", 0, result.getFailureCount());
}
 [Lines 308 - 310 ] {
    super(timeout, timeUnit);
}
 [Lines 312 - 314 ] {
    return super.getTimeout(unit);
}
 [Lines 322 - 324 ] {
    assertEquals(1000, timeout.getTimeoutFromSuperclass(TimeUnit.MILLISECONDS));
}
 [Lines 328 - 333 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(TimeOutOneSecond.class);
    assertEquals("Should run the test", 1, result.getRunCount());
    assertEquals("Test should not have failed", 0, result.getFailureCount());
}

/src/test/java/org/junit/tests/running/methods/ParameterizedTestMethodTest.java
===============================================================================
 [Lines 27 - 28 ] {
}
 [Lines 31 - 32 ] {
}
 [Lines 35 - 36 ] {
}
 [Lines 39 - 41 ] {
    return 0;
}
 [Lines 44 - 45 ] {
}
 [Lines 48 - 49 ] {
}
 [Lines 52 - 53 ] {
}
 [Lines 56 - 57 ] {
}
 [Lines 60 - 62 ] {
    return 0;
}
 [Lines 65 - 66 ] {
}
 [Lines 69 - 70 ] {
}
 [Lines 73 - 74 ] {
}
 [Lines 77 - 78 ] {
}
 [Lines 81 - 83 ] {
    return 0;
}
 [Lines 86 - 87 ] {
}
 [Lines 90 - 91 ] {
}
 [Lines 94 - 95 ] {
}
 [Lines 98 - 99 ] {
}
 [Lines 102 - 104 ] {
    return 0;
}
 [Lines 107 - 108 ] {
}
 [Lines 111 - 112 ] {
}
 [Lines 115 - 116 ] {
}
 [Lines 119 - 120 ] {
}
 [Lines 123 - 125 ] {
    return 0;
}
 [Lines 128 - 129 ] {
}
 [Lines 132 - 133 ] {
}
 [Lines 141 - 142 ] {
}
 [Lines 147 - 148 ] {
}
 [Lines 154 - 155 ] {
}
 [Lines 158 - 161 ] {
    fClass = class1;
    fErrorCount = errorCount;
}
 [Lines 164 - 168 ] {
    return Arrays.asList(new Object[][] { { EverythingWrong.class, 1 + 4 * 5 }, { SubWrong.class, 1 }, { SubShadows.class, 0 } });
}
 [Lines 170 - 177 ] {
    try {
        new BlockJUnit4ClassRunner(clazz);
    } catch (InitializationError e) {
        return e.getCauses();
    }
    return Collections.emptyList();
}
 [Lines 180 - 183 ] {
    List<Throwable> problems = validateAllMethods(fClass);
    assertEquals(fErrorCount, problems.size());
}
 [Lines 185 - 187 ] {
    return new JUnit4TestAdapter(ParameterizedTestMethodTest.class);
}

/src/test/java/org/junit/tests/running/methods/AnnotationTest.java
==================================================================
 [Lines 27 - 29 ] {
    run = false;
}
 [Lines 33 - 35 ] {
    run = true;
}
 [Lines 38 - 42 ] {
    JUnitCore runner = new JUnitCore();
    runner.run(SimpleTest.class);
    assertTrue(run);
}
 [Lines 47 - 49 ] {
    run = true;
}
 [Lines 52 - 56 ] {
    JUnitCore runner = new JUnitCore();
    runner.run(SimpleTestWithFutureProofExplicitRunner.class);
    assertTrue(run);
}
 [Lines 60 - 62 ] {
    run = true;
}
 [Lines 65 - 66 ] {
}
 [Lines 69 - 73 ] {
    JUnitCore runner = new JUnitCore();
    runner.run(SetupTest.class);
    assertTrue(run);
}
 [Lines 77 - 79 ] {
    run = true;
}
 [Lines 82 - 83 ] {
}
 [Lines 86 - 90 ] {
    JUnitCore runner = new JUnitCore();
    runner.run(TeardownTest.class);
    assertTrue(run);
}
 [Lines 94 - 96 ] {
    org.junit.Assert.fail();
}
 [Lines 99 - 105 ] {
    JUnitCore runner = new JUnitCore();
    Result result = runner.run(FailureTest.class);
    assertEquals(1, result.getRunCount());
    assertEquals(1, result.getFailureCount());
    assertEquals(AssertionError.class, result.getFailures().get(0).getException().getClass());
}
 [Lines 109 - 111 ] {
    throw new Error();
}
 [Lines 114 - 116 ] {
    run = true;
}
 [Lines 119 - 126 ] {
    JUnitCore core = new JUnitCore();
    Result runner = core.run(SetupFailureTest.class);
    assertEquals(1, runner.getRunCount());
    assertEquals(1, runner.getFailureCount());
    assertEquals(Error.class, runner.getFailures().get(0).getException().getClass());
    assertFalse(run);
}
 [Lines 130 - 132 ] {
    throw new Error();
}
 [Lines 135 - 136 ] {
}
 [Lines 139 - 145 ] {
    JUnitCore core = new JUnitCore();
    Result runner = core.run(TeardownFailureTest.class);
    assertEquals(1, runner.getRunCount());
    assertEquals(1, runner.getFailureCount());
    assertEquals(Error.class, runner.getFailures().get(0).getException().getClass());
}
 [Lines 149 - 151 ] {
    throw new Error("hereAfter");
}
 [Lines 154 - 156 ] {
    throw new Exception("inTest");
}
 [Lines 159 - 165 ] {
    JUnitCore core = new JUnitCore();
    Result runner = core.run(TestAndTeardownFailureTest.class);
    assertEquals(1, runner.getRunCount());
    assertEquals(2, runner.getFailureCount());
    assertThat(runner.getFailures().toString(), allOf(containsString("hereAfter"), containsString("inTest")));
}
 [Lines 169 - 171 ] {
    run = true;
}
 [Lines 174 - 176 ] {
    throw new Exception();
}
 [Lines 179 - 183 ] {
    JUnitCore runner = new JUnitCore();
    runner.run(TeardownAfterFailureTest.class);
    assertTrue(run);
}
 [Lines 190 - 193 ] {
    count++;
    tests.add(this);
}
 [Lines 196 - 199 ] {
    count++;
    tests.add(this);
}
 [Lines 202 - 209 ] {
    count = 0;
    tests = new HashSet<Object>();
    JUnitCore runner = new JUnitCore();
    runner.run(TwoTests.class);
    assertEquals(2, count);
    assertEquals(2, tests.size());
}
 [Lines 212 - 214 ] {
    run = true;
}
 [Lines 217 - 221 ] {
    JUnitCore runner = new JUnitCore();
    runner.run(OldTest.class);
    assertTrue(run);
}
 [Lines 224 - 226 ] {
    run = true;
}
 [Lines 229 - 234 ] {
    TestSuite suite = new TestSuite(OldSuiteTest.class);
    JUnitCore runner = new JUnitCore();
    runner.run(suite);
    assertTrue(run);
}
 [Lines 238 - 240 ] {
    throw new Error();
}
 [Lines 243 - 247 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(ExceptionTest.class);
    assertEquals(0, result.getFailureCount());
}
 [Lines 251 - 252 ] {
}
 [Lines 255 - 260 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(NoExceptionTest.class);
    assertEquals(1, result.getFailureCount());
    assertEquals("Expected exception: java.lang.Error", result.getFailures().get(0).getMessage());
}
 [Lines 264 - 266 ] {
    count++;
}
 [Lines 269 - 270 ] {
}
 [Lines 273 - 274 ] {
}
 [Lines 277 - 282 ] {
    count = 0;
    JUnitCore core = new JUnitCore();
    core.run(OneTimeSetup.class);
    assertEquals(1, count);
}
 [Lines 286 - 288 ] {
    count++;
}
 [Lines 291 - 292 ] {
}
 [Lines 295 - 296 ] {
}
 [Lines 299 - 304 ] {
    count = 0;
    JUnitCore core = new JUnitCore();
    core.run(OneTimeTeardown.class);
    assertEquals(1, count);
}
 [Lines 310 - 312 ] {
    log += "beforeClass ";
}
 [Lines 315 - 317 ] {
    log += "before ";
}
 [Lines 320 - 322 ] {
    log += "test ";
}
 [Lines 325 - 327 ] {
    log += "after ";
}
 [Lines 330 - 332 ] {
    log += "afterClass ";
}
 [Lines 335 - 340 ] {
    log = "";
    JUnitCore core = new JUnitCore();
    core.run(OrderTest.class);
    assertEquals("beforeClass before test after afterClass ", log);
}
 [Lines 344 - 345 ] {
}
 [Lines 348 - 349 ] {
}
 [Lines 352 - 356 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(NonStaticOneTimeSetup.class);
    assertEquals(1, result.getFailureCount());
}
 [Lines 360 - 362 ] {
    throw new Exception();
}
 [Lines 365 - 367 ] {
    run = true;
}
 [Lines 370 - 378 ] {
    run = false;
    JUnitCore core = new JUnitCore();
    Result result = core.run(ErrorInBeforeClass.class);
    assertFalse(run);
    assertEquals(1, result.getFailureCount());
    Description description = result.getFailures().get(0).getDescription();
    assertEquals(ErrorInBeforeClass.class.getName(), description.getDisplayName());
}
 [Lines 382 - 384 ] {
    run = true;
}
 [Lines 387 - 389 ] {
    throw new Exception();
}
 [Lines 392 - 398 ] {
    run = false;
    JUnitCore core = new JUnitCore();
    Result result = core.run(ErrorInAfterClass.class);
    assertTrue(run);
    assertEquals(1, result.getFailureCount());
}
 [Lines 402 - 404 ] {
    log += "Before class super ";
}
 [Lines 407 - 409 ] {
    log += "After class super ";
}
 [Lines 412 - 414 ] {
    log += "Before super ";
}
 [Lines 417 - 419 ] {
    log += "After super ";
}
 [Lines 424 - 426 ] {
    log += "Before class sub ";
}
 [Lines 429 - 431 ] {
    log += "After class sub ";
}
 [Lines 434 - 436 ] {
    log += "Before sub ";
}
 [Lines 439 - 441 ] {
    log += "After sub ";
}
 [Lines 444 - 446 ] {
    log += "Test ";
}
 [Lines 449 - 454 ] {
    log = "";
    JUnitCore core = new JUnitCore();
    core.run(SubInheritance.class);
    assertEquals("Before class super Before class sub Before super Before sub Test After sub After super After class sub After class super ", log);
}
 [Lines 458 - 460 ] {
    log += "Before super ";
}
 [Lines 463 - 465 ] {
    log += "After super ";
}
 [Lines 471 - 473 ] {
    log += "Before sub ";
}
 [Lines 477 - 479 ] {
    log += "After sub ";
}
 [Lines 482 - 484 ] {
    log += "Test ";
}
 [Lines 487 - 492 ] {
    log = "";
    JUnitCore core = new JUnitCore();
    core.run(SubShadowing.class);
    assertEquals("Before sub Test After sub ", log);
}
 [Lines 496 - 498 ] {
    log += "Super";
}
 [Lines 501 - 503 ] {
    log += "Two";
}
 [Lines 509 - 511 ] {
    log += "Sub";
}
 [Lines 514 - 522 ] {
    log = "";
    JUnitCore core = new JUnitCore();
    core.run(SubTest.class);
    // The order in which the test methods are called is unspecified
    assertTrue(log.contains("Sub"));
    assertTrue(log.contains("Two"));
    assertFalse(log.contains("Super"));
}
 [Lines 526 - 527 ] {
}
 [Lines 530 - 532 ] {
    throw new Error();
}
 [Lines 535 - 536 ] {
}
 [Lines 539 - 541 ] {
    log += "one";
}
 [Lines 544 - 546 ] {
    log += "two";
}
 [Lines 549 - 555 ] {
    log = "";
    JUnitCore core = new JUnitCore();
    core.run(RunAllAfters.class);
    assertTrue(log.contains("one"));
    assertTrue(log.contains("two"));
}
 [Lines 559 - 560 ] {
}
 [Lines 563 - 566 ] {
    log += "one";
    throw new Error();
}
 [Lines 569 - 572 ] {
    log += "two";
    throw new Error();
}
 [Lines 575 - 582 ] {
    log = "";
    JUnitCore core = new JUnitCore();
    Result result = core.run(RunAllAftersRegardless.class);
    assertTrue(log.contains("one"));
    assertTrue(log.contains("two"));
    assertEquals(2, result.getFailureCount());
}
 [Lines 586 - 587 ] {
}
 [Lines 590 - 592 ] {
    throw new Error();
}
 [Lines 595 - 596 ] {
}
 [Lines 599 - 601 ] {
    log += "one";
}
 [Lines 604 - 606 ] {
    log += "two";
}
 [Lines 609 - 615 ] {
    log = "";
    JUnitCore core = new JUnitCore();
    core.run(RunAllAfterClasses.class);
    assertTrue(log.contains("one"));
    assertTrue(log.contains("two"));
}
 [Lines 619 - 620 ] {
}
 [Lines 623 - 626 ] {
    log += "one";
    throw new Error();
}
 [Lines 629 - 632 ] {
    log += "two";
    throw new Error();
}
 [Lines 635 - 642 ] {
    log = "";
    JUnitCore core = new JUnitCore();
    Result result = core.run(RunAllAfterClassesRegardless.class);
    assertTrue(log.contains("one"));
    assertTrue(log.contains("two"));
    assertEquals(2, result.getFailureCount());
}

/src/test/java/org/junit/tests/running/methods/TestMethodTest.java
==================================================================
 [Lines 26 - 27 ] {
}
 [Lines 30 - 31 ] {
}
 [Lines 34 - 35 ] {
}
 [Lines 38 - 40 ] {
    return 0;
}
 [Lines 43 - 44 ] {
}
 [Lines 47 - 48 ] {
}
 [Lines 51 - 52 ] {
}
 [Lines 55 - 56 ] {
}
 [Lines 59 - 61 ] {
    return 0;
}
 [Lines 64 - 65 ] {
}
 [Lines 68 - 69 ] {
}
 [Lines 72 - 73 ] {
}
 [Lines 76 - 77 ] {
}
 [Lines 80 - 82 ] {
    return 0;
}
 [Lines 85 - 86 ] {
}
 [Lines 89 - 90 ] {
}
 [Lines 93 - 94 ] {
}
 [Lines 97 - 98 ] {
}
 [Lines 101 - 103 ] {
    return 0;
}
 [Lines 106 - 107 ] {
}
 [Lines 110 - 111 ] {
}
 [Lines 114 - 115 ] {
}
 [Lines 118 - 119 ] {
}
 [Lines 122 - 124 ] {
    return 0;
}
 [Lines 127 - 128 ] {
}
 [Lines 131 - 132 ] {
}
 [Lines 136 - 140 ] {
    List<Throwable> problems = validateAllMethods(EverythingWrong.class);
    // missing constructor plus four invalid methods for each annotation */
    int errorCount = 1 + 4 * 5;
    assertEquals(errorCount, problems.size());
}
 [Lines 144 - 145 ] {
}
 [Lines 150 - 151 ] {
}
 [Lines 155 - 158 ] {
    List<Throwable> problems = validateAllMethods(SubWrong.class);
    assertEquals(1, problems.size());
}
 [Lines 163 - 164 ] {
}
 [Lines 168 - 171 ] {
    List<Throwable> problems = validateAllMethods(SubShadows.class);
    assertTrue(problems.isEmpty());
}
 [Lines 173 - 180 ] {
    try {
        new BlockJUnit4ClassRunner(clazz);
    } catch (InitializationError e) {
        return e.getCauses();
    }
    return Collections.emptyList();
}
 [Lines 184 - 185 ] {
}
 [Lines 189 - 190 ] {
}
 [Lines 194 - 195 ] {
}
 [Lines 199 - 204 ] {
    JUnitCore runner = new JUnitCore();
    Result result = runner.run(IgnoredTest.class);
    assertEquals(2, result.getIgnoreCount());
    assertEquals(1, result.getRunCount());
}
 [Lines 207 - 211 ] {
    TestResult result = new TestResult();
    new JUnit4TestAdapter(IgnoredTest.class).run(result);
    assertEquals(1, result.runCount());
}
 [Lines 215 - 216 ] {
}
 [Lines 219 - 220 ] {
}
 [Lines 224 - 226 ] {
    new BlockJUnit4ClassRunner(Confused.class);
}
 [Lines 229 - 230 ] {
}
 [Lines 233 - 234 ] {
}
 [Lines 238 - 240 ] {
    new BlockJUnit4ClassRunner(ConstructorParameter.class);
}
 [Lines 245 - 246 ] {
}
 [Lines 250 - 254 ] {
    Result result = JUnitCore.runClasses(OnlyTestIsIgnored.class);
    assertEquals(0, result.getFailureCount());
    assertEquals(1, result.getIgnoreCount());
}

/src/test/java/org/junit/tests/running/methods/ExpectedTest.java
================================================================
 [Lines 16 - 18 ] {
    throw new Exception();
}
 [Lines 22 - 26 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(Expected.class);
    assertTrue(result.wasSuccessful());
}
 [Lines 30 - 32 ] {
    throw new Error();
}
 [Lines 36 - 42 ] {
    Result result = JUnitCore.runClasses(Unexpected.class);
    Failure failure = result.getFailures().get(0);
    String message = failure.getMessage();
    assertTrue(message.contains("expected<java.lang.Exception> but was<java.lang.Error>"));
    assertEquals(Error.class, failure.getException().getCause().getClass());
}
 [Lines 46 - 47 ] {
}
 [Lines 51 - 57 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(NoneThrown.class);
    assertFalse(result.wasSuccessful());
    String message = result.getFailures().get(0).getMessage();
    assertTrue(message.contains("Expected exception: java.lang.Exception"));
}
 [Lines 61 - 63 ] {
    throw new ClassCastException();
}
 [Lines 67 - 69 ] {
    assertTrue(new JUnitCore().run(ExpectSuperclass.class).wasSuccessful());
}

/src/test/java/org/junit/tests/running/methods/InheritedTestTest.java
=====================================================================
 [Lines 15 - 16 ] {
}
 [Lines 23 - 26 ] {
    Result result = JUnitCore.runClasses(Sub.class);
    assertTrue(result.wasSuccessful());
}
 [Lines 30 - 32 ] {
    fail();
}
 [Lines 36 - 38 ] {
    assertFalse(JUnitCore.runClasses(SubWithBefore.class).wasSuccessful());
}

/src/test/java/org/junit/tests/running/core/JUnitCoreReturnsCorrectExitCodeTest.java
====================================================================================
 [Lines 13 - 15 ] {
    fail();
}
 [Lines 19 - 21 ] {
    runClass(getClass().getName() + "$Fail", 1);
}
 [Lines 24 - 26 ] {
    runClass("Foo", 1);
}
 [Lines 30 - 31 ] {
}
 [Lines 35 - 37 ] {
    runClass(getClass().getName() + "$Succeed", 0);
}
 [Lines 39 - 46 ] {
    Integer exitValue = new MainRunner().runWithCheckForSystemExit(new Runnable() {

        public void run() {
            JUnitCore.main(className);
        }
    });
    assertEquals(Integer.valueOf(returnCode), exitValue);
}

/src/test/java/org/junit/tests/running/core/MainRunner.java
===========================================================
 [Lines 15 - 18 ] {
    super("");
    this.status = status;
}
 [Lines 20 - 22 ] {
    return status;
}
 [Lines 33 - 35 ] {
    this.originalSecurityManager = originalSecurityManager;
}
 [Lines 38 - 40 ] {
    throw new ExitException(status);
}
 [Lines 44 - 46 ] {
    return (originalSecurityManager != null) && originalSecurityManager.getInCheck();
}
 [Lines 49 - 51 ] {
    return (originalSecurityManager == null) ? super.getSecurityContext() : originalSecurityManager.getSecurityContext();
}
 [Lines 54 - 58 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkPermission(perm);
    }
}
 [Lines 61 - 65 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkPermission(perm, context);
    }
}
 [Lines 68 - 72 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkCreateClassLoader();
    }
}
 [Lines 75 - 79 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkAccess(t);
    }
}
 [Lines 82 - 86 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkAccess(g);
    }
}
 [Lines 89 - 93 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkExec(cmd);
    }
}
 [Lines 96 - 100 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkLink(lib);
    }
}
 [Lines 103 - 107 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkRead(fd);
    }
}
 [Lines 110 - 114 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkRead(file);
    }
}
 [Lines 117 - 121 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkRead(file, context);
    }
}
 [Lines 124 - 128 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkWrite(fd);
    }
}
 [Lines 131 - 135 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkWrite(file);
    }
}
 [Lines 138 - 142 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkDelete(file);
    }
}
 [Lines 145 - 149 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkConnect(host, port);
    }
}
 [Lines 152 - 156 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkConnect(host, port, context);
    }
}
 [Lines 159 - 163 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkListen(port);
    }
}
 [Lines 166 - 170 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkAccept(host, port);
    }
}
 [Lines 173 - 177 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkMulticast(maddr);
    }
}
 [Lines 181 - 185 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkMulticast(maddr, ttl);
    }
}
 [Lines 188 - 192 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkPropertiesAccess();
    }
}
 [Lines 195 - 199 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkPropertyAccess(key);
    }
}
 [Lines 202 - 204 ] {
    return (originalSecurityManager == null) ? super.checkTopLevelWindow(window) : originalSecurityManager.checkTopLevelWindow(window);
}
 [Lines 207 - 211 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkPrintJobAccess();
    }
}
 [Lines 214 - 218 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkSystemClipboardAccess();
    }
}
 [Lines 221 - 225 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkAwtEventQueueAccess();
    }
}
 [Lines 228 - 232 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkPackageAccess(pkg);
    }
}
 [Lines 235 - 239 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkPackageDefinition(pkg);
    }
}
 [Lines 242 - 246 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkSetFactory();
    }
}
 [Lines 249 - 253 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkMemberAccess(clazz, which);
    }
}
 [Lines 256 - 260 ] {
    if (originalSecurityManager != null) {
        originalSecurityManager.checkSecurityAccess(target);
    }
}
 [Lines 263 - 265 ] {
    return (originalSecurityManager == null) ? super.getThreadGroup() : originalSecurityManager.getThreadGroup();
}
 [Lines 275 - 292 ] {
    SecurityManager oldSecurityManager = System.getSecurityManager();
    System.setSecurityManager(new NoExitSecurityManager(oldSecurityManager));
    PrintStream oldOut = System.out;
    System.setOut(new PrintStream(new ByteArrayOutputStream()));
    try {
        runnable.run();
        System.out.println("System.exit() not called, return null");
        return null;
    } catch (ExitException e) {
        System.out.println("System.exit() called, value=" + e.getStatus());
        return e.getStatus();
    } finally {
        System.setSecurityManager(oldSecurityManager);
        System.setOut(oldOut);
    }
}

/src/test/java/org/junit/tests/running/core/CommandLineTest.java
================================================================
 [Lines 20 - 24 ] {
    oldOut = System.out;
    results = new ByteArrayOutputStream();
    System.setOut(new PrintStream(results));
}
 [Lines 27 - 29 ] {
    System.setOut(oldOut);
}
 [Lines 33 - 35 ] {
    testWasRun = true;
}
 [Lines 39 - 47 ] {
    testWasRun = false;
    new MainRunner().runWithCheckForSystemExit(new Runnable() {

        public void run() {
            JUnitCore.main("org.junit.tests.running.core.CommandLineTest$Example");
        }
    });
    assertTrue(testWasRun);
}
 [Lines 50 - 54 ] {
    testWasRun = false;
    JUnitCore.runClasses(Example.class);
    assertTrue(testWasRun);
}
 [Lines 60 - 62 ] {
    fCount++;
}
 [Lines 66 - 70 ] {
    fCount = 0;
    JUnitCore.runClasses(new Class[] { Count.class, Count.class });
    assertEquals(2, fCount);
}
 [Lines 73 - 77 ] {
    fCount = 0;
    JUnitCore.runClasses(Count.class, Count.class);
    assertEquals(2, fCount);
}

/src/test/java/org/junit/tests/running/core/SystemExitTest.java
===============================================================
 [Lines 16 - 18 ] {
    System.exit(EXIT_CODE);
}
 [Lines 22 - 30 ] {
    String java = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
    String classPath = getClass().getClassLoader().getResource(".").getFile() + File.pathSeparator + System.getProperty("java.class.path");
    String[] cmd = { java, "-cp", classPath, getClass().getName() + "$Exit" };
    Process process = Runtime.getRuntime().exec(cmd);
    InputStream input = process.getInputStream();
    while ((input.read()) != -1) ;
    assertEquals(EXIT_CODE, process.waitFor());
}

/src/test/java/org/junit/tests/running/classes/UseSuiteAsASuperclassTest.java
=============================================================================
 [Lines 17 - 18 ] {
}
 [Lines 23 - 25 ] {
    fail();
}
 [Lines 29 - 31 ] {
    super(klass, new Class[] { TestA.class, TestB.class });
}
 [Lines 39 - 44 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(AllWithMySuite.class);
    assertEquals(2, result.getRunCount());
    assertEquals(1, result.getFailureCount());
}

/src/test/java/org/junit/tests/running/classes/BlockJUnit4ClassRunnerTest.java
==============================================================================
 [Lines 15 - 16 ] {
}
 [Lines 21 - 32 ] {
    try {
        new BlockJUnit4ClassRunner(OuterClass.Enclosed.class);
    } catch (InitializationError e) {
        List<Throwable> causes = e.getCauses();
        assertEquals("Wrong number of causes.", 1, causes.size());
        assertEquals("Wrong exception.", "The inner class org.junit.tests.running.classes.BlockJUnit4ClassRunnerTest$OuterClass$Enclosed is not static.", causes.get(0).getMessage());
    }
}

/src/test/java/org/junit/tests/running/classes/RunWithTest.java
===============================================================
 [Lines 18 - 20 ] {
    log += "initialize";
}
 [Lines 23 - 25 ] {
    log += "run";
}
 [Lines 28 - 31 ] {
    log += "count";
    return 0;
}
 [Lines 34 - 37 ] {
    log += "plan";
    return Description.createSuiteDescription("example");
}
 [Lines 45 - 52 ] {
    log = "";
    JUnitCore.runClasses(ExampleTest.class);
    assertTrue(log.contains("plan"));
    assertTrue(log.contains("initialize"));
    assertTrue(log.contains("run"));
}
 [Lines 58 - 63 ] {
    log = "";
    JUnitCore.runClasses(SubExampleTest.class);
    assertTrue(log.contains("run"));
}
 [Lines 67 - 69 ] {
    return null;
}
 [Lines 72 - 74 ] {
// do nothing
}
 [Lines 82 - 87 ] {
    assertEquals("Custom runner class BadRunner should have a public constructor with signature BadRunner(Class testClass)", JUnitCore.runClasses(Empty.class).getFailures().get(0).getMessage());
}

/src/test/java/org/junit/tests/running/classes/ParentRunnerFilteringTest.java
=============================================================================
 [Lines 31 - 44 ] {
    return new Filter() {

        @Override
        public boolean shouldRun(Description description) {
            return description.getMethodName() == null || !description.getMethodName().equals(methodName);
        }

        @Override
        public String describe() {
            return "don't run method name: " + methodName;
        }
    };
}
 [Lines 50 - 58 ] {
    Integer count = countMap.get(description);
    if (count == null) {
        countMap.put(description, 1);
    } else {
        countMap.put(description, count + 1);
    }
    return true;
}
 [Lines 61 - 63 ] {
    return "filter counter";
}
 [Lines 65 - 71 ] {
    if (!countMap.containsKey(desc)) {
        throw new IllegalArgumentException("Looking for " + desc + ", but only contains: " + countMap.keySet());
    }
    return countMap.get(desc);
}
 [Lines 76 - 78 ] {
// passes
}
 [Lines 87 - 96 ] {
    Runner runner = Request.aClass(ExampleSuite.class).getRunner();
    Filter filter = notThisMethodName("test1");
    try {
        filter.apply(runner);
    } catch (NoTestsRemainException e) {
        return;
    }
    fail("Expected 'NoTestsRemainException' due to complete filtering");
}
 [Lines 102 - 104 ] {
    super(klass, builder);
}
 [Lines 107 - 109 ] {
    return Collections.unmodifiableList(super.getChildren());
}
 [Lines 118 - 128 ] {
    Runner runner = Request.aClass(ExampleSuiteWithUnmodifyableChildList.class).getRunner();
    Filter filter = notThisMethodName("test1");
    try {
        filter.apply(runner);
    } catch (NoTestsRemainException e) {
        return;
    }
    fail("Expected 'NoTestsRemainException' due to complete filtering");
}
 [Lines 131 - 136 ] {
    Request request = Request.aClass(ExampleSuite.class);
    Request requestFiltered = request.filterWith(notThisMethodName("test1"));
    assertThat(testResult(requestFiltered), hasSingleFailureContaining("don't run method name: test1"));
}
 [Lines 139 - 150 ] {
    JUnitCore junitCore = new JUnitCore();
    Request request = Request.aClass(ExampleTest.class);
    CountingFilter countingFilter = new CountingFilter();
    Request requestFiltered = request.filterWith(countingFilter);
    Result result = junitCore.run(requestFiltered);
    assertEquals(1, result.getRunCount());
    assertEquals(0, result.getFailureCount());
    Description desc = createTestDescription(ExampleTest.class, "test1");
    assertEquals(1, countingFilter.getCount(desc));
}
 [Lines 153 - 170 ] {
    Class<ExampleSuite> suiteClazz = ExampleSuite.class;
    Class<ExampleTest> clazz = ExampleTest.class;
    JUnitCore junitCore = new JUnitCore();
    Request request = Request.aClass(suiteClazz);
    CountingFilter countingFilter = new CountingFilter();
    Request requestFiltered = request.filterWith(countingFilter);
    Result result = junitCore.run(requestFiltered);
    assertEquals(1, result.getRunCount());
    assertEquals(0, result.getFailureCount());
    Description suiteDesc = createSuiteDescription(clazz);
    assertEquals(1, countingFilter.getCount(suiteDesc));
    Description desc = createTestDescription(ExampleTest.class, "test1");
    assertEquals(1, countingFilter.getCount(desc));
}

/src/test/java/org/junit/tests/running/classes/EnclosedTest.java
================================================================
 [Lines 18 - 18 ] {
}
 [Lines 21 - 21 ] {
}
 [Lines 25 - 25 ] {
}
 [Lines 28 - 28 ] {
}
 [Lines 31 - 31 ] {
}
 [Lines 34 - 34 ] {
}
 [Lines 39 - 42 ] {
    Runner runner = Request.aClass(Enclosing.class).getRunner();
    assertEquals(5, runner.testCount());
}
 [Lines 45 - 48 ] {
    Result result = JUnitCore.runClasses(Enclosing.class);
    assertEquals(5, result.getRunCount());
}
 [Lines 51 - 54 ] {
    assertEquals(Enclosing.class.getName(), Request.aClass(Enclosing.class).getRunner().getDescription().getDisplayName());
}

/src/test/java/org/junit/tests/running/classes/SuiteTest.java
=============================================================
 [Lines 28 - 29 ] {
}
 [Lines 34 - 36 ] {
    Assert.fail();
}
 [Lines 48 - 53 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(All.class);
    assertEquals(2, result.getRunCount());
    assertEquals(1, result.getFailureCount());
}
 [Lines 56 - 61 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(InheritsAll.class);
    assertEquals(2, result.getRunCount());
    assertEquals(1, result.getFailureCount());
}
 [Lines 64 - 67 ] {
    Runner runner = Request.aClass(All.class).getRunner();
    assertEquals(2, runner.testCount());
}
 [Lines 70 - 75 ] {
    junit.framework.Test test = new JUnit4TestAdapter(All.class);
    TestResult result = new TestResult();
    test.run(result);
    assertEquals(2, result.runCount());
}
 [Lines 78 - 82 ] {
    JUnit4TestAdapter adapter = new JUnit4TestAdapter(All.class);
    List<? extends junit.framework.Test> tests = adapter.getTests();
    assertEquals(2, tests.size());
}
 [Lines 85 - 88 ] {
    JUnit4TestAdapter adapter = new JUnit4TestAdapter(All.class);
    assertEquals(2, adapter.countTestCases());
}
 [Lines 97 - 99 ] {
    log += "before ";
}
 [Lines 102 - 104 ] {
    log += "after ";
}
 [Lines 108 - 112 ] {
    log = "";
    JUnitCore.runClasses(AllWithBeforeAndAfterClass.class);
    assertEquals("before after ", log);
}
 [Lines 119 - 126 ] {
    Result result = JUnitCore.runClasses(AllWithOutAnnotation.class);
    assertEquals(1, result.getFailureCount());
    String expected = String.format("class '%s' must have a SuiteClasses annotation", AllWithOutAnnotation.class.getName());
    assertEquals(expected, result.getFailures().get(0).getMessage());
}
 [Lines 134 - 137 ] {
    Result result = JUnitCore.runClasses(InfiniteLoop.class);
    assertEquals(1, result.getFailureCount());
}
 [Lines 145 - 148 ] {
    Result result = JUnitCore.runClasses(BiInfiniteLoop.class);
    assertEquals(2, result.getFailureCount());
}
 [Lines 165 - 168 ] {
    Result result = JUnitCore.runClasses(Hydra.class);
    assertEquals(2, result.getFailureCount());
}
 [Lines 173 - 175 ] {
}
 [Lines 179 - 182 ] {
    Result result = JUnitCore.runClasses(WithoutDefaultConstructor.class);
    assertTrue(result.wasSuccessful());
}
 [Lines 189 - 191 ] {
    assertThat(testResult(NoSuiteClassesAnnotation.class), hasSingleFailureContaining("SuiteClasses"));
}

/src/test/java/org/junit/tests/running/classes/ParentRunnerTest.java
====================================================================
 [Lines 37 - 39 ] {
    log += "apple ";
}
 [Lines 42 - 44 ] {
    log += "banana ";
}
 [Lines 48 - 65 ] {
    log = "";
    ParentRunner<?> runner = new BlockJUnit4ClassRunner(FruitTest.class);
    runner.setScheduler(new RunnerScheduler() {

        public void schedule(Runnable childStatement) {
            log += "before ";
            childStatement.run();
            log += "after ";
        }

        public void finished() {
            log += "afterAll ";
        }
    });
    runner.run(new RunNotifier());
    assertEquals("before apple after before banana after afterAll ", log);
}
 [Lines 68 - 77 ] {
    JUnitCore junitCore = new JUnitCore();
    Request request = Request.aClass(ExampleTest.class);
    Request requestFiltered = request.filterWith(new Exclude("test1"));
    Request requestFilteredFiltered = requestFiltered.filterWith(new Exclude("test2"));
    Result result = junitCore.run(requestFilteredFiltered);
    assertThat(result.getFailures(), isEmpty());
    assertEquals(1, result.getRunCount());
}
 [Lines 79 - 90 ] {
    return new TypeSafeMatcher<List<?>>() {

        public void describeTo(org.hamcrest.Description description) {
            description.appendText("is empty");
        }

        @Override
        public boolean matchesSafely(List<?> item) {
            return item.size() == 0;
        }
    };
}
 [Lines 95 - 97 ] {
    this.methodName = methodName;
}
 [Lines 100 - 102 ] {
    return !description.getMethodName().equals(methodName);
}
 [Lines 105 - 107 ] {
    return "filter method name: " + methodName;
}
 [Lines 112 - 113 ] {
}
 [Lines 116 - 117 ] {
}
 [Lines 120 - 121 ] {
}
 [Lines 125 - 128 ] {
    assertClassHasFailureMessage(TestWithProtectedClassRule.class, "The @ClassRule 'temporaryFolder' must be public.");
}
 [Lines 131 - 134 ] {
    assertClassHasFailureMessage(TestWithNonStaticClassRule.class, "The @ClassRule 'temporaryFolder' must be static.");
}
 [Lines 137 - 138 ] {
}
 [Lines 142 - 146 ] {
    assertClassHasFailureMessage(NonPublicTestClass.class, "The class org.junit.tests.running.classes.ParentRunnerTest$NonPublicTestClass is not public.");
}
 [Lines 148 - 155 ] {
    JUnitCore junitCore = new JUnitCore();
    Request request = Request.aClass(klass);
    Result result = junitCore.run(request);
    //the second failure is no runnable methods
    assertThat(result.getFailureCount(), is(2));
    assertThat(result.getFailures().get(0).getMessage(), is(equalTo(message)));
}
 [Lines 159 - 161 ] {
    throw new AssertionError("Thrown from @BeforeClass");
}
 [Lines 164 - 164 ] {
}
 [Lines 168 - 175 ] {
    CountingRunListener countingRunListener = runTestWithParentRunner(AssertionErrorAtParentLevelTest.class);
    Assert.assertEquals(0, countingRunListener.testStarted);
    Assert.assertEquals(0, countingRunListener.testFinished);
    Assert.assertEquals(1, countingRunListener.testFailure);
    Assert.assertEquals(0, countingRunListener.testAssumptionFailure);
    Assert.assertEquals(0, countingRunListener.testIgnored);
}
 [Lines 180 - 182 ] {
    throw new AssumptionViolatedException("Thrown from @BeforeClass");
}
 [Lines 185 - 185 ] {
}
 [Lines 189 - 196 ] {
    CountingRunListener countingRunListener = runTestWithParentRunner(AssumptionViolatedAtParentLevelTest.class);
    Assert.assertEquals(0, countingRunListener.testStarted);
    Assert.assertEquals(0, countingRunListener.testFinished);
    Assert.assertEquals(0, countingRunListener.testFailure);
    Assert.assertEquals(1, countingRunListener.testAssumptionFailure);
    Assert.assertEquals(0, countingRunListener.testIgnored);
}
 [Lines 200 - 200 ] {
}
 [Lines 203 - 205 ] {
    throw new AssertionError("Thrown from @Test");
}
 [Lines 209 - 209 ] {
}
 [Lines 213 - 215 ] {
    throw new AssumptionViolatedException("Thrown from @Test");
}
 [Lines 219 - 226 ] {
    CountingRunListener countingRunListener = runTestWithParentRunner(TestTest.class);
    Assert.assertEquals(3, countingRunListener.testStarted);
    Assert.assertEquals(3, countingRunListener.testFinished);
    Assert.assertEquals(1, countingRunListener.testFailure);
    Assert.assertEquals(1, countingRunListener.testAssumptionFailure);
    Assert.assertEquals(1, countingRunListener.testIgnored);
}
 [Lines 228 - 235 ] {
    CountingRunListener listener = new CountingRunListener();
    RunNotifier runNotifier = new RunNotifier();
    runNotifier.addListener(listener);
    ParentRunner<?> runner = new BlockJUnit4ClassRunner(testClass);
    runner.run(runNotifier);
    return listener;
}
 [Lines 245 - 247 ] {
    testStarted++;
}
 [Lines 250 - 252 ] {
    testFinished++;
}
 [Lines 255 - 257 ] {
    testFailure++;
}
 [Lines 260 - 262 ] {
    testAssumptionFailure++;
}
 [Lines 265 - 267 ] {
    testIgnored++;
}

/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java
=========================================================================
 [Lines 38 - 41 ] {
    return Arrays.asList(new Object[][] { { 0, 0, 0 }, { 1, 1, 2 }, { 3, 2, 5 }, { 4, 3, 7 } });
}
 [Lines 49 - 53 ] {
    this.firstSummand = firstSummand;
    this.secondSummand = secondSummand;
    this.sum = sum;
}
 [Lines 56 - 58 ] {
    assertEquals(sum, firstSummand + secondSummand);
}
 [Lines 62 - 65 ] {
    Result result = JUnitCore.runClasses(AdditionTest.class);
    assertEquals(4, result.getRunCount());
}
 [Lines 68 - 71 ] {
    Runner runner = Request.aClass(AdditionTest.class).getRunner();
    assertEquals(4, runner.testCount());
}
 [Lines 74 - 79 ] {
    Runner runner = Request.aClass(AdditionTest.class).getRunner();
    Description description = runner.getDescription();
    assertEquals("[2: 3 + 2 = 5]", description.getChildren().get(2).getDisplayName());
}
 [Lines 84 - 86 ] {
    return Arrays.asList(1, 2, 3);
}
 [Lines 92 - 94 ] {
    fail();
}
 [Lines 98 - 101 ] {
    Result result = JUnitCore.runClasses(ThreeFailures.class);
    assertEquals(3, result.getFailureCount());
}
 [Lines 104 - 109 ] {
    Result result = JUnitCore.runClasses(ThreeFailures.class);
    assertEquals("testSomething[0: x=1](" + ThreeFailures.class.getName() + ")", result.getFailures().get(0).getTestHeader());
}
 [Lines 114 - 116 ] {
    return Arrays.asList(new Object[][] { { 3 }, { 3 } });
}
 [Lines 118 - 119 ] {
}
 [Lines 122 - 123 ] {
}
 [Lines 127 - 132 ] {
    Runner runner = Request.aClass(ParameterizedWithoutSpecialTestname.class).getRunner();
    Description description = runner.getDescription();
    assertEquals("[1]", description.getChildren().get(1).getDisplayName());
}
 [Lines 137 - 140 ] {
    return Arrays.asList(new Object[][] { { 0, 0, 0 }, { 1, 1, 2 }, { 3, 2, 5 }, { 4, 3, 7 } });
}
 [Lines 152 - 154 ] {
    assertEquals(sum, firstSummand + secondSummand);
}
 [Lines 158 - 162 ] {
    Result result = JUnitCore.runClasses(AdditionTestWithAnnotatedFields.class);
    assertEquals(4, result.getRunCount());
    assertEquals(0, result.getFailureCount());
}
 [Lines 167 - 169 ] {
    return Arrays.asList(new Object[][] { { 0 } });
}
 [Lines 177 - 179 ] {
    assertEquals(fExpected, fib(fInput));
}
 [Lines 181 - 183 ] {
    return 0;
}
 [Lines 187 - 194 ] {
    Result result = JUnitCore.runClasses(BadIndexForAnnotatedFieldTest.class);
    assertEquals(2, result.getFailureCount());
    List<Failure> failures = result.getFailures();
    assertEquals("Invalid @Parameter value: 2. @Parameter fields counted: 1. Please use an index between 0 and 0.", failures.get(0).getException().getMessage());
    assertEquals("@Parameter(0) is never used.", failures.get(1).getException().getMessage());
}
 [Lines 199 - 201 ] {
    return Arrays.asList(new Object[][] { { 0, 0 } });
}
 [Lines 209 - 211 ] {
    assertEquals(fExpected, fib(fInput));
}
 [Lines 213 - 215 ] {
    return 0;
}
 [Lines 219 - 224 ] {
    Result result = JUnitCore.runClasses(BadNumberOfAnnotatedFieldTest.class);
    assertEquals(1, result.getFailureCount());
    List<Failure> failures = result.getFailures();
    assertTrue(failures.get(0).getException().getMessage().contains("Wrong number of parameters and @Parameter fields. @Parameter fields counted: 1, available parameters: 2."));
}
 [Lines 231 - 233 ] {
    fLog += "before ";
}
 [Lines 236 - 238 ] {
    fLog += "after ";
}
 [Lines 240 - 242 ] {
}
 [Lines 245 - 247 ] {
    return Arrays.asList(new Object[][] { { 3 } });
}
 [Lines 250 - 251 ] {
}
 [Lines 255 - 259 ] {
    fLog = "";
    JUnitCore.runClasses(BeforeAndAfter.class);
    assertEquals("before after ", fLog);
}
 [Lines 264 - 266 ] {
    fLog += "before ";
}
 [Lines 269 - 271 ] {
    fLog += "after ";
}
 [Lines 275 - 278 ] {
    Result result = JUnitCore.runClasses(EmptyTest.class);
    assertEquals(1, result.getFailureCount());
}
 [Lines 283 - 285 ] {
    return 0;
}
 [Lines 288 - 290 ] {
    return Collections.singletonList(new Object[] { 1 });
}
 [Lines 294 - 297 ] {
    Result result = JUnitCore.runClasses(IncorrectTest.class);
    assertEquals(1, result.getFailureCount());
}
 [Lines 302 - 304 ] {
    return Collections.emptyList();
}
 [Lines 307 - 308 ] {
}
 [Lines 312 - 316 ] {
    assertTestCreatesSingleFailureWithMessage(ProtectedParametersTest.class, "No public static parameters method on class " + ProtectedParametersTest.class.getName());
}
 [Lines 321 - 323 ] {
    return "foo";
}
 [Lines 326 - 327 ] {
}
 [Lines 331 - 335 ] {
    assertThat(testResult(ParametersNotIterable.class).toString(), containsString("ParametersNotIterable.data() must return an Iterable of arrays."));
}
 [Lines 339 - 341 ] {
}
 [Lines 344 - 346 ] {
    return Arrays.asList(new Object[][] { { 3 } });
}
 [Lines 349 - 350 ] {
}
 [Lines 354 - 356 ] {
    new Parameterized(PrivateConstructor.class);
}
 [Lines 361 - 364 ] {
    return new Object[][] { { 0, 0, 0 }, { 1, 1, 2 }, { 3, 2, 5 }, { 4, 3, 7 } };
}
 [Lines 376 - 378 ] {
    assertEquals(sum, firstSummand + secondSummand);
}
 [Lines 382 - 385 ] {
    Result result = JUnitCore.runClasses(AdditionTestWithArray.class);
    assertEquals(4, result.getRunCount());
}
 [Lines 390 - 392 ] {
    return new Object[] { "first test", "second test" };
}
 [Lines 394 - 395 ] {
}
 [Lines 398 - 399 ] {
}
 [Lines 403 - 406 ] {
    Result result = JUnitCore.runClasses(SingleArgumentTestWithArray.class);
    assertEquals(2, result.getRunCount());
}
 [Lines 411 - 413 ] {
    return asList("first test", "second test");
}
 [Lines 415 - 416 ] {
}
 [Lines 419 - 420 ] {
}
 [Lines 424 - 428 ] {
    Result result = JUnitCore.runClasses(SingleArgumentTestWithIterable.class);
    assertEquals(2, result.getRunCount());
}
 [Lines 433 - 436 ] {
    throw new InitializationError("Called ExceptionThrowingRunnerFactory.");
}
 [Lines 443 - 445 ] {
    return asList("single test");
}
 [Lines 447 - 448 ] {
}
 [Lines 451 - 452 ] {
}
 [Lines 456 - 460 ] {
    assertTestCreatesSingleFailureWithMessage(TestWithUseParametersRunnerFactoryAnnotation.class, "Called ExceptionThrowingRunnerFactory.");
}
 [Lines 462 - 466 ] {
    Result result = JUnitCore.runClasses(test);
    assertEquals(1, result.getFailures().size());
    assertEquals(message, result.getFailures().get(0).getMessage());
}
 [Lines 472 - 474 ] {
    return asList("single test");
}
 [Lines 480 - 482 ] {
}
 [Lines 485 - 486 ] {
}
 [Lines 490 - 494 ] {
    assertTestCreatesSingleFailureWithMessage(UseParameterizedFactoryTest.class, "Called ExceptionThrowingRunnerFactory.");
}

/src/test/java/org/junit/tests/running/classes/IgnoreClassTest.java
===================================================================
 [Lines 15 - 17 ] {
    fail();
}
 [Lines 20 - 22 ] {
    fail();
}
 [Lines 26 - 30 ] {
    Result result = JUnitCore.runClasses(IgnoreMe.class);
    assertEquals(0, result.getFailureCount());
    assertEquals(1, result.getIgnoreCount());
}

/src/test/java/org/junit/tests/running/classes/ClassLevelMethodsWithIgnoredTestsTest.java
=========================================================================================
 [Lines 33 - 35 ] {
    fail(FAILURE_MESSAGE);
}
 [Lines 39 - 41 ] {
    fail("test() should not run");
}
 [Lines 45 - 48 ] {
    runClassAndVerifyNoFailures(BeforeClassWithIgnoredTest.class, "BeforeClass should not have been executed because the test method is ignored!");
}
 [Lines 53 - 55 ] {
    fail(FAILURE_MESSAGE);
}
 [Lines 58 - 60 ] {
    fail("test() should not run");
}
 [Lines 64 - 68 ] {
    runClassAndVerifyNoFailures(BeforeClassWithIgnoredClass.class, "BeforeClass should not have been executed because the whole test class is ignored!");
}
 [Lines 73 - 75 ] {
    fail("test() should not run");
}
 [Lines 78 - 80 ] {
    fail(FAILURE_MESSAGE);
}
 [Lines 84 - 87 ] {
    runClassAndVerifyNoFailures(AfterClassWithIgnoredTest.class, "AfterClass should not have been executed because the test method is ignored!");
}
 [Lines 94 - 96 ] {
    fail(FAILURE_MESSAGE);
}
 [Lines 100 - 102 ] {
    fail("test() should not run");
}
 [Lines 107 - 109 ] {
// to prevent errors when all other tests have been filtered
}
 [Lines 113 - 120 ] {
    Result result = new JUnitCore().run(Request.classes(BeforeClassWithFilteredTest.class, HasUnfilteredTest.class).filterWith(CategoryFilter.exclude(FilteredTests.class)));
    analyseResult(result, "BeforeClass should not have been executed because the test method is filtered!");
}
 [Lines 123 - 125 ] {
    throw new RuntimeException("this rule is broken");
}
 [Lines 134 - 136 ] {
    fail("test() should not be run");
}
 [Lines 140 - 143 ] {
    runClassAndVerifyNoFailures(ClassRuleWithIgnoredTest.class, "The class rule should have been applied because the test method is ignored!");
}
 [Lines 146 - 149 ] {
    Result result = JUnitCore.runClasses(klass);
    analyseResult(result, testFailureDescription);
}
 [Lines 151 - 156 ] {
    List<Failure> failures = result.getFailures();
    if (failures.isEmpty() == false) {
        analyzeFailure(failures.get(0), testFailureDescription);
    }
}
 [Lines 158 - 164 ] {
    String actualFailureMsg = failure.getMessage();
    if (FAILURE_MESSAGE.equals(actualFailureMsg)) {
        fail(testFailureDescription);
    }
    fail("Unexpected failure : " + actualFailureMsg);
}

/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java
============================================================================
 [Lines 28 - 30 ] {
    fSynchronizer = new CountDownLatch(2);
}
 [Lines 33 - 37 ] {
    fSynchronizer.countDown();
    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));
    fOne = Thread.currentThread();
}
 [Lines 40 - 44 ] {
    fSynchronizer.countDown();
    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));
    fTwo = Thread.currentThread();
}
 [Lines 48 - 51 ] {
    fOne = null;
    fTwo = null;
}
 [Lines 54 - 60 ] {
    Result result = JUnitCore.runClasses(ParallelComputer.methods(), Example.class);
    assertTrue(result.wasSuccessful());
    assertNotNull(fOne);
    assertNotNull(fTwo);
    assertThat(fOne, is(not(fTwo)));
}

/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java
===========================================================================
 [Lines 28 - 32 ] {
    fSynchronizer.countDown();
    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));
    fExample1One = Thread.currentThread();
}
 [Lines 35 - 39 ] {
    fSynchronizer.countDown();
    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));
    fExample1Two = Thread.currentThread();
}
 [Lines 44 - 48 ] {
    fSynchronizer.countDown();
    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));
    fExample2One = Thread.currentThread();
}
 [Lines 51 - 55 ] {
    fSynchronizer.countDown();
    assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));
    fExample2Two = Thread.currentThread();
}
 [Lines 59 - 65 ] {
    fExample1One = null;
    fExample1Two = null;
    fExample2One = null;
    fExample2Two = null;
    fSynchronizer = new CountDownLatch(2);
}
 [Lines 68 - 78 ] {
    Result result = JUnitCore.runClasses(ParallelComputer.classes(), Example1.class, Example2.class);
    assertTrue(result.wasSuccessful());
    assertNotNull(fExample1One);
    assertNotNull(fExample1Two);
    assertNotNull(fExample2One);
    assertNotNull(fExample2Two);
    assertThat(fExample1One, is(fExample1Two));
    assertThat(fExample2One, is(fExample2Two));
    assertThat(fExample1One, is(not(fExample2One)));
}

/src/test/java/org/junit/tests/experimental/ExperimentalTests.java
==================================================================

/src/test/java/org/junit/tests/experimental/AssumptionTest.java
===============================================================
 [Lines 33 - 36 ] {
    assumeThat(3, is(4));
    fail();
}
 [Lines 40 - 45 ] {
    Result result = JUnitCore.runClasses(HasFailingAssumption.class);
    assertThat(result.getRunCount(), is(1));
    assertThat(result.getIgnoreCount(), is(0));
    assertThat(result.getFailureCount(), is(0));
}
 [Lines 50 - 62 ] {
    assumptionFailures = 0;
    JUnitCore core = new JUnitCore();
    core.addListener(new RunListener() {

        @Override
        public void testAssumptionFailure(Failure failure) {
            assumptionFailures++;
        }
    });
    core.run(HasFailingAssumption.class);
    assertThat(assumptionFailures, is(1));
}
 [Lines 66 - 69 ] {
    assumeThat(3, is(3));
    fail();
}
 [Lines 73 - 78 ] {
    Result result = JUnitCore.runClasses(HasPassingAssumption.class);
    assertThat(result.getRunCount(), is(1));
    assertThat(result.getIgnoreCount(), is(0));
    assertThat(result.getFailureCount(), is(1));
}
 [Lines 81 - 83 ] {
    assumeThat(1, is(2));
}
 [Lines 86 - 89 ] {
    assumeThat(1, is(1));
    assertCompletesNormally();
}
 [Lines 92 - 95 ] {
    assumeThat("x", is("x"));
    assertCompletesNormally();
}
 [Lines 98 - 101 ] {
    Object[] objects = { 1, 2, null };
    assumeNotNull(objects);
}
 [Lines 104 - 108 ] {
    Object[] objects = { 1, 2 };
    assumeNotNull(objects);
    assertCompletesNormally();
}
 [Lines 111 - 120 ] {
    try {
        Object[] objects = { 1, 2, null };
        assumeNotNull(objects);
    } catch (AssumptionViolatedException e) {
        assertThat(e.getMessage(), containsString("1, 2, null"));
    } catch (Exception e) {
        fail("Should have thrown AssumptionViolatedException");
    }
}
 [Lines 123 - 131 ] {
    final Throwable exception = new NullPointerException();
    try {
        assumeNoException(exception);
        fail("Should have thrown exception");
    } catch (AssumptionViolatedException e) {
        assertThat(e.getCause(), is(exception));
    }
}
 [Lines 133 - 134 ] {
}
 [Lines 137 - 139 ] {
    Assume.assumeTrue(false);
}
 [Lines 143 - 145 ] {
    assumeTrue(false);
}
 [Lines 148 - 150 ] {
    fail();
}
 [Lines 154 - 156 ] {
    assertThat(testResult(HasFailingAssumeInBefore.class), isSuccessful());
}
 [Lines 160 - 162 ] {
    assumeTrue(false);
}
 [Lines 165 - 167 ] {
    fail();
}
 [Lines 171 - 173 ] {
    assertThat(testResult(HasFailingAssumeInBeforeClass.class), isSuccessful());
}
 [Lines 176 - 178 ] {
    assumeTrue(false);
}
 [Lines 181 - 183 ] {
    fail();
}
 [Lines 187 - 189 ] {
    assertThat(testResult(AssumptionFailureInConstructor.class), isSuccessful());
}
 [Lines 192 - 194 ] {
    assumeTrue(false);
}
 [Lines 204 - 206 ] {
    assumeTrue(message, false);
}
 [Lines 210 - 215 ] {
    final List<Failure> failures = runAndGetAssumptionFailures(HasAssumeWithMessage.class);
    assertTrue(failures.get(0).getMessage().contains(message));
}
 [Lines 222 - 224 ] {
    assumeNoException(message, e);
}
 [Lines 228 - 233 ] {
    final List<Failure> failures = runAndGetAssumptionFailures(HasAssumeWithMessageAndCause.class);
    assertTrue(failures.get(0).getMessage().contains(message));
    assertSame(failures.get(0).getException().getCause(), e);
}
 [Lines 237 - 240 ] {
    assumeThat(message, 3, is(4));
    fail();
}
 [Lines 244 - 250 ] {
    final List<Failure> failures = runAndGetAssumptionFailures(HasFailingAssumptionWithMessage.class);
    assertEquals(failures.size(), 1);
    assertTrue(failures.get(0).getMessage().contains(message));
}
 [Lines 256 - 267 ] {
    final List<Failure> failures = new ArrayList<Failure>();
    final JUnitCore core = new JUnitCore();
    core.addListener(new RunListener() {

        @Override
        public void testAssumptionFailure(Failure failure) {
            failures.add(failure);
        }
    });
    core.run(clazz);
    return failures;
}

/src/test/java/org/junit/tests/experimental/theories/ParameterSignatureTest.java
================================================================================
 [Lines 26 - 29 ] {
    return ParameterSignatureTest.class.getMethod("getType", Method.class, int.class);
}
 [Lines 38 - 42 ] {
    assumeTrue(index < method.getParameterTypes().length);
    assertEquals(method.getParameterTypes()[index], ParameterSignature.signatures(method).get(index).getType());
}
 [Lines 44 - 45 ] {
}
 [Lines 49 - 55 ] {
    Method method = getClass().getMethod("foo", int.class);
    List<Annotation> annotations = ParameterSignature.signatures(method).get(0).getAnnotations();
    assertThat(annotations, CoreMatchers.<TestedOn>hasItem(isA(TestedOn.class)));
}
 [Lines 57 - 58 ] {
}
 [Lines 60 - 61 ] {
}
 [Lines 63 - 64 ] {
}
 [Lines 67 - 73 ] {
    List<ParameterSignature> signatures = ParameterSignature.signatures(getClass().getMethod("integerMethod", Integer.class));
    ParameterSignature integerSignature = signatures.get(0);
    assertTrue(integerSignature.canAcceptType(int.class));
}
 [Lines 76 - 82 ] {
    List<ParameterSignature> signatures = ParameterSignature.signatures(getClass().getMethod("numberMethod", Number.class));
    ParameterSignature numberSignature = signatures.get(0);
    assertTrue(numberSignature.canAcceptType(int.class));
}
 [Lines 85 - 91 ] {
    List<ParameterSignature> signatures = ParameterSignature.signatures(getClass().getMethod("intMethod", int.class));
    ParameterSignature intSignature = signatures.get(0);
    assertTrue(intSignature.canAcceptType(Integer.class));
}

/src/test/java/org/junit/tests/experimental/theories/PotentialAssignmentTest.java
=================================================================================
 [Lines 11 - 23 ] {
    String name = "stringDatapoint";
    Object value = new Object() {

        @Override
        public String toString() {
            return "string value";
        }
    };
    PotentialAssignment assignment = PotentialAssignment.forValue(name, value);
    assertEquals("\"string value\" <from stringDatapoint>", assignment.getDescription());
}
 [Lines 26 - 33 ] {
    String name = "nullDatapoint";
    Object value = null;
    PotentialAssignment assignment = PotentialAssignment.forValue(name, value);
    assertEquals("null <from nullDatapoint>", assignment.getDescription());
}
 [Lines 36 - 48 ] {
    String name = "explodingValue";
    Object value = new Object() {

        @Override
        public String toString() {
            throw new RuntimeException("Oh no!");
        }
    };
    PotentialAssignment assignment = PotentialAssignment.forValue(name, value);
    assertEquals("[toString() threw RuntimeException: Oh no!] <from explodingValue>", assignment.getDescription());
}
 [Lines 51 - 55 ] {
    Object value = new Object();
    PotentialAssignment assignment = PotentialAssignment.forValue("name", value);
    assertEquals(value, assignment.getValue());
}

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java
============================================================================================
 [Lines 17 - 19 ] {
    super(klass);
}
 [Lines 22 - 24 ] {
    return new StubbedTheoryAnchor(method, getTestClass());
}
 [Lines 27 - 29 ] {
    super(method, testClass);
}
 [Lines 34 - 39 ] {
    super.handleAssumptionViolation(e);
    for (GuesserQueue queue : queues) {
        queue.update(e);
    }
}
 [Lines 43 - 49 ] {
    GuesserQueue guessers = createGuesserQueue(incomplete);
    queues.add(guessers);
    while (!guessers.isEmpty()) runWithAssignment(incomplete.assignNext(guessers.remove(0)));
    queues.remove(guessers);
}
 [Lines 52 - 62 ] {
    ParameterSignature nextUnassigned = incomplete.nextUnassigned();
    if (nextUnassigned.hasAnnotation(Stub.class)) {
        GuesserQueue queue = new GuesserQueue();
        queue.add(new Guesser<Object>(nextUnassigned.getType()));
        return queue;
    }
    return GuesserQueue.forSingleValues(incomplete.potentialsForNextUnassigned());
}

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/Stub.java
=================================================================================

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StringableObject.java
=============================================================================================
 [Lines 8 - 10 ] {
    this.obj = obj;
}
 [Lines 12 - 18 ] {
    if (isListableArray()) {
        return Arrays.asList((Object[]) obj);
    } else {
        return obj;
    }
}
 [Lines 20 - 23 ] {
    Class<?> type = obj.getClass();
    return type.isArray() && !type.getComponentType().isPrimitive();
}
 [Lines 26 - 28 ] {
    return stringableObject().toString();
}

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/ReguessableValue.java
=============================================================================================
 [Lines 10 - 12 ] {
    super();
}

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheoriesTest.java
================================================================================================
 [Lines 12 - 15 ] {
    assumeThat(correspondent.getAnswer("What is five?", "four", "five"), is("five"));
}

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/Guesser.java
====================================================================================
 [Lines 21 - 23 ] {
    super(guesses);
}
 [Lines 25 - 26 ] {
}
 [Lines 28 - 36 ] {
    GuessMap newGuesses = new GuessMap(this);
    for (Entry<MethodCall, Object> entry : newGuesses.entrySet()) {
        if (entry.getValue().equals(oldValue)) {
            entry.setValue(newValue);
        }
    }
    return newGuesses;
}
 [Lines 38 - 47 ] {
    if (returnType.equals(String.class)) {
        return "GUESS" + new Random().nextInt();
    }
    if (returnType.equals(Integer.class) || returnType.equals(int.class)) {
        return new Random().nextInt();
    }
    return null;
}
 [Lines 49 - 54 ] {
    if (!containsKey(call)) {
        put(call, generateGuess(call.getReturnType()));
    }
    return get(call);
}
 [Lines 57 - 59 ] {
    return getGuess(new MethodCall(method, args));
}
 [Lines 66 - 68 ] {
    this(type, new GuessMap());
}
 [Lines 70 - 73 ] {
    this.type = type2;
    this.guesses = guesses;
}
 [Lines 76 - 79 ] {
    return (T) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { getType() }, guesses);
}
 [Lines 82 - 110 ] {
    final ArrayList<ReguessableValue> returnThis = new ArrayList<ReguessableValue>();
    e.describeTo(new BaseDescription() {

        @Override
        protected void append(char arg0) {
        }

        boolean expectedSeen = false;

        Object expected = null;

        @Override
        public Description appendValue(Object value) {
            noteValue(value);
            return super.appendValue(value);
        }

        private void noteValue(Object value) {
            if (!expectedSeen) {
                expected = value;
                expectedSeen = true;
                return;
            }
            GuessMap newGuesses = guesses.replaceGuess(expected, value);
            returnThis.add(new Guesser<T>(getType(), newGuesses));
        }
    });
    return returnThis;
}
 [Lines 113 - 115 ] {
    return getProxy();
}
 [Lines 117 - 119 ] {
    return type;
}
 [Lines 122 - 124 ] {
    return "guesser[" + type + "]";
}

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/Correspondent.java
==========================================================================================

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/GuesserQueue.java
=========================================================================================
 [Lines 14 - 16 ] {
    this.delegate = delegate;
}
 [Lines 19 - 21 ] {
    return Collections.emptyList();
}
 [Lines 24 - 26 ] {
    return delegate.getValue();
}
 [Lines 29 - 31 ] {
    return delegate.getDescription();
}
 [Lines 35 - 42 ] {
    GuesserQueue returnThis = new GuesserQueue();
    for (PotentialAssignment potentialParameterValue : potentials) {
        returnThis.add(new GuesserQueue.ReguessableDecorator(potentialParameterValue));
    }
    return returnThis;
}
 [Lines 47 - 51 ] {
    if (lastRemoved != null) {
        addAll(lastRemoved.reguesses(e));
    }
}
 [Lines 54 - 57 ] {
    lastRemoved = super.remove(index);
    return lastRemoved;
}

/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/MethodCall.java
=======================================================================================
 [Lines 12 - 15 ] {
    this.method = method;
    this.args = args;
}
 [Lines 18 - 21 ] {
    MethodCall call = (MethodCall) obj;
    return call.method.equals(method) && Arrays.deepEquals(call.args, args);
}
 [Lines 24 - 26 ] {
    return 1;
}
 [Lines 28 - 30 ] {
    return method.getReturnType();
}
 [Lines 33 - 35 ] {
    return String.format("%s(%s)", method.getName(), argListString());
}
 [Lines 37 - 42 ] {
    if (args == null) {
        return null;
    }
    return argList().toString().substring(1, argList().toString().length() - 1);
}
 [Lines 44 - 50 ] {
    ArrayList<Object> list = new ArrayList<Object>();
    for (Object arg : args) {
        list.add(new StringableObject(arg));
    }
    return list;
}
 [Lines 52 - 54 ] {
    return new StringableObject(arg).stringableObject();
}

/src/test/java/org/junit/tests/experimental/theories/runner/WithParameterSupplier.java
======================================================================================
 [Lines 32 - 35 ] {
    this.value = value;
    this.description = description;
}
 [Lines 38 - 40 ] {
    return value;
}
 [Lines 43 - 45 ] {
    return description;
}
 [Lines 53 - 62 ] {
    List<PotentialAssignment> assignments = new ArrayList<PotentialAssignment>();
    for (String datapoint : DATAPOINTS) {
        assignments.add(new SimplePotentialAssignment(datapoint, datapoint));
    }
    return assignments;
}
 [Lines 70 - 71 ] {
}
 [Lines 76 - 83 ] {
    List<PotentialAssignment> assignments = potentialAssignments(TestClassUsingParameterSupplier.class.getMethod("theoryMethod", String.class));
    assertEquals(2, assignments.size());
    assertEquals(DATAPOINTS.get(0), assignments.get(0).getValue());
    assertEquals(DATAPOINTS.get(1), assignments.get(1).getValue());
}
 [Lines 87 - 88 ] {
}
 [Lines 91 - 93 ] {
    return null;
}
 [Lines 101 - 102 ] {
}
 [Lines 107 - 110 ] {
    expected.expect(InitializationError.class);
    new Theories(TestClassUsingSupplierWithUnknownConstructor.class);
}
 [Lines 114 - 115 ] {
}
 [Lines 118 - 120 ] {
    return null;
}
 [Lines 128 - 129 ] {
}
 [Lines 134 - 137 ] {
    expected.expect(InitializationError.class);
    new Theories(TestClassUsingSupplierWithTwoConstructors.class);
}
 [Lines 141 - 142 ] {
}
 [Lines 145 - 147 ] {
    return null;
}
 [Lines 155 - 156 ] {
}
 [Lines 161 - 163 ] {
    new Theories(TestClassUsingSupplierWithTestClassConstructor.class);
}

/src/test/java/org/junit/tests/experimental/theories/runner/WithDataPointMethod.java
====================================================================================
 [Lines 30 - 32 ] {
    return 100;
}
 [Lines 35 - 36 ] {
}
 [Lines 40 - 42 ] {
    assertThat(testResult(HasDataPointMethod.class), isSuccessful());
}
 [Lines 47 - 49 ] {
    return new ArrayList<Object>();
}
 [Lines 58 - 61 ] {
    assertThat(first.size(), is(0));
    first.add("a");
}
 [Lines 65 - 67 ] {
    assertThat(failures(DataPointMethodReturnsMutableObject.class), empty());
}
 [Lines 72 - 74 ] {
    return 100;
}
 [Lines 76 - 78 ] {
    return new Date();
}
 [Lines 81 - 82 ] {
}
 [Lines 85 - 86 ] {
}
 [Lines 89 - 90 ] {
}
 [Lines 94 - 98 ] {
    assertThat(potentialAssignments(HasDateMethod.class.getMethod("onlyStringsOk", String.class)).toString(), not(containsString("100")));
}
 [Lines 101 - 105 ] {
    assertThat(potentialAssignments(HasDateMethod.class.getMethod("onlyDatesOk", Date.class)).size(), is(0));
}
 [Lines 107 - 109 ] {
    return JUnitCore.runClasses(type).getFailures();
}
 [Lines 111 - 113 ] {
    return everyItem(nullValue(Failure.class));
}

/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java
================================================================================================
 [Lines 28 - 30 ] {
    assertThat(x, is(0));
}
 [Lines 34 - 37 ] {
    assertThat(new Theories(HasAFailingTheory.class).getDescription().getChildren().size(), is(1));
}
 [Lines 40 - 43 ] {
    assertThat(new TestClass(HasAFailingTheory.class).getAnnotatedMethods(Theory.class).size(), is(1));
}
 [Lines 46 - 49 ] {
    assertThat(testResult(HasAFailingTheory.class), hasSingleFailureContaining("Expected"));
}
 [Lines 57 - 59 ] {
    assertThat(2, is(3));
}
 [Lines 63 - 66 ] {
    assertThat(testResult(DoesntUseParams.class), hasSingleFailureContaining("everythingIsZero(\"1\" <from ONE>, \"1\" <from ONE>)"));
}
 [Lines 77 - 79 ] {
    assertThat(a, is("A"));
}
 [Lines 83 - 86 ] {
    assertThat(testResult(NullsOK.class), hasSingleFailureContaining("null"));
}
 [Lines 94 - 96 ] {
}
 [Lines 100 - 104 ] {
    assertThat(testResult(TheoriesMustBePublic.class), hasSingleFailureContaining("public"));
}
 [Lines 115 - 117 ] {
}
 [Lines 121 - 129 ] {
    assertThat(testResult(DataPointFieldsMustBeStatic.class), CoreMatchers.<PrintableResult>both(failureCountIs(2)).and(hasFailureContaining("DataPoint field THREE must be static")).and(hasFailureContaining("DataPoint field FOURS must be static")));
}
 [Lines 134 - 136 ] {
    return 1;
}
 [Lines 139 - 141 ] {
    return new int[] { 1, 2, 3 };
}
 [Lines 144 - 146 ] {
}
 [Lines 150 - 158 ] {
    assertThat(testResult(DataPointMethodsMustBeStatic.class), CoreMatchers.<PrintableResult>both(failureCountIs(2)).and(hasFailureContaining("DataPoint method singleDataPointMethod must be static")).and(hasFailureContaining("DataPoint method dataPointArrayMethod must be static")));
}
 [Lines 181 - 183 ] {
}
 [Lines 187 - 198 ] {
    PrintableResult result = testResult(DataPointFieldsMustBePublic.class);
    assertEquals(6, result.failureCount());
    assertThat(result, allOf(hasFailureContaining("DataPoint field THREE must be public"), hasFailureContaining("DataPoint field THREES must be public"), hasFailureContaining("DataPoint field FOUR must be public"), hasFailureContaining("DataPoint field FOURS must be public"), hasFailureContaining("DataPoint field FIVE must be public"), hasFailureContaining("DataPoint field FIVES must be public")));
}
 [Lines 203 - 205 ] {
    return 3;
}
 [Lines 208 - 210 ] {
    return new int[] { 3 };
}
 [Lines 213 - 215 ] {
    return 4;
}
 [Lines 218 - 220 ] {
    return new int[] { 4 };
}
 [Lines 223 - 225 ] {
    return 5;
}
 [Lines 228 - 230 ] {
    return new int[] { 5 };
}
 [Lines 233 - 235 ] {
}
 [Lines 239 - 250 ] {
    PrintableResult result = testResult(DataPointMethodsMustBePublic.class);
    assertEquals(6, result.failureCount());
    assertThat(result, allOf(hasFailureContaining("DataPoint method three must be public"), hasFailureContaining("DataPoint method threes must be public"), hasFailureContaining("DataPoint method four must be public"), hasFailureContaining("DataPoint method fours must be public"), hasFailureContaining("DataPoint method five must be public"), hasFailureContaining("DataPoint method fives must be public")));
}

/src/test/java/org/junit/tests/experimental/theories/runner/WithOnlyTestAnnotations.java
========================================================================================
 [Lines 22 - 24 ] {
}
 [Lines 28 - 30 ] {
    assertThat(testResult(HonorExpectedException.class).failureCount(), is(1));
}
 [Lines 35 - 37 ] {
    throw new NullPointerException();
}
 [Lines 41 - 43 ] {
    assertThat(testResult(HonorExpectedExceptionPasses.class), isSuccessful());
}
 [Lines 48 - 56 ] {
    while (true) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }
    }
}
 [Lines 60 - 62 ] {
    assertThat(testResult(HonorTimeout.class), failureCountIs(1));
}
 [Lines 70 - 71 ] {
}
 [Lines 75 - 81 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(ErrorWhenTestHasParametersDespiteTheories.class);
    assertEquals(1, result.getFailureCount());
    String message = result.getFailures().get(0).getMessage();
    assertThat(message, containsString("should have no parameters"));
}

/src/test/java/org/junit/tests/experimental/theories/runner/WithExtendedParameterSources.java
=============================================================================================
 [Lines 25 - 27 ] {
    assertThat(number, is(1));
}
 [Lines 31 - 34 ] {
    assertThat(testResult(ParameterAnnotations.class), ResultMatchers.isSuccessful());
}
 [Lines 46 - 48 ] {
    assertThat(s, notNullValue());
}
 [Lines 52 - 54 ] {
    assertThat(testResult(ShouldFilterOutNullSingleDataPoints.class), isSuccessful());
}
 [Lines 62 - 64 ] {
    assertThat(s, notNullValue());
}
 [Lines 68 - 70 ] {
    assertThat(testResult(ShouldFilterOutNullElementsFromDataPointArrays.class), isSuccessful());
}
 [Lines 78 - 79 ] {
}
 [Lines 83 - 85 ] {
    assertThat(testResult(ShouldRejectTheoriesWithOnlyDisallowedNullData.class), not(isSuccessful()));
}
 [Lines 95 - 97 ] {
    log += string;
}
 [Lines 101 - 105 ] {
    DataPointArrays.log = "";
    JUnitCore.runClasses(DataPointArrays.class);
    assertThat(DataPointArrays.log, is("AB"));
}
 [Lines 112 - 114 ] {
    return new String[] { "A", "B" };
}
 [Lines 119 - 121 ] {
    log += string;
}
 [Lines 125 - 129 ] {
    DataPointArrayMethod.log = "";
    JUnitCore.runClasses(DataPointArrayMethod.class);
    assertThat(DataPointArrayMethod.log, is("AB"));
}
 [Lines 136 - 138 ] {
    return new String[] { "A", "B" };
}
 [Lines 143 - 145 ] {
    return "C";
}
 [Lines 148 - 150 ] {
    return new int[] { 1, 2, 3 };
}
 [Lines 153 - 155 ] {
    log += string;
}
 [Lines 159 - 163 ] {
    DataPointArrayMethod.log = "";
    JUnitCore.runClasses(DataPointArrayMethod.class);
    assertThat(DataPointArrayMethod.log, is("AB"));
}
 [Lines 173 - 175 ] {
    log += strings[0];
}
 [Lines 179 - 183 ] {
    DataPointArrayToBeUsedForWholeParameter.log = "";
    JUnitCore.runClasses(DataPointArrayToBeUsedForWholeParameter.class);
    assertThat(DataPointArrayToBeUsedForWholeParameter.log, is("A"));
}

/src/test/java/org/junit/tests/experimental/theories/runner/WhenNoParametersMatch.java
======================================================================================
 [Lines 34 - 36 ] {
    assumeThat(x, MATCHER);
}
 [Lines 41 - 50 ] {
    assumeThat(data, not(matcher));
    AssumptionsFail.DATA = data;
    AssumptionsFail.MATCHER = matcher;
    String result = testResult(AssumptionsFail.class).toString();
    assertThat(result, containsString(matcher.toString()));
    assertThat(result, containsString("" + data));
}

/src/test/java/org/junit/tests/experimental/theories/runner/WithUnresolvedGenericTypeVariablesOnTheoryParms.java
================================================================================================================
 [Lines 25 - 28 ] {
    PrintableResult result = testResult(TypeVariableOnTheoryOnly.class);
    assertThat(result, isSuccessful());
}
 [Lines 36 - 37 ] {
}
 [Lines 41 - 44 ] {
    PrintableResult result = testResult(TypeVariableOnTheoryParm.class);
    assertThat(result, hasSingleFailureContaining("unresolved type variable T"));
}
 [Lines 52 - 53 ] {
}
 [Lines 57 - 60 ] {
    PrintableResult result = testResult(TypeVariableOnParameterizedTheoryParm.class);
    assertThat(result, hasSingleFailureContaining("unresolved type variable T"));
}
 [Lines 68 - 69 ] {
}
 [Lines 73 - 76 ] {
    PrintableResult result = testResult(TypeVariableOnWildcardUpperBoundOnTheoryParm.class);
    assertThat(result, hasSingleFailureContaining("unresolved type variable U"));
}
 [Lines 84 - 85 ] {
}
 [Lines 89 - 92 ] {
    PrintableResult result = testResult(TypeVariableOnWildcardLowerBoundOnTheoryParm.class);
    assertThat(result, hasSingleFailureContaining("unresolved type variable V"));
}
 [Lines 100 - 101 ] {
}
 [Lines 105 - 108 ] {
    PrintableResult result = testResult(TypeVariableOnArrayTypeOnTheoryParm.class);
    assertThat(result, hasSingleFailureContaining("unresolved type variable T"));
}
 [Lines 113 - 115 ] {
    return new String[][] { new String[] { "foo" }, new String[] { "bar" } };
}
 [Lines 118 - 119 ] {
}
 [Lines 123 - 126 ] {
    PrintableResult result = testResult(TypeVariableOnComponentOfArrayTypeOnTheoryParm.class);
    assertThat(result, hasSingleFailureContaining("unresolved type variable U"));
}
 [Lines 131 - 136 ] {
    return new List<?>[][] { new List<?>[] { Arrays.asList("foo") }, new List<?>[] { Arrays.asList("bar") } };
}
 [Lines 139 - 140 ] {
}
 [Lines 144 - 147 ] {
    PrintableResult result = testResult(TypeVariableOnTheoryClass.class);
    assertThat(result, hasSingleFailureContaining("unresolved type variable T"));
}
 [Lines 155 - 156 ] {
}
 [Lines 160 - 170 ] {
    PrintableResult result = testResult(TypeVariablesAbound.class);
    assertThat(result, failureCountIs(7));
    assertThat(result, hasFailureContaining("unresolved type variable A"));
    assertThat(result, hasFailureContaining("unresolved type variable B"));
    assertThat(result, hasFailureContaining("unresolved type variable C"));
    assertThat(result, hasFailureContaining("unresolved type variable D"));
    assertThat(result, hasFailureContaining("unresolved type variable E"));
    assertThat(result, hasFailureContaining("unresolved type variable F"));
    assertThat(result, hasFailureContaining("unresolved type variable G"));
}
 [Lines 177 - 178 ] {
}

/src/test/java/org/junit/tests/experimental/theories/runner/SuccessfulWithDataPointFields.java
==============================================================================================
 [Lines 30 - 32 ] {
    assertThat(x, is(y));
}
 [Lines 43 - 45 ] {
    befores++;
}
 [Lines 48 - 50 ] {
    assertTrue(befores == 1);
}
 [Lines 64 - 67 ] {
    list.add(string);
    assertThat(list.size(), is(1));
}
 [Lines 77 - 80 ] {
    assumeTrue(x > 0);
    this.x = x;
}
 [Lines 83 - 85 ] {
    assertTrue(x * x > 0);
}
 [Lines 97 - 100 ] {
    assumeTrue(x > 0);
    this.x = x;
}
 [Lines 103 - 105 ] {
    assertTrue(x > 0);
}
 [Lines 115 - 118 ] {
    assumeTrue(x > 0);
    this.x = x;
}
 [Lines 121 - 124 ] {
    assumeTrue(y > 0);
    assertTrue(x * y > 0);
}
 [Lines 135 - 136 ] {
}
 [Lines 139 - 140 ] {
}
 [Lines 154 - 156 ] {
    befores++;
}
 [Lines 159 - 161 ] {
    befores = 0;
}
 [Lines 164 - 165 ] {
}
 [Lines 168 - 170 ] {
    assertEquals(2, befores);
}
 [Lines 181 - 183 ] {
    tests = 0;
}
 [Lines 187 - 189 ] {
    tests++;
}
 [Lines 192 - 194 ] {
    assertEquals(1, tests);
}
 [Lines 207 - 209 ] {
    assertTrue(i == 0);
}

/src/test/java/org/junit/tests/experimental/theories/runner/FailingDataPointMethods.java
========================================================================================
 [Lines 22 - 24 ] {
    throw new RuntimeException();
}
 [Lines 27 - 28 ] {
}
 [Lines 32 - 34 ] {
    assertThat(testResult(HasWronglyIgnoredFailingSingleDataPointMethod.class), not(isSuccessful()));
}
 [Lines 42 - 44 ] {
    throw new RuntimeException();
}
 [Lines 47 - 48 ] {
}
 [Lines 52 - 54 ] {
    assertThat(testResult(HasFailingDataPointArrayMethod.class), not(isSuccessful()));
}
 [Lines 62 - 64 ] {
    throw new RuntimeException();
}
 [Lines 67 - 68 ] {
}
 [Lines 72 - 74 ] {
    assertThat(testResult(HasIgnoredFailingSingleDataPointMethod.class), isSuccessful());
}
 [Lines 82 - 84 ] {
    throw new RuntimeException();
}
 [Lines 87 - 88 ] {
}
 [Lines 92 - 94 ] {
    assertThat(testResult(HasIgnoredFailingMultipleDataPointMethod.class), isSuccessful());
}
 [Lines 102 - 104 ] {
    throw new RuntimeException();
}
 [Lines 107 - 108 ] {
}
 [Lines 112 - 114 ] {
    assertThat(testResult(HasWronglyIgnoredFailingSingleDataPointMethod.class), not(isSuccessful()));
}
 [Lines 122 - 124 ] {
    throw new RuntimeException();
}
 [Lines 127 - 128 ] {
}
 [Lines 132 - 134 ] {
    assertThat(testResult(HasWronglyIgnoredFailingMultipleDataPointMethod.class), not(isSuccessful()));
}

/src/test/java/org/junit/tests/experimental/theories/runner/WithAutoGeneratedDataPoints.java
============================================================================================
 [Lines 17 - 18 ] {
}
 [Lines 20 - 21 ] {
}
 [Lines 26 - 29 ] {
    assertEquals(ENUM.values().length, potentialAssignments(TheoryTestClassWithAutogeneratedParameterValues.class.getMethod("theory", ENUM.class)).size());
}
 [Lines 32 - 35 ] {
    assertEquals(2, potentialAssignments(TheoryTestClassWithAutogeneratedParameterValues.class.getMethod("theory", boolean.class)).size());
}
 [Lines 43 - 44 ] {
}
 [Lines 49 - 52 ] {
    assertEquals(1, potentialAssignments(TheoryTestClassWithSpecificEnumDataPoint.class.getMethod("theory", ENUM.class)).size());
}
 [Lines 60 - 61 ] {
}
 [Lines 66 - 69 ] {
    assertEquals(1, potentialAssignments(TheoryTestClassWithSpecificBooleanDataPoint.class.getMethod("theory", boolean.class)).size());
}

/src/test/java/org/junit/tests/experimental/theories/runner/TypeMatchingBetweenMultiDataPointsMethod.java
=========================================================================================================
 [Lines 22 - 24 ] {
    return new String[] { "Hello", "World" };
}
 [Lines 27 - 28 ] {
}
 [Lines 32 - 34 ] {
    assertThat(testResult(WithWrongfullyTypedDataPointsMethod.class), isSuccessful());
}
 [Lines 42 - 46 ] {
    return new String[][] { { "Hello", "World" } };
}
 [Lines 49 - 50 ] {
}
 [Lines 54 - 56 ] {
    assertThat(testResult(WithCorrectlyTypedDataPointsMethod.class), isSuccessful());
}

/src/test/java/org/junit/tests/experimental/theories/runner/TheoriesPerformanceTest.java
========================================================================================
 [Lines 21 - 23 ] {
// pass always
}
 [Lines 34 - 37 ] {
    assumeTrue(TESTING_PERFORMANCE);
    assertThat(testResult(UpToTen.class), isSuccessful());
}

/src/test/java/org/junit/tests/experimental/theories/runner/WithNamedDataPoints.java
====================================================================================
 [Lines 37 - 39 ] {
    return new String[] { "expected method value" };
}
 [Lines 42 - 44 ] {
    return "expected single method string";
}
 [Lines 47 - 49 ] {
    return new String[] { "other method value" };
}
 [Lines 52 - 54 ] {
    return "other single value string";
}
 [Lines 57 - 58 ] {
}
 [Lines 63 - 71 ] {
    List<PotentialAssignment> assignments = potentialAssignments(HasSpecificDatapointsParameters.class.getMethod("theory", String.class));
    assertEquals(5, assignments.size());
    for (PotentialAssignment assignment : assignments) {
        assertThat((String) assignment.getValue(), containsString("expected"));
    }
}

/src/test/java/org/junit/tests/experimental/theories/internal/SpecificDataPointsSupplierTest.java
=================================================================================================
 [Lines 32 - 34 ] {
    return new String[] { "named method" };
}
 [Lines 43 - 45 ] {
    return "named single method value";
}
 [Lines 48 - 50 ] {
    return "other single method value";
}
 [Lines 53 - 55 ] {
    return new String[] { "other method" };
}
 [Lines 59 - 67 ] {
    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(TestClassWithNamedDataPoints.class));
    List<PotentialAssignment> assignments = supplier.getValueSources(signature("methodWantingAllNamedStrings"));
    List<String> assignedStrings = getStringValuesFromAssignments(assignments);
    assertEquals(4, assignedStrings.size());
    assertThat(assignedStrings, hasItems("named field", "named method", "named single value", "named single method value"));
}
 [Lines 70 - 78 ] {
    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(TestClassWithNamedDataPoints.class));
    List<PotentialAssignment> assignments = supplier.getValueSources(signature("methodWantingNamedFieldString"));
    List<String> assignedStrings = getStringValuesFromAssignments(assignments);
    assertEquals(1, assignedStrings.size());
    assertThat(assignedStrings, hasItem("named field"));
}
 [Lines 81 - 89 ] {
    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(TestClassWithNamedDataPoints.class));
    List<PotentialAssignment> assignments = supplier.getValueSources(signature("methodWantingNamedMethodString"));
    List<String> assignedStrings = getStringValuesFromAssignments(assignments);
    assertEquals(1, assignedStrings.size());
    assertThat(assignedStrings, hasItem("named method"));
}
 [Lines 92 - 100 ] {
    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(TestClassWithNamedDataPoints.class));
    List<PotentialAssignment> assignments = supplier.getValueSources(signature("methodWantingNamedSingleFieldString"));
    List<String> assignedStrings = getStringValuesFromAssignments(assignments);
    assertEquals(1, assignedStrings.size());
    assertThat(assignedStrings, hasItem("named single value"));
}
 [Lines 103 - 111 ] {
    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(TestClassWithNamedDataPoints.class));
    List<PotentialAssignment> assignments = supplier.getValueSources(signature("methodWantingNamedSingleMethodString"));
    List<String> assignedStrings = getStringValuesFromAssignments(assignments);
    assertEquals(1, assignedStrings.size());
    assertThat(assignedStrings, hasItem("named single method value"));
}
 [Lines 114 - 121 ] {
    SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier(new TestClass(TestClassWithNamedDataPoints.class));
    List<PotentialAssignment> assignments = supplier.getValueSources(signature("methodWantingWrongNamedString"));
    List<String> assignedStrings = getStringValuesFromAssignments(assignments);
    assertEquals(0, assignedStrings.size());
}
 [Lines 123 - 129 ] {
    List<String> stringValues = new ArrayList<String>();
    for (PotentialAssignment assignment : assignments) {
        stringValues.add((String) assignment.getValue());
    }
    return stringValues;
}
 [Lines 131 - 133 ] {
    return ParameterSignature.signatures(this.getClass().getMethod(methodName, String.class)).get(0);
}
 [Lines 135 - 136 ] {
}
 [Lines 138 - 139 ] {
}
 [Lines 141 - 142 ] {
}
 [Lines 144 - 145 ] {
}
 [Lines 147 - 148 ] {
}
 [Lines 150 - 151 ] {
}
 [Lines 153 - 154 ] {
}

/src/test/java/org/junit/tests/experimental/theories/internal/ParameterizedAssertionErrorTest.java
==================================================================================================
 [Lines 42 - 45 ] {
    assumeThat(a, is(b));
    assertThat(a.toString(), is(b.toString()));
}
 [Lines 49 - 52 ] {
    assumeThat(a, not(b));
    assertThat(a.toString(), not(b.toString()));
}
 [Lines 56 - 60 ] {
    assertThat(new ParameterizedAssertionError(targetException, methodName, params), is(new ParameterizedAssertionError(targetException, methodName, params)));
}
 [Lines 64 - 72 ] {
    ParameterizedAssertionError one = new ParameterizedAssertionError(targetException, methodName, params);
    ParameterizedAssertionError two = new ParameterizedAssertionError(targetException, methodName, params);
    assumeThat(one, is(two));
    assertThat(one.hashCode(), is(two.hashCode()));
}
 [Lines 75 - 79 ] {
    assertThat(new ParameterizedAssertionError(new RuntimeException(), methodName, param).toString(), containsString(methodName));
}
 [Lines 82 - 84 ] {
    assertFalse(a.equals(null));
}
 [Lines 87 - 94 ] {
    assertThat(ParameterizedAssertionError.join(" ", new Object() {

        @Override
        public String toString() {
            throw new UnsupportedOperationException();
        }
    }), is("[toString failed]"));
}

/src/test/java/org/junit/tests/experimental/theories/internal/AllMembersSupplierTest.java
=========================================================================================
 [Lines 32 - 33 ] {
}
 [Lines 37 - 42 ] {
    List<PotentialAssignment> assignments = potentialAssignments(HasDataPointsArrayField.class.getMethod("theory", String.class));
    assertEquals(2, assignments.size());
}
 [Lines 49 - 50 ] {
}
 [Lines 54 - 59 ] {
    List<PotentialAssignment> assignments = potentialAssignments(HasDataPointsArrayWithMatchingButInaccurateTypes.class.getMethod("theory", Integer.class));
    assertEquals(2, assignments.size());
}
 [Lines 63 - 65 ] {
    return 1;
}
 [Lines 68 - 69 ] {
}
 [Lines 73 - 78 ] {
    List<PotentialAssignment> assignments = potentialAssignments(HasDataPointMethodWithOverlyGeneralTypes.class.getMethod("theory", Object.class));
    assertEquals(1, assignments.size());
}
 [Lines 85 - 86 ] {
}
 [Lines 90 - 98 ] {
    List<PotentialAssignment> assignments = potentialAssignments(HasDataPointsWithObjectParameter.class.getMethod("theory", Object.class));
    assertEquals(2, assignments.size());
    for (PotentialAssignment assignment : assignments) {
        assertNotEquals(HasDataPointsWithObjectParameter.objectField, assignment.getValue());
    }
}
 [Lines 104 - 105 ] {
}
 [Lines 109 - 113 ] {
    List<PotentialAssignment> valueSources = allMemberValuesFor(HasDataPointsFieldWithNullValue.class, Object.class);
    assertThat(valueSources.size(), is(2));
}
 [Lines 117 - 119 ] {
    return new Integer[] { null, 1 };
}
 [Lines 121 - 122 ] {
}
 [Lines 126 - 130 ] {
    List<PotentialAssignment> valueSources = allMemberValuesFor(HasDataPointsMethodWithNullValue.class, Integer.class);
    assertThat(valueSources.size(), is(2));
}
 [Lines 134 - 136 ] {
    throw new RuntimeException("failing method");
}
 [Lines 138 - 139 ] {
}
 [Lines 143 - 147 ] {
    expected.expect(RuntimeException.class);
    expected.expectMessage("failing method");
    allMemberValuesFor(HasFailingDataPointsArrayMethod.class, Object.class);
}
 [Lines 150 - 155 ] {
    return new AllMembersSupplier(new TestClass(testClass)).getValueSources(ParameterSignature.signatures(testClass.getConstructor(constructorParameterTypes)).get(0));
}
 [Lines 162 - 163 ] {
}
 [Lines 167 - 172 ] {
    List<PotentialAssignment> assignments = potentialAssignments(HasDataPointsListField.class.getMethod("theory", String.class));
    assertEquals(2, assignments.size());
}
 [Lines 176 - 178 ] {
    return Arrays.asList("one", "two");
}
 [Lines 181 - 182 ] {
}
 [Lines 186 - 191 ] {
    List<PotentialAssignment> assignments = potentialAssignments(HasDataPointsListMethod.class.getMethod("theory", String.class));
    assertEquals(2, assignments.size());
}
 [Lines 198 - 199 ] {
}
 [Lines 203 - 208 ] {
    List<PotentialAssignment> assignments = potentialAssignments(HasDataPointsListFieldWithOverlyGenericTypes.class.getMethod("theory", String.class));
    assertEquals(1, assignments.size());
}

/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java
================================================================================
 [Lines 18 - 20 ] {
    Assume.assumeTrue(false);
}
 [Lines 23 - 26 ] {
    Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
    Assert.assertEquals(1, result.getFailureCount());
}
 [Lines 37 - 39 ] {
    Assume.assumeTrue(value);
}

/src/test/java/org/junit/tests/experimental/theories/TestedOnSupplierTest.java
==============================================================================
 [Lines 17 - 18 ] {
}
 [Lines 21 - 25 ] {
    TestedOnSupplier supplier = new TestedOnSupplier();
    List<PotentialAssignment> assignments = supplier.getValueSources(signatureOfFoo());
    assertThat(assignments.get(0).getDescription(), is("\"1\" <from ints>"));
}
 [Lines 27 - 30 ] {
    Method method = getClass().getMethod("foo", int.class);
    return ParameterSignature.signatures(method).get(0);
}

/src/test/java/org/junit/tests/experimental/theories/TheoryTestUtils.java
=========================================================================
 [Lines 18 - 18 ] {
}
 [Lines 21 - 25 ] {
    return Assignments.allUnassigned(method, new TestClass(method.getDeclaringClass())).potentialsForNextUnassigned();
}
 [Lines 27 - 31 ] {
    Runner theoryRunner = new Theories(testClass);
    Request request = Request.runner(theoryRunner);
    return new JUnitCore().run(request);
}

/src/test/java/org/junit/tests/experimental/max/DescriptionTest.java
====================================================================
 [Lines 20 - 22 ] {
    assertNull(Description.TEST_MECHANISM.getTestClass());
}
 [Lines 25 - 27 ] {
    assertNull(Description.TEST_MECHANISM.getMethodName());
}
 [Lines 30 - 32 ] {
    Description.createSuiteDescription("");
}
 [Lines 35 - 37 ] {
    Description.createSuiteDescription((String) null);
}
 [Lines 40 - 46 ] {
    Description description = Description.createTestDescription(Description.class, "aTestMethod");
    assertThat(description.getClassName(), equalTo("org.junit.runner.Description"));
    assertThat(description.getMethodName(), equalTo("aTestMethod"));
    assertThat(description.getAnnotations().size(), equalTo(0));
}
 [Lines 49 - 58 ] {
    Annotation[] annotations = DescriptionTest.class.getMethod("parseClassAndMethodWithAnnotations").getDeclaredAnnotations();
    Description description = Description.createTestDescription(Description.class, "aTestMethod", annotations);
    assertThat(description.getClassName(), equalTo("org.junit.runner.Description"));
    assertThat(description.getMethodName(), equalTo("aTestMethod"));
    assertThat(description.getAnnotations().size(), equalTo(1));
}
 [Lines 61 - 67 ] {
    Description description = Description.createTestDescription("not a class name", "aTestMethod", 123);
    assertThat(description.getClassName(), equalTo("not a class name"));
    assertThat(description.getMethodName(), equalTo("aTestMethod"));
    assertThat(description.getAnnotations().size(), equalTo(0));
}
 [Lines 70 - 73 ] {
    assertThat(Description.createTestDescription("not a class name", "aTestMethod", 1), not(equalTo(Description.createTestDescription("not a class name", "aTestMethod", 2))));
}
 [Lines 76 - 114 ] {
    class URLClassLoader2 extends URLClassLoader {

        URLClassLoader2(URL... urls) {
            super(urls);
        }

        // just making public
        @Override
        public Class<?> findClass(String name) throws ClassNotFoundException {
            return super.findClass(name);
        }
    }
    URL classpath = Sweet.class.getProtectionDomain().getCodeSource().getLocation();
    URLClassLoader2 loader = new URLClassLoader2(classpath);
    Class<?> clazz = loader.findClass(Sweet.class.getName());
    assertEquals(loader, clazz.getClassLoader());
    Description d = Description.createSuiteDescription(clazz);
    assertEquals(clazz, d.getTestClass());
    assertNull(d.getMethodName());
    assertEquals(1, d.getAnnotations().size());
    assertEquals(Ignore.class, d.getAnnotations().iterator().next().annotationType());
    d = Description.createTestDescription(clazz, "tessed");
    assertEquals(clazz, d.getTestClass());
    assertEquals("tessed", d.getMethodName());
    assertEquals(0, d.getAnnotations().size());
    d = Description.createTestDescription(clazz, "tessed", clazz.getMethod("tessed").getAnnotations());
    assertEquals(clazz, d.getTestClass());
    assertEquals("tessed", d.getMethodName());
    assertEquals(1, d.getAnnotations().size());
    assertEquals(Test.class, d.getAnnotations().iterator().next().annotationType());
    d = d.childlessCopy();
    assertEquals(clazz, d.getTestClass());
    assertEquals("tessed", d.getMethodName());
    assertEquals(1, d.getAnnotations().size());
    assertEquals(Test.class, d.getAnnotations().iterator().next().annotationType());
}
 [Lines 119 - 120 ] {
}

/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java
=======================================================================
 [Lines 21 - 27 ] {
    fMaxFile = new File("MaxCore.ser");
    if (fMaxFile.exists()) {
        fMaxFile.delete();
    }
    fMax = MaxCore.storedLocally(fMaxFile);
}
 [Lines 30 - 32 ] {
    fMaxFile.delete();
}
 [Lines 36 - 37 ] {
}
 [Lines 41 - 43 ] {
    fail();
}
 [Lines 45 - 46 ] {
}
 [Lines 48 - 49 ] {
}
 [Lines 53 - 60 ] {
    Request request = Request.classes(JUnit4Test.class, JUnit38Test.class);
    fMax.run(request);
    List<Description> tests = fMax.sortedLeavesForTest(request);
    Description dontSucceed = Description.createTestDescription(JUnit38Test.class, "testFails");
    assertEquals(dontSucceed, tests.get(0));
}

/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java
===================================================================
 [Lines 37 - 43 ] {
    fMaxFile = new File("MaxCore.ser");
    if (fMaxFile.exists()) {
        fMaxFile.delete();
    }
    fMax = MaxCore.storedLocally(fMaxFile);
}
 [Lines 46 - 48 ] {
    fMaxFile.delete();
}
 [Lines 52 - 53 ] {
}
 [Lines 56 - 58 ] {
    fail();
}
 [Lines 62 - 72 ] {
    Request request = Request.aClass(TwoTests.class);
    List<Description> things = fMax.sortedLeavesForTest(request);
    Description succeed = Description.createTestDescription(TwoTests.class, "succeed");
    Description dontSucceed = Description.createTestDescription(TwoTests.class, "dontSucceed");
    assertTrue(things.contains(succeed));
    assertTrue(things.contains(dontSucceed));
    assertEquals(2, things.size());
}
 [Lines 75 - 84 ] {
    Request one = Request.method(TwoTests.class, "succeed");
    fMax.run(one);
    Request two = Request.aClass(TwoTests.class);
    List<Description> things = fMax.sortedLeavesForTest(two);
    Description dontSucceed = Description.createTestDescription(TwoTests.class, "dontSucceed");
    assertEquals(dontSucceed, things.get(0));
    assertEquals(2, things.size());
}
 [Lines 92 - 101 ] {
    Request one = Request.method(TwoTests.class, "dontSucceed");
    fMax.run(one);
    Request two = Request.aClass(TwoTests.class);
    List<Description> things = fMax.sortedLeavesForTest(two);
    Description succeed = Description.createTestDescription(TwoTests.class, "succeed");
    assertEquals(succeed, things.get(0));
    assertEquals(2, things.size());
}
 [Lines 104 - 111 ] {
    Request request = Request.aClass(TwoTests.class);
    fMax.run(request);
    List<Description> tests = fMax.sortedLeavesForTest(request);
    Description dontSucceed = Description.createTestDescription(TwoTests.class, "dontSucceed");
    assertEquals(dontSucceed, tests.get(0));
}
 [Lines 114 - 123 ] {
    Request request = Request.classes(Computer.serial(), TwoTests.class, TwoTests.class);
    fMax.run(request);
    List<Description> tests = fMax.sortedLeavesForTest(request);
    Description dontSucceed = Description.createTestDescription(TwoTests.class, "dontSucceed");
    assertEquals(dontSucceed, tests.get(0));
    assertEquals(dontSucceed, tests.get(1));
}
 [Lines 127 - 130 ] {
    Thread.sleep(100);
    fail();
}
 [Lines 133 - 135 ] {
    fail();
}
 [Lines 140 - 148 ] {
    fMax.run(TwoUnEqualTests.class);
    MaxCore reincarnation = MaxCore.storedLocally(fMaxFile);
    List<Failure> failures = reincarnation.run(TwoUnEqualTests.class).getFailures();
    assertEquals("fast", failures.get(0).getDescription().getMethodName());
    assertEquals("slow", failures.get(1).getDescription().getMethodName());
}
 [Lines 151 - 157 ] {
    Request request = Request.aClass(TwoUnEqualTests.class);
    fMax.run(request);
    Description thing = fMax.sortedLeavesForTest(request).get(1);
    assertEquals(Description.createTestDescription(TwoUnEqualTests.class, "slow"), thing);
}
 [Lines 161 - 172 ] {
    JUnitCore core = new JUnitCore();
    final List<Failure> failures = new ArrayList<Failure>();
    core.addListener(new RunListener() {

        @Override
        public void testRunFinished(Result result) throws Exception {
            failures.addAll(result.getFailures());
        }
    });
    fMax.run(Request.aClass(TwoTests.class), core);
    assertEquals(1, failures.size());
}
 [Lines 176 - 179 ] {
    Result result = fMax.run(Request.aClass(TwoTests.class));
    assertEquals(2, result.getRunCount());
}
 [Lines 182 - 183 ] {
}
 [Lines 185 - 186 ] {
}
 [Lines 190 - 194 ] {
    Result result = fMax.run(Request.aClass(TwoOldTests.class), new JUnitCore());
    assertEquals(2, result.getRunCount());
}
 [Lines 197 - 204 ] {
    final Description method = Description.createTestDescription(TwoOldTests.class, "testOne");
    Filter filter = Filter.matchMethodDescription(method);
    JUnit38ClassRunner child = new JUnit38ClassRunner(TwoOldTests.class);
    child.filter(filter);
    assertEquals(1, child.testCount());
}
 [Lines 207 - 209 ] {
    assertFilterLeavesTestUnscathed(AllTests.class);
}
 [Lines 211 - 228 ] {
    Request oneClass = Request.aClass(testClass);
    Request filtered = oneClass.filterWith(new Filter() {

        @Override
        public boolean shouldRun(Description description) {
            return true;
        }

        @Override
        public String describe() {
            return "Everything";
        }
    });
    int filterCount = filtered.getRunner().testCount();
    int coreCount = oneClass.getRunner().testCount();
    assertEquals("Counts match up in " + testClass, coreCount, filterCount);
}
 [Lines 231 - 232 ] {
}
 [Lines 235 - 236 ] {
}
 [Lines 240 - 243 ] {
    Request request = Request.aClass(MalformedJUnit38Test.class);
    fMax.run(request);
}
 [Lines 247 - 248 ] {
}
 [Lines 254 - 264 ] {
    Request request = Request.aClass(MalformedJUnit38TestMethod.class);
    JUnitCore core = new JUnitCore();
    Request sorted = fMax.sortRequest(request);
    Runner runner = sorted.getRunner();
    Result result = core.run(runner);
    Failure failure = result.getFailures().get(0);
    assertThat(failure.toString(), containsString("MalformedJUnit38TestMethod"));
    assertThat(failure.toString(), containsString("testNothing"));
    assertThat(failure.toString(), containsString("isn't public"));
}
 [Lines 267 - 268 ] {
}
 [Lines 271 - 272 ] {
}
 [Lines 276 - 279 ] {
    assertThat(JUnitCore.runClasses(HalfMalformedJUnit38TestMethod.class).getFailureCount(), is(1));
}
 [Lines 283 - 293 ] {
    Request request = Request.aClass(HalfMalformedJUnit38TestMethod.class);
    JUnitCore core = new JUnitCore();
    Request sorted = fMax.sortRequest(request);
    Runner runner = sorted.getRunner();
    Result result = core.run(runner);
    Failure failure = result.getFailures().get(0);
    assertThat(failure.toString(), containsString("MalformedJUnit38TestMethod"));
    assertThat(failure.toString(), containsString("testNothing"));
    assertThat(failure.toString(), containsString("isn't public"));
}

/src/test/java/org/junit/tests/experimental/results/ResultMatchersTest.java
===========================================================================
 [Lines 13 - 16 ] {
    assertThat(ResultMatchers.failureCountIs(3).toString(), is("has 3 failures"));
}
 [Lines 19 - 22 ] {
    assertThat(ResultMatchers.failureCountIs(i).toString(), containsString("" + i));
}

/src/test/java/org/junit/tests/experimental/results/PrintableResultTest.java
============================================================================
 [Lines 22 - 36 ] {
    Failure failure = new Failure(Description.createSuiteDescription(descriptionName), new Throwable() {

        private static final long serialVersionUID = 1L;

        @Override
        public StackTraceElement[] getStackTrace() {
            return new StackTraceElement[] { new StackTraceElement(stackTraceClassName, "methodName", "fileName", 1) };
        }
    });
    assertThat(new PrintableResult(asList(failure)).toString(), allOf(containsString(descriptionName), containsString(stackTraceClassName)));
}
 [Lines 42 - 49 ] {
    PrintableResult backtrace = new PrintableResult(Arrays.asList(new Failure(Description.createSuiteDescription("firstName"), new RuntimeException("firstException")), new Failure(Description.createSuiteDescription("secondName"), new RuntimeException(secondExceptionName))));
    assertThat(backtrace.toString(), containsString(secondExceptionName));
}

/src/test/java/org/junit/tests/experimental/MatcherTest.java
============================================================
 [Lines 35 - 39 ] {
    assumeThat(value, matcher1);
    assumeThat(value, not(matcher2));
    assertThat(matcher1.toString(), not(matcher2.toString()));
}
 [Lines 41 - 43 ] {
    return new Failure(Description.EMPTY, new Error(string));
}

/src/test/java/org/junit/tests/experimental/rules/ExternalResourceRuleTest.java
===============================================================================
 [Lines 19 - 21 ] {
    callSequence += "before ";
}
 [Lines 26 - 28 ] {
    callSequence += "after ";
}
 [Lines 34 - 36 ] {
    callSequence += "test ";
}
 [Lines 40 - 44 ] {
    callSequence = "";
    assertThat(testResult(UsesExternalResource.class), isSuccessful());
    assertEquals("before test after ", callSequence);
}

/src/test/java/org/junit/tests/experimental/rules/ClassRulesTest.java
=====================================================================
 [Lines 32 - 34 ] {
    count++;
}
 [Lines 42 - 44 ] {
    assertEquals(1, counter.count);
}
 [Lines 47 - 49 ] {
    assertEquals(1, counter.count);
}
 [Lines 53 - 57 ] {
    ExampleTestWithClassRule.counter.count = 0;
    JUnitCore.runClasses(ExampleTestWithClassRule.class);
    assertEquals(1, ExampleTestWithClassRule.counter.count);
}
 [Lines 65 - 69 ] {
    ExampleTestWithClassRule.counter.count = 0;
    JUnitCore.runClasses(SubclassOfTestWithClassRule.class);
    assertEquals(1, ExampleTestWithClassRule.counter.count);
}
 [Lines 74 - 82 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            count++;
            base.evaluate();
        }
    };
}
 [Lines 90 - 92 ] {
    assertEquals(1, counter.count);
}
 [Lines 95 - 97 ] {
    assertEquals(1, counter.count);
}
 [Lines 102 - 107 ] {
    ExampleTestWithCustomClassRule.counter.count = 0;
    Result result = JUnitCore.runClasses(ExampleTestWithCustomClassRule.class);
    assertTrue(result.wasSuccessful());
    assertEquals(1, ExampleTestWithCustomClassRule.counter.count);
}
 [Lines 114 - 116 ] {
    this.name = name;
}
 [Lines 118 - 126 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            orderList.add(name);
            base.evaluate();
        }
    };
}
 [Lines 133 - 135 ] {
    return new OrderTestRule("orderMethod");
}
 [Lines 141 - 144 ] {
    assertEquals("orderField", orderList.get(0));
    assertEquals("orderMethod", orderList.get(1));
}
 [Lines 148 - 151 ] {
    orderList.clear();
    assertThat(testResult(UsesFieldAndMethodRule.class), isSuccessful());
}
 [Lines 158 - 160 ] {
    return counter;
}
 [Lines 163 - 165 ] {
    assertEquals(1, counter.count);
}
 [Lines 168 - 170 ] {
    assertEquals(1, counter.count);
}
 [Lines 174 - 178 ] {
    MethodExampleTestWithClassRule.counter.count = 0;
    JUnitCore.runClasses(MethodExampleTestWithClassRule.class);
    assertEquals(1, MethodExampleTestWithClassRule.counter.count);
}
 [Lines 186 - 190 ] {
    MethodExampleTestWithClassRule.counter.count = 0;
    JUnitCore.runClasses(MethodSubclassOfTestWithClassRule.class);
    assertEquals(1, MethodExampleTestWithClassRule.counter.count);
}
 [Lines 196 - 198 ] {
    return counter;
}
 [Lines 201 - 203 ] {
    assertEquals(1, counter.count);
}
 [Lines 206 - 208 ] {
    assertEquals(1, counter.count);
}
 [Lines 213 - 218 ] {
    MethodExampleTestWithCustomClassRule.counter.count = 0;
    Result result = JUnitCore.runClasses(MethodExampleTestWithCustomClassRule.class);
    assertTrue(result.wasSuccessful());
    assertEquals(1, MethodExampleTestWithCustomClassRule.counter.count);
}
 [Lines 224 - 233 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            base.evaluate();
        }

        ;
    };
}
 [Lines 237 - 240 ] {
    countOfMethodCalls++;
    return new Dummy();
}
 [Lines 243 - 245 ] {
    assertEquals(1, countOfMethodCalls);
}
 [Lines 249 - 252 ] {
    CallMethodOnlyOnceRule.countOfMethodCalls = 0;
    assertTrue(JUnitCore.runClasses(CallMethodOnlyOnceRule.class).wasSuccessful());
}

/src/test/java/org/junit/tests/experimental/rules/TestWatcherTest.java
======================================================================
 [Lines 27 - 29 ] {
    assumeTrue(false);
}
 [Lines 33 - 38 ] {
    ViolatedAssumptionTest.watchedLog = new StringBuilder();
    runClasses(ViolatedAssumptionTest.class);
    assertThat(ViolatedAssumptionTest.watchedLog.toString(), is("starting skipped finished "));
}
 [Lines 46 - 48 ] {
    watchedLog.append("starting ");
}
 [Lines 51 - 53 ] {
    watchedLog.append("finished ");
}
 [Lines 56 - 58 ] {
    watchedLog.append("skipped ");
}
 [Lines 63 - 65 ] {
    throw new AssumptionViolatedException("don't run");
}
 [Lines 69 - 74 ] {
    InternalViolatedAssumptionTest.watchedLog = new StringBuilder();
    runClasses(InternalViolatedAssumptionTest.class);
    assertThat(InternalViolatedAssumptionTest.watchedLog.toString(), is("starting skipped finished "));
}
 [Lines 80 - 82 ] {
    throw new RuntimeException("watcher failure");
}
 [Lines 87 - 89 ] {
    throw new AssumptionViolatedException("test failure");
}
 [Lines 93 - 98 ] {
    PrintableResult result = testResult(TestWatcherSkippedThrowsExceptionTest.class);
    assertThat(result, failureCountIs(2));
    assertThat(result, hasFailureContaining("test failure"));
    assertThat(result, hasFailureContaining("watcher failure"));
}
 [Lines 107 - 109 ] {
    fail();
}
 [Lines 113 - 118 ] {
    FailingTest.watchedLog = new StringBuilder();
    runClasses(FailingTest.class);
    assertThat(FailingTest.watchedLog.toString(), is("starting failed finished "));
}
 [Lines 124 - 126 ] {
    throw new RuntimeException("watcher failure");
}
 [Lines 130 - 132 ] {
    throw new IllegalArgumentException("test failure");
}
 [Lines 136 - 141 ] {
    PrintableResult result = testResult(TestWatcherFailedThrowsExceptionTest.class);
    assertThat(result, failureCountIs(2));
    assertThat(result, hasFailureContaining("test failure"));
    assertThat(result, hasFailureContaining("watcher failure"));
}
 [Lines 147 - 149 ] {
    throw new RuntimeException("watcher failure");
}
 [Lines 153 - 155 ] {
    throw new IllegalArgumentException("test failure");
}
 [Lines 159 - 164 ] {
    PrintableResult result = testResult(TestWatcherStartingThrowsExceptionTest.class);
    assertThat(result, failureCountIs(2));
    assertThat(result, hasFailureContaining("test failure"));
    assertThat(result, hasFailureContaining("watcher failure"));
}
 [Lines 170 - 172 ] {
    throw new RuntimeException("watcher failed failure");
}
 [Lines 175 - 177 ] {
    throw new RuntimeException("watcher finished failure");
}
 [Lines 181 - 183 ] {
    throw new IllegalArgumentException("test failure");
}
 [Lines 187 - 193 ] {
    PrintableResult result = testResult(TestWatcherFailedAndFinishedThrowsExceptionTest.class);
    assertThat(result, failureCountIs(3));
    assertThat(result, hasFailureContaining("test failure"));
    assertThat(result, hasFailureContaining("watcher failed failure"));
    assertThat(result, hasFailureContaining("watcher finished failure"));
}

/src/test/java/org/junit/tests/experimental/rules/TimeoutRuleTest.java
======================================================================
 [Lines 40 - 44 ] {
    logger.append("run1");
    TimeoutRuleTest.run1Lock.lockInterruptibly();
    TimeoutRuleTest.run1Lock.unlock();
}
 [Lines 47 - 50 ] {
    logger.append("run2");
    Thread.currentThread().join();
}
 [Lines 53 - 56 ] {
    logger.append("run3");
    wait();
}
 [Lines 59 - 63 ] {
    logger.append("run4");
    while (!run4done) {
    }
}
 [Lines 66 - 84 ] {
    logger.append("run5");
    Random rnd = new Random();
    byte[] data = new byte[1024];
    File tmp = tmpFile.newFile();
    while (true) {
        RandomAccessFile randomAccessFile = new RandomAccessFile(tmp, "rw");
        try {
            FileChannel channel = randomAccessFile.getChannel();
            rnd.nextBytes(data);
            ByteBuffer buffer = ByteBuffer.wrap(data);
            // Interrupted thread closes channel and throws ClosedByInterruptException.
            channel.write(buffer);
        } finally {
            randomAccessFile.close();
        }
        tmp.delete();
    }
}
 [Lines 87 - 91 ] {
    logger.append("run6");
    // Java IO throws InterruptedIOException only on SUN machines.
    throw new InterruptedIOException();
}
 [Lines 112 - 113 ] {
}
 [Lines 117 - 120 ] {
    run4done = false;
    run1Lock.lock();
}
 [Lines 123 - 127 ] {
    // set run4done to make sure that the thread won't continue at run4()
    run4done = true;
    run1Lock.unlock();
}
 [Lines 130 - 140 ] {
    HasGlobalTimeUnitTimeout.logger.setLength(0);
    Result result = JUnitCore.runClasses(HasGlobalTimeUnitTimeout.class);
    assertEquals(6, result.getFailureCount());
    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString("run1"));
    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString("run2"));
    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString("run3"));
    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString("run4"));
    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString("run5"));
    assertThat(HasGlobalTimeUnitTimeout.logger.toString(), containsString("run6"));
}
 [Lines 143 - 153 ] {
    HasGlobalLongTimeout.logger.setLength(0);
    Result result = JUnitCore.runClasses(HasGlobalLongTimeout.class);
    assertEquals(6, result.getFailureCount());
    assertThat(HasGlobalLongTimeout.logger.toString(), containsString("run1"));
    assertThat(HasGlobalLongTimeout.logger.toString(), containsString("run2"));
    assertThat(HasGlobalLongTimeout.logger.toString(), containsString("run3"));
    assertThat(HasGlobalLongTimeout.logger.toString(), containsString("run4"));
    assertThat(HasGlobalLongTimeout.logger.toString(), containsString("run5"));
    assertThat(HasGlobalLongTimeout.logger.toString(), containsString("run6"));
}
 [Lines 156 - 164 ] {
    Result result = JUnitCore.runClasses(HasNullTimeUnit.class);
    assertEquals(1, result.getFailureCount());
    Failure failure = result.getFailures().get(0);
    assertThat(failure.getException().getMessage(), containsString("Invalid parameters for Timeout"));
    Throwable cause = failure.getException().getCause();
    assertThat(cause.getMessage(), containsString("TimeUnit cannot be null"));
}

/src/test/java/org/junit/tests/experimental/rules/RuleMemberValidatorTest.java
==============================================================================
 [Lines 26 - 30 ] {
    TestClass target = new TestClass(TestWithProtectedClassRule.class);
    CLASS_RULE_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'temporaryFolder' must be public.");
}
 [Lines 38 - 42 ] {
    TestClass target = new TestClass(TestWithNonStaticClassRule.class);
    CLASS_RULE_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'temporaryFolder' must be static.");
}
 [Lines 50 - 54 ] {
    TestClass target = new TestClass(TestWithStaticClassAndTestRule.class);
    CLASS_RULE_VALIDATOR.validate(target, errors);
    assertNumberOfErrors(0);
}
 [Lines 63 - 67 ] {
    TestClass target = new TestClass(NonPublicTestWithClassRule.class);
    CLASS_RULE_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'temporaryFolder' must be declared in a public class.");
}
 [Lines 82 - 86 ] {
    TestClass target = new TestClass(TestWithClassRuleIsImplementationOfMethodRule.class);
    CLASS_RULE_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'classRule' must implement TestRule.");
}
 [Lines 92 - 94 ] {
    return base;
}
 [Lines 106 - 110 ] {
    TestClass target = new TestClass(TestWithClassRuleMethodThatReturnsMethodRule.class);
    CLASS_RULE_METHOD_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'methodRule' must return an implementation of TestRule.");
}
 [Lines 114 - 121 ] {
    return new MethodRule() {

        public Statement apply(Statement base, FrameworkMethod method, Object target) {
            return base;
        }
    };
}
 [Lines 132 - 136 ] {
    TestClass target = new TestClass(TestWithClassRuleIsAnArbitraryObject.class);
    CLASS_RULE_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'arbitraryObject' must implement TestRule.");
}
 [Lines 151 - 155 ] {
    TestClass target = new TestClass(TestWithClassRuleMethodReturnsAnArbitraryObject.class);
    CLASS_RULE_METHOD_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'arbitraryObject' must return an implementation of TestRule.");
}
 [Lines 159 - 161 ] {
    return 1;
}
 [Lines 165 - 169 ] {
    TestClass target = new TestClass(TestWithNonStaticTestRule.class);
    RULE_VALIDATOR.validate(target, errors);
    assertNumberOfErrors(0);
}
 [Lines 177 - 181 ] {
    TestClass target = new TestClass(TestWithStaticTestRule.class);
    RULE_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @Rule 'temporaryFolder' must not be static or it must be annotated with @ClassRule.");
}
 [Lines 189 - 193 ] {
    TestClass target = new TestClass(TestWithStaticMethodRule.class);
    RULE_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @Rule 'someMethodRule' must not be static.");
}
 [Lines 201 - 205 ] {
    TestClass target = new TestClass(TestWithMethodRule.class);
    RULE_VALIDATOR.validate(target, errors);
    assertNumberOfErrors(0);
}
 [Lines 211 - 213 ] {
    return null;
}
 [Lines 218 - 222 ] {
    TestClass target = new TestClass(TestWithArbitraryObjectWithRuleAnnotation.class);
    RULE_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @Rule 'arbitraryObject' must implement MethodRule or TestRule.");
}
 [Lines 230 - 234 ] {
    TestClass target = new TestClass(MethodTestWithProtectedClassRule.class);
    CLASS_RULE_METHOD_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'getTemporaryFolder' must be public.");
}
 [Lines 238 - 240 ] {
    return new TemporaryFolder();
}
 [Lines 244 - 248 ] {
    TestClass target = new TestClass(MethodTestWithNonStaticClassRule.class);
    CLASS_RULE_METHOD_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @ClassRule 'getTemporaryFolder' must be static.");
}
 [Lines 252 - 254 ] {
    return new TemporaryFolder();
}
 [Lines 258 - 262 ] {
    TestClass target = new TestClass(MethodTestWithStaticClassAndTestRule.class);
    CLASS_RULE_METHOD_VALIDATOR.validate(target, errors);
    assertNumberOfErrors(0);
}
 [Lines 267 - 269 ] {
    return new TemporaryFolder();
}
 [Lines 273 - 277 ] {
    TestClass target = new TestClass(TestMethodWithNonStaticTestRule.class);
    RULE_METHOD_VALIDATOR.validate(target, errors);
    assertNumberOfErrors(0);
}
 [Lines 281 - 283 ] {
    return new TemporaryFolder();
}
 [Lines 287 - 291 ] {
    TestClass target = new TestClass(TestMethodWithStaticTestRule.class);
    RULE_METHOD_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @Rule 'getTemporaryFolder' must not be static or it must be annotated with @ClassRule.");
}
 [Lines 295 - 297 ] {
    return new TemporaryFolder();
}
 [Lines 301 - 305 ] {
    TestClass target = new TestClass(TestMethodWithStaticMethodRule.class);
    RULE_METHOD_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @Rule 'getSomeMethodRule' must not be static.");
}
 [Lines 309 - 309 ] {
    return new SomeMethodRule();
}
 [Lines 313 - 317 ] {
    TestClass target = new TestClass(MethodTestWithMethodRule.class);
    RULE_METHOD_VALIDATOR.validate(target, errors);
    assertNumberOfErrors(0);
}
 [Lines 321 - 328 ] {
    return new MethodRule() {

        public Statement apply(Statement base, FrameworkMethod method, Object target) {
            return null;
        }
    };
}
 [Lines 332 - 336 ] {
    TestClass target = new TestClass(MethodTestWithArbitraryObjectWithRuleAnnotation.class);
    RULE_METHOD_VALIDATOR.validate(target, errors);
    assertOneErrorWithMessage("The @Rule 'getArbitraryObject' must return an implementation of MethodRule or TestRule.");
}
 [Lines 340 - 342 ] {
    return 1;
}
 [Lines 345 - 348 ] {
    assertNumberOfErrors(1);
    assertEquals("Wrong error message:", message, errors.get(0).getMessage());
}
 [Lines 350 - 352 ] {
    assertEquals("Wrong number of errors:", numberOfErrors, errors.size());
}
 [Lines 355 - 357 ] {
    return base;
}

/src/test/java/org/junit/tests/experimental/rules/TempFolderRuleTest.java
=========================================================================
 [Lines 30 - 33 ] {
    createdFiles[0] = folder.newFile("myfile.txt");
    assertTrue(createdFiles[0].exists());
}
 [Lines 37 - 40 ] {
    assertThat(testResult(HasTempFolder.class), isSuccessful());
    assertFalse(createdFiles[0].exists());
}
 [Lines 47 - 59 ] {
    String subfolder = "subfolder";
    String filename = "a.txt";
    // force usage of folder.newFolder(String),
    // check is available and works, to avoid a potential NoSuchMethodError with non-recompiled code.
    Method method = folder.getClass().getMethod("newFolder", new Class<?>[] { String.class });
    createdFiles[0] = (File) method.invoke(folder, subfolder);
    new File(createdFiles[0], filename).createNewFile();
    File expectedFile = new File(folder.getRoot(), join(subfolder, filename));
    assertTrue(expectedFile.exists());
}
 [Lines 62 - 72 ] {
    String subfolder = "subfolder";
    String filename = "a.txt";
    // this uses newFolder(String), ensure that a single String works
    createdFiles[0] = folder.newFolder(subfolder);
    new File(createdFiles[0], filename).createNewFile();
    File expectedFile = new File(folder.getRoot(), join(subfolder, filename));
    assertTrue(expectedFile.exists());
}
 [Lines 75 - 86 ] {
    String subfolder = "subfolder";
    String anotherfolder = "anotherfolder";
    String filename = "a.txt";
    createdFiles[0] = folder.newFolder(subfolder, anotherfolder);
    new File(createdFiles[0], filename).createNewFile();
    File expectedFile = new File(folder.getRoot(), join(subfolder, anotherfolder, filename));
    assertTrue(expectedFile.exists());
}
 [Lines 88 - 94 ] {
    StringBuilder path = new StringBuilder();
    for (String folderName : folderNames) {
        path.append(File.separator).append(folderName);
    }
    return path.toString();
}
 [Lines 98 - 101 ] {
    assertThat(testResult(CreatesSubFolder.class), isSuccessful());
    assertFalse(createdFiles[0].exists());
}
 [Lines 108 - 116 ] {
    for (int i = 0; i < 20; i++) {
        File newFolder = folder.newFolder();
        assertThat(Arrays.asList(createdFiles), not(hasItem(newFolder)));
        createdFiles[i] = newFolder;
        new File(newFolder, "a.txt").createNewFile();
        assertTrue(newFolder.exists());
    }
}
 [Lines 120 - 125 ] {
    assertThat(testResult(CreatesRandomSubFolders.class), isSuccessful());
    for (File f : createdFiles) {
        assertFalse(f.exists());
    }
}
 [Lines 132 - 139 ] {
    for (int i = 0; i < 20; i++) {
        File newFile = folder.newFile();
        assertThat(Arrays.asList(createdFiles), not(hasItem(newFile)));
        createdFiles[i] = newFile;
        assertTrue(newFile.exists());
    }
}
 [Lines 143 - 148 ] {
    assertThat(testResult(CreatesRandomFiles.class), isSuccessful());
    for (File f : createdFiles) {
        assertFalse(f.exists());
    }
}
 [Lines 151 - 158 ] {
    TemporaryFolder folder = new TemporaryFolder();
    folder.create();
    File file = folder.newFile("a");
    folder.delete();
    assertFalse(file.exists());
    assertFalse(folder.getRoot().exists());
}
 [Lines 161 - 168 ] {
    TemporaryFolder folder = new TemporaryFolder();
    folder.create();
    File file = folder.newFile();
    folder.delete();
    assertFalse(file.exists());
    assertFalse(folder.getRoot().exists());
}
 [Lines 171 - 176 ] {
    TemporaryFolder folder = new TemporaryFolder();
    folder.create();
    folder.delete();
    assertFalse(folder.getRoot().exists());
}
 [Lines 183 - 186 ] {
    folder.newFile("something.txt");
    folder.newFile("something.txt");
}
 [Lines 189 - 192 ] {
    folder.newFolder("dummy");
    folder.newFile("dummy");
}
 [Lines 196 - 198 ] {
    assertThat(testResult(NameClashes.class), failureCountIs(2));
}
 [Lines 210 - 212 ] {
    new File(folder.getRoot(), GET_ROOT_DUMMY).createNewFile();
}
 [Lines 215 - 217 ] {
    folder.newFile(NEW_FILE_DUMMY);
}
 [Lines 220 - 222 ] {
    folder.newFolder(NEW_FOLDER_DUMMY);
}
 [Lines 226 - 231 ] {
    assertThat(testResult(IncorrectUsage.class), failureCountIs(3));
    assertFalse("getRoot should have failed early", new File(GET_ROOT_DUMMY).exists());
    assertFalse("newFile should have failed early", new File(NEW_FILE_DUMMY).exists());
    assertFalse("newFolder should have failed early", new File(NEW_FOLDER_DUMMY).exists());
}
 [Lines 234 - 238 ] {
    new File(GET_ROOT_DUMMY).delete();
    new File(NEW_FILE_DUMMY).delete();
    new File(NEW_FOLDER_DUMMY).delete();
}

/src/test/java/org/junit/tests/experimental/rules/EventCollector.java
=====================================================================
 [Lines 17 - 19 ] {
    return allOf(hasNoFailure(), hasNoAssumptionFailure());
}
 [Lines 22 - 42 ] {
    return new TypeSafeMatcher<EventCollector>() {

        @Override
        public boolean matchesSafely(EventCollector item) {
            return item.fFailures.size() == numberOfFailures;
        }

        public void describeTo(org.hamcrest.Description description) {
            description.appendText("has ");
            description.appendValue(numberOfFailures);
            description.appendText(" failures");
        }

        @Override
        protected void describeMismatchSafely(EventCollector item, org.hamcrest.Description description) {
            description.appendValue(item.fFailures.size());
            description.appendText(" failures");
        }
    };
}
 [Lines 44 - 46 ] {
    return hasNumberOfFailures(1);
}
 [Lines 48 - 50 ] {
    return hasNumberOfFailures(0);
}
 [Lines 53 - 66 ] {
    return new TypeSafeMatcher<EventCollector>() {

        @Override
        public boolean matchesSafely(EventCollector item) {
            return item.fAssumptionFailures.size() == numberOfFailures;
        }

        public void describeTo(org.hamcrest.Description description) {
            description.appendText("has ");
            description.appendValue(numberOfFailures);
            description.appendText(" assumption failures");
        }
    };
}
 [Lines 68 - 70 ] {
    return hasNumberOfAssumptionFailures(1);
}
 [Lines 72 - 74 ] {
    return hasNumberOfAssumptionFailures(0);
}
 [Lines 76 - 78 ] {
    return hasSingleFailureWithMessage(equalTo(message));
}
 [Lines 81 - 113 ] {
    return new TypeSafeMatcher<EventCollector>() {

        @Override
        public boolean matchesSafely(EventCollector item) {
            return hasSingleFailure().matches(item) && messageMatcher.matches(item.fFailures.get(0).getMessage());
        }

        public void describeTo(org.hamcrest.Description description) {
            description.appendText("has single failure with message ");
            messageMatcher.describeTo(description);
        }

        @Override
        protected void describeMismatchSafely(EventCollector item, org.hamcrest.Description description) {
            description.appendText("was ");
            hasSingleFailure().describeMismatch(item, description);
            description.appendText(": ");
            boolean first = true;
            for (Failure f : item.fFailures) {
                if (!first) {
                    description.appendText(" ,");
                }
                description.appendText("'");
                description.appendText(f.getMessage());
                description.appendText("'");
                first = false;
            }
        }
    };
}
 [Lines 115 - 130 ] {
    return new TypeSafeMatcher<EventCollector>() {

        @Override
        public boolean matchesSafely(EventCollector item) {
            for (Failure f : item.fFailures) {
                return exceptionMatcher.matches(f.getException());
            }
            return false;
        }

        public void describeTo(org.hamcrest.Description description) {
            description.appendText("failure is ");
            exceptionMatcher.describeTo(description);
        }
    };
}
 [Lines 147 - 149 ] {
    fTestRunsStarted.add(description);
}
 [Lines 152 - 154 ] {
    fTestRunsFinished.add(result);
}
 [Lines 157 - 159 ] {
    fTestsStarted.add(description);
}
 [Lines 162 - 164 ] {
    fTestsFinished.add(description);
}
 [Lines 167 - 169 ] {
    fFailures.add(failure);
}
 [Lines 172 - 174 ] {
    fAssumptionFailures.add(failure);
}
 [Lines 177 - 179 ] {
    fTestsIgnored.add(description);
}
 [Lines 182 - 190 ] {
    return fTestRunsStarted.size() + " test runs started, " + fTestRunsFinished.size() + " test runs finished, " + fTestsStarted.size() + " tests started, " + fTestsFinished.size() + " tests finished, " + fFailures.size() + " failures, " + fAssumptionFailures.size() + " assumption failures, " + fTestsIgnored.size() + " tests ignored";
}

/src/test/java/org/junit/tests/experimental/rules/MethodRulesTest.java
======================================================================
 [Lines 34 - 44 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            wasRun = true;
            base.evaluate();
        }

        ;
    };
}
 [Lines 48 - 50 ] {
}
 [Lines 54 - 58 ] {
    wasRun = false;
    JUnitCore.runClasses(ExampleTest.class);
    assertTrue(wasRun);
}
 [Lines 65 - 69 ] {
    wasRun = false;
    JUnitCore.runClasses(SonOfExampleTest.class);
    assertTrue(wasRun);
}
 [Lines 75 - 83 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            runCount++;
            base.evaluate();
        }
    };
}
 [Lines 95 - 97 ] {
}
 [Lines 101 - 105 ] {
    runCount = 0;
    JUnitCore.runClasses(MultipleRuleTest.class);
    assertEquals(2, runCount);
}
 [Lines 111 - 113 ] {
}
 [Lines 117 - 120 ] {
    Result result = JUnitCore.runClasses(NoRulesTest.class);
    assertEquals(0, result.getFailureCount());
}
 [Lines 128 - 130 ] {
    log += method.getName() + " " + e.getClass().getSimpleName();
}
 [Lines 134 - 136 ] {
    fail();
}
 [Lines 140 - 145 ] {
    log = "";
    Result result = JUnitCore.runClasses(OnFailureTest.class);
    assertEquals("nothing AssertionError", log);
    assertEquals(1, result.getFailureCount());
}
 [Lines 153 - 156 ] {
    watchedLog += method.getName() + " " + e.getClass().getSimpleName() + "\n";
}
 [Lines 159 - 161 ] {
    watchedLog += method.getName() + " " + "success!\n";
}
 [Lines 165 - 167 ] {
    fail();
}
 [Lines 170 - 171 ] {
}
 [Lines 175 - 180 ] {
    WatchmanTest.watchedLog = "";
    JUnitCore.runClasses(WatchmanTest.class);
    assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
    assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
}
 [Lines 186 - 188 ] {
    watchedLog += "before ";
}
 [Lines 193 - 195 ] {
    watchedLog += "starting ";
}
 [Lines 198 - 200 ] {
    watchedLog += "finished ";
}
 [Lines 203 - 205 ] {
    watchedLog += "succeeded ";
}
 [Lines 209 - 211 ] {
    watchedLog += "after ";
}
 [Lines 214 - 216 ] {
    watchedLog += "test ";
}
 [Lines 220 - 224 ] {
    BeforesAndAfters.watchedLog = "";
    JUnitCore.runClasses(BeforesAndAfters.class);
    assertThat(BeforesAndAfters.watchedLog, is("starting before test after succeeded finished "));
}
 [Lines 231 - 232 ] {
}
 [Lines 236 - 239 ] {
    assertThat(testResult(WrongTypedField.class), hasSingleFailureContaining("must implement MethodRule"));
}
 [Lines 246 - 249 ] {
    assertThat(testResult(SonOfWrongTypedField.class), hasSingleFailureContaining("must implement MethodRule"));
}
 [Lines 256 - 257 ] {
}
 [Lines 261 - 264 ] {
    assertThat(testResult(PrivateRule.class), hasSingleFailureContaining("must be public"));
}
 [Lines 269 - 277 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            name = description.getMethodName();
            base.evaluate();
        }
    };
}
 [Lines 285 - 287 ] {
    assertEquals("foo", counter.name);
}
 [Lines 291 - 293 ] {
    assertThat(testResult(UsesCustomMethodRule.class), isSuccessful());
}
 [Lines 297 - 306 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            wasRun = true;
            base.evaluate();
        }
    };
}
 [Lines 310 - 312 ] {
    return methodRule;
}
 [Lines 315 - 317 ] {
}
 [Lines 329 - 333 ] {
    wasRun = false;
    JUnitCore.runClasses(HasMethodReturningMethodRule.class);
    assertTrue(wasRun);
}
 [Lines 337 - 339 ] {
    return new Increment();
}
 [Lines 342 - 344 ] {
    return new Increment();
}
 [Lines 347 - 349 ] {
}
 [Lines 361 - 365 ] {
    runCount = 0;
    JUnitCore.runClasses(HasMultipleMethodsReturningMethodRule.class);
    assertEquals(2, runCount);
}
 [Lines 372 - 380 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            base.evaluate();
        }
    };
}
 [Lines 385 - 388 ] {
    callCount++;
    return new Dummy();
}
 [Lines 391 - 393 ] {
    assertEquals(1, callCount);
}
 [Lines 405 - 407 ] {
    assertTrue(JUnitCore.runClasses(CallsMethodReturningRuleOnlyOnce.class).wasSuccessful());
}

/src/test/java/org/junit/tests/experimental/rules/NameRulesTest.java
====================================================================
 [Lines 20 - 22 ] {
    assertEquals("testA", name.getMethodName());
}
 [Lines 25 - 27 ] {
    assertEquals("testB", name.getMethodName());
}
 [Lines 37 - 39 ] {
    assertEquals(expectedName, name.getMethodName());
}
 [Lines 42 - 44 ] {
    assertEquals(expectedName, name.getMethodName());
}
 [Lines 47 - 49 ] {
    assertEquals(expectedName, name.getMethodName());
}

/src/test/java/org/junit/tests/experimental/rules/VerifierRuleTest.java
=======================================================================
 [Lines 24 - 26 ] {
    collector.addError(new Throwable("message"));
}
 [Lines 30 - 32 ] {
    assertThat(testResult(UsesErrorCollector.class), hasFailureContaining("message"));
}
 [Lines 39 - 42 ] {
    collector.addError(new Throwable("first thing went wrong"));
    collector.addError(new Throwable("second thing went wrong"));
}
 [Lines 46 - 50 ] {
    PrintableResult testResult = testResult(UsesErrorCollectorTwice.class);
    assertThat(testResult, hasFailureContaining("first thing went wrong"));
    assertThat(testResult, hasFailureContaining("second thing went wrong"));
}
 [Lines 57 - 62 ] {
    collector.checkThat(3, is(4));
    collector.checkThat(5, is(6));
    collector.checkThat("reason 1", 7, is(8));
    collector.checkThat("reason 2", 9, is(16));
}
 [Lines 66 - 74 ] {
    PrintableResult testResult = testResult(UsesErrorCollectorCheckThat.class);
    assertThat(testResult, hasFailureContaining("was <3>"));
    assertThat(testResult, hasFailureContaining("was <5>"));
    assertThat(testResult, hasFailureContaining("reason 1"));
    assertThat(testResult, hasFailureContaining("was <7>"));
    assertThat(testResult, hasFailureContaining("reason 2"));
    assertThat(testResult, hasFailureContaining("was <9>"));
}
 [Lines 81 - 98 ] {
    collector.checkSucceeds(new Callable<Object>() {

        public Object call() throws Exception {
            throw new RuntimeException("first!");
        }
    });
    collector.checkSucceeds(new Callable<Integer>() {

        public Integer call() throws Exception {
            throw new RuntimeException("second!");
        }
    });
    Integer result = collector.checkSucceeds(new Callable<Integer>() {

        public Integer call() throws Exception {
            return 1;
        }
    });
    assertEquals(Integer.valueOf(1), result);
}
 [Lines 102 - 106 ] {
    PrintableResult testResult = testResult(UsesErrorCollectorCheckSucceeds.class);
    assertThat(testResult, hasFailureContaining("first!"));
    assertThat(testResult, hasFailureContaining("second!"));
}
 [Lines 113 - 119 ] {
    assertEquals(3, collector.checkSucceeds(new Callable<Object>() {

        public Object call() throws Exception {
            return 3;
        }
    }));
}
 [Lines 123 - 126 ] {
    PrintableResult testResult = testResult(UsesErrorCollectorCheckSucceedsPasses.class);
    assertThat(testResult, isSuccessful());
}
 [Lines 134 - 136 ] {
    sequence += "verify ";
}
 [Lines 140 - 142 ] {
    sequence += "test ";
}
 [Lines 146 - 150 ] {
    sequence = "";
    assertThat(testResult(UsesVerifier.class), isSuccessful());
    assertEquals("test verify ", sequence);
}

/src/test/java/org/junit/tests/experimental/rules/TestRuleTest.java
===================================================================
 [Lines 37 - 47 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            wasRun = true;
            base.evaluate();
        }

        ;
    };
}
 [Lines 51 - 53 ] {
}
 [Lines 57 - 61 ] {
    wasRun = false;
    JUnitCore.runClasses(ExampleTest.class);
    assertTrue(wasRun);
}
 [Lines 67 - 70 ] {
    applications++;
    return base;
}
 [Lines 72 - 75 ] {
    applications++;
    return base;
}
 [Lines 83 - 85 ] {
    assertEquals(1, both.applications);
}
 [Lines 90 - 92 ] {
    assertTrue(JUnitCore.runClasses(OneFieldTwoKindsOfRule.class).wasSuccessful());
}
 [Lines 99 - 103 ] {
    wasRun = false;
    JUnitCore.runClasses(SonOfExampleTest.class);
    assertTrue(wasRun);
}
 [Lines 109 - 119 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            runCount++;
            base.evaluate();
        }

        ;
    };
}
 [Lines 129 - 131 ] {
}
 [Lines 135 - 139 ] {
    runCount = 0;
    JUnitCore.runClasses(MultipleRuleTest.class);
    assertEquals(2, runCount);
}
 [Lines 145 - 147 ] {
}
 [Lines 151 - 154 ] {
    Result result = JUnitCore.runClasses(NoRulesTest.class);
    assertEquals(0, result.getFailureCount());
}
 [Lines 162 - 164 ] {
    log += description + " " + e.getClass().getSimpleName();
}
 [Lines 168 - 170 ] {
    fail();
}
 [Lines 174 - 179 ] {
    log = "";
    Result result = JUnitCore.runClasses(OnFailureTest.class);
    assertEquals(String.format("nothing(%s) AssertionError", OnFailureTest.class.getName()), log);
    assertEquals(1, result.getFailureCount());
}
 [Lines 187 - 190 ] {
    watchedLog += description + " " + e.getClass().getSimpleName() + "\n";
}
 [Lines 193 - 195 ] {
    watchedLog += description + " " + "success!\n";
}
 [Lines 199 - 201 ] {
    fail();
}
 [Lines 204 - 205 ] {
}
 [Lines 209 - 214 ] {
    WatchmanTest.watchedLog = "";
    JUnitCore.runClasses(WatchmanTest.class);
    assertThat(WatchmanTest.watchedLog, containsString(String.format("fails(%s) AssertionError", WatchmanTest.class.getName())));
    assertThat(WatchmanTest.watchedLog, containsString(String.format("succeeds(%s) success!", WatchmanTest.class.getName())));
}
 [Lines 220 - 222 ] {
    watchedLog.append("before ");
}
 [Lines 228 - 230 ] {
    watchedLog.append("after ");
}
 [Lines 233 - 235 ] {
    watchedLog.append("test ");
}
 [Lines 239 - 244 ] {
    BeforesAndAfters.watchedLog = new StringBuilder();
    JUnitCore.runClasses(BeforesAndAfters.class);
    assertThat(BeforesAndAfters.watchedLog.toString(), is("starting before test after succeeded finished "));
}
 [Lines 251 - 252 ] {
}
 [Lines 256 - 259 ] {
    assertThat(testResult(WrongTypedField.class), hasSingleFailureContaining("must implement MethodRule"));
}
 [Lines 266 - 269 ] {
    assertThat(testResult(SonOfWrongTypedField.class), hasSingleFailureContaining("must implement MethodRule"));
}
 [Lines 276 - 277 ] {
}
 [Lines 281 - 284 ] {
    assertThat(testResult(PrivateRule.class), hasSingleFailureContaining("must be public"));
}
 [Lines 289 - 297 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            name = description.getMethodName();
            base.evaluate();
        }
    };
}
 [Lines 305 - 307 ] {
    assertEquals("foo", counter.name);
}
 [Lines 311 - 313 ] {
    assertThat(testResult(UsesCustomMethodRule.class), isSuccessful());
}
 [Lines 317 - 327 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            wasRun = true;
            base.evaluate();
        }

        ;
    };
}
 [Lines 331 - 333 ] {
    return example;
}
 [Lines 336 - 338 ] {
}
 [Lines 342 - 346 ] {
    wasRun = false;
    JUnitCore.runClasses(MethodExampleTest.class);
    assertTrue(wasRun);
}
 [Lines 352 - 355 ] {
    applications++;
    return base;
}
 [Lines 357 - 360 ] {
    applications++;
    return base;
}
 [Lines 367 - 369 ] {
    return both;
}
 [Lines 372 - 374 ] {
    assertEquals(1, both.applications);
}
 [Lines 379 - 381 ] {
    assertTrue(JUnitCore.runClasses(MethodOneFieldTwoKindsOfRule.class).wasSuccessful());
}
 [Lines 388 - 392 ] {
    wasRun = false;
    JUnitCore.runClasses(MethodSonOfExampleTest.class);
    assertTrue(wasRun);
}
 [Lines 396 - 406 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            runCount++;
            base.evaluate();
        }

        ;
    };
}
 [Lines 412 - 414 ] {
    return incrementor1;
}
 [Lines 419 - 421 ] {
    return incrementor2;
}
 [Lines 424 - 426 ] {
}
 [Lines 430 - 434 ] {
    runCount = 0;
    JUnitCore.runClasses(MethodMultipleRuleTest.class);
    assertEquals(2, runCount);
}
 [Lines 440 - 442 ] {
}
 [Lines 446 - 449 ] {
    Result result = JUnitCore.runClasses(MethodNoRulesTest.class);
    assertEquals(0, result.getFailureCount());
}
 [Lines 454 - 456 ] {
    log += description + " " + e.getClass().getSimpleName();
}
 [Lines 460 - 462 ] {
    return watchman;
}
 [Lines 465 - 467 ] {
    fail();
}
 [Lines 471 - 476 ] {
    log = "";
    Result result = JUnitCore.runClasses(MethodOnFailureTest.class);
    assertEquals(String.format("nothing(%s) AssertionError", MethodOnFailureTest.class.getName()), log);
    assertEquals(1, result.getFailureCount());
}
 [Lines 481 - 483 ] {
    log += description + " " + e.getClass().getSimpleName();
}
 [Lines 487 - 489 ] {
    return watchman;
}
 [Lines 492 - 494 ] {
    Assume.assumeTrue(false);
}
 [Lines 498 - 504 ] {
    log = "";
    Result result = JUnitCore.runClasses(MethodOnSkippedTest.class);
    assertEquals(String.format("nothing(%s) AssumptionViolatedException", MethodOnSkippedTest.class.getName()), log);
    assertEquals(0, result.getFailureCount());
    assertEquals(1, result.getRunCount());
}
 [Lines 512 - 515 ] {
    watchedLog += description + " " + e.getClass().getSimpleName() + "\n";
}
 [Lines 518 - 520 ] {
    watchedLog += description + " " + "success!\n";
}
 [Lines 524 - 526 ] {
    return watchman;
}
 [Lines 529 - 531 ] {
    fail();
}
 [Lines 534 - 535 ] {
}
 [Lines 539 - 544 ] {
    WatchmanTest.watchedLog = "";
    JUnitCore.runClasses(WatchmanTest.class);
    assertThat(WatchmanTest.watchedLog, containsString(String.format("fails(%s) AssertionError", WatchmanTest.class.getName())));
    assertThat(WatchmanTest.watchedLog, containsString(String.format("succeeds(%s) success!", WatchmanTest.class.getName())));
}
 [Lines 550 - 552 ] {
    watchedLog += "before ";
}
 [Lines 556 - 558 ] {
    watchedLog += "starting ";
}
 [Lines 561 - 563 ] {
    watchedLog += "finished ";
}
 [Lines 566 - 568 ] {
    watchedLog += "succeeded ";
}
 [Lines 572 - 574 ] {
    return watchman;
}
 [Lines 577 - 579 ] {
    watchedLog += "after ";
}
 [Lines 582 - 584 ] {
    watchedLog += "test ";
}
 [Lines 588 - 592 ] {
    MethodBeforesAndAfters.watchedLog = "";
    JUnitCore.runClasses(MethodBeforesAndAfters.class);
    assertThat(MethodBeforesAndAfters.watchedLog, is("starting before test after succeeded finished "));
}
 [Lines 596 - 598 ] {
    return 5;
}
 [Lines 601 - 602 ] {
}
 [Lines 606 - 609 ] {
    assertThat(testResult(MethodWrongTypedField.class), hasSingleFailureContaining("must return an implementation of MethodRule"));
}
 [Lines 616 - 619 ] {
    assertThat(testResult(MethodSonOfWrongTypedField.class), hasSingleFailureContaining("must return an implementation of MethodRule"));
}
 [Lines 623 - 625 ] {
    return new TestName();
}
 [Lines 628 - 629 ] {
}
 [Lines 633 - 636 ] {
    assertThat(testResult(MethodPrivateRule.class), hasSingleFailureContaining("must be public"));
}
 [Lines 642 - 644 ] {
    return counter;
}
 [Lines 647 - 649 ] {
    assertEquals("foo", counter.name);
}
 [Lines 653 - 655 ] {
    assertThat(testResult(MethodUsesCustomMethodRule.class), isSuccessful());
}
 [Lines 662 - 664 ] {
    this.name = name;
}
 [Lines 666 - 674 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            orderList.add(name);
            base.evaluate();
        }
    };
}
 [Lines 679 - 681 ] {
    return new OrderTestRule("orderMethod");
}
 [Lines 687 - 690 ] {
    assertEquals("orderField", orderList.get(0));
    assertEquals("orderMethod", orderList.get(1));
}
 [Lines 694 - 697 ] {
    orderList.clear();
    assertThat(testResult(UsesFieldAndMethodRule.class), isSuccessful());
}
 [Lines 703 - 712 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            base.evaluate();
        }

        ;
    };
}
 [Lines 716 - 719 ] {
    countOfMethodCalls++;
    return new Dummy();
}
 [Lines 722 - 724 ] {
    assertEquals(1, countOfMethodCalls);
}
 [Lines 728 - 730 ] {
    assertTrue(JUnitCore.runClasses(CallMethodOnlyOnceRule.class).wasSuccessful());
}

/src/test/java/org/junit/tests/experimental/rules/LoggingTestWatcher.java
=========================================================================
 [Lines 10 - 12 ] {
    this.log = log;
}
 [Lines 15 - 17 ] {
    log.append("succeeded ");
}
 [Lines 20 - 22 ] {
    log.append("failed ");
}
 [Lines 25 - 27 ] {
    log.append("skipped ");
}
 [Lines 30 - 32 ] {
    log.append("starting ");
}
 [Lines 35 - 37 ] {
    log.append("finished ");
}

/src/test/java/org/junit/tests/experimental/rules/RuleChainTest.java
====================================================================
 [Lines 24 - 26 ] {
    this.label = label;
}
 [Lines 29 - 31 ] {
    LOG.add("starting " + label);
}
 [Lines 34 - 36 ] {
    LOG.add("finished " + label);
}
 [Lines 46 - 48 ] {
    assertTrue(true);
}
 [Lines 52 - 59 ] {
    testResult(UseRuleChain.class);
    List<String> expectedLog = asList("starting outer rule", "starting middle rule", "starting inner rule", "finished inner rule", "finished middle rule", "finished outer rule");
    assertEquals(expectedLog, LOG);
}

/src/test/java/org/junit/tests/experimental/rules/TemporaryFolderUsageTest.java
===============================================================================
 [Lines 31 - 33 ] {
    tempFolder = new TemporaryFolder();
}
 [Lines 36 - 38 ] {
    tempFolder.delete();
}
 [Lines 41 - 43 ] {
    new TemporaryFolder().getRoot();
}
 [Lines 47 - 49 ] {
    new TemporaryFolder().newFile();
}
 [Lines 53 - 55 ] {
    new TemporaryFolder().newFile("MyFile.txt");
}
 [Lines 58 - 65 ] {
    tempFolder.create();
    tempFolder.newFile("MyFile.txt");
    thrown.expect(IOException.class);
    thrown.expectMessage("a file with the name 'MyFile.txt' already exists in the test folder");
    tempFolder.newFile("MyFile.txt");
}
 [Lines 69 - 71 ] {
    new TemporaryFolder().newFolder();
}
 [Lines 74 - 76 ] {
    new TemporaryFolder().newFolder("level1", "level2", "level3");
}
 [Lines 79 - 86 ] {
    tempFolder.create();
    tempFolder.newFolder("level1");
    thrown.expect(IOException.class);
    thrown.expectMessage("a folder with the name 'level1' already exists");
    tempFolder.newFolder("level1");
}
 [Lines 90 - 95 ] {
    tempFolder.create();
    thrown.expect(IOException.class);
    thrown.expectMessage("name cannot consist of multiple path components");
    tempFolder.newFolder("temp1/temp2");
}
 [Lines 98 - 105 ] {
    tempFolder.create();
    tempFolder.newFolder("level1", "level2", "level3");
    thrown.expect(IOException.class);
    thrown.expectMessage("a folder with the name 'level3' already exists");
    tempFolder.newFolder("level1", "level2", "level3");
}
 [Lines 109 - 114 ] {
    tempFolder.create();
    thrown.expect(IOException.class);
    thrown.expectMessage("name cannot consist of multiple path components");
    tempFolder.newFolder("temp1", "temp2", "temp3/temp4");
}
 [Lines 117 - 120 ] {
    tempFolder.create();
    assertFileExists(tempFolder.getRoot());
}
 [Lines 123 - 125 ] {
    tempFolder.delete();
}
 [Lines 128 - 132 ] {
    tempFolder.create();
    tempFolder.delete();
    assertFileDoesNotExist(tempFolder.getRoot());
}
 [Lines 135 - 141 ] {
    tempFolder.create();
    File f = tempFolder.newFile();
    assertFileExists(f);
    assertFileCreatedUnderRootFolder("Random file", f);
}
 [Lines 144 - 153 ] {
    final String fileName = "SampleFile.txt";
    tempFolder.create();
    File f = tempFolder.newFile(fileName);
    assertFileExists(f);
    assertFileCreatedUnderRootFolder("Named file", f);
    assertThat("file name", f.getName(), equalTo(fileName));
}
 [Lines 156 - 162 ] {
    tempFolder.create();
    File f = tempFolder.newFolder();
    assertFileExists(f);
    assertFileCreatedUnderRootFolder("Random folder", f);
}
 [Lines 165 - 176 ] {
    tempFolder.create();
    File f = tempFolder.newFolder("top", "middle", "bottom");
    assertFileExists(f);
    assertParentFolderForFileIs(f, new File(tempFolder.getRoot(), "top/middle"));
    assertParentFolderForFileIs(f.getParentFile(), new File(tempFolder.getRoot(), "top"));
    assertFileCreatedUnderRootFolder("top", f.getParentFile().getParentFile());
}
 [Lines 179 - 186 ] {
    File tempDir = createTemporaryFolder();
    TemporaryFolder folder = new TemporaryFolder(tempDir);
    folder.create();
    assertThat(tempDir, is(folder.getRoot().getParentFile()));
}
 [Lines 188 - 193 ] {
    File tempDir = File.createTempFile("junit", "tempFolder");
    assertTrue("Unable to delete temporary file", tempDir.delete());
    assertTrue("Unable to create temp directory", tempDir.mkdir());
    return tempDir;
}
 [Lines 195 - 197 ] {
    checkFileExists("exists", file, false);
}
 [Lines 199 - 203 ] {
    assertThat("File is null", file, is(notNullValue()));
    assertThat("File '" + file.getAbsolutePath() + "' " + msg, file.exists(), is(exists));
}
 [Lines 205 - 207 ] {
    checkFileExists("does not exist", file, true);
}
 [Lines 209 - 211 ] {
    assertParentFolderForFileIs(f, tempFolder.getRoot());
}
 [Lines 213 - 216 ] {
    assertThat("'" + f.getAbsolutePath() + "': not under root", f.getParentFile(), is(parentFolder));
}

/src/test/java/org/junit/tests/experimental/rules/BlockJUnit4ClassRunnerOverrideTest.java
=========================================================================================
 [Lines 25 - 33 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            target.getClass().getField("flipBit").set(target, true);
            base.evaluate();
        }
    };
}
 [Lines 38 - 40 ] {
    super(klass);
}
 [Lines 43 - 48 ] {
    final LinkedList<MethodRule> methodRules = new LinkedList<MethodRule>(super.rules(test));
    methodRules.add(new FlipBitRule());
    return methodRules;
}
 [Lines 56 - 58 ] {
    assertTrue(flipBit);
}
 [Lines 62 - 64 ] {
    assertThat(testResult(OverrideTestRulesTest.class), isSuccessful());
}
 [Lines 68 - 70 ] {
    super(klass);
}
 [Lines 73 - 82 ] {
    final LinkedList<TestRule> methodRules = new LinkedList<TestRule>(super.getTestRules(test));
    methodRules.add(new TestRule() {

        public Statement apply(Statement base, Description description) {
            return new FlipBitRule().apply(base, null, test);
        }
    });
    return methodRules;
}
 [Lines 90 - 92 ] {
    assertThat(testResult(OverrideRulesTest.class), isSuccessful());
}
 [Lines 102 - 106 ] {
    super(klass);
    assert (klass.equals(OverrideCreateTest.class));
}
 [Lines 109 - 115 ] {
    final OverrideCreateTest obj = new OverrideCreateTest();
    obj.method = method;
    return obj;
}
 [Lines 123 - 125 ] {
    assertEquals("testMethodA", method.getMethod().getName());
}
 [Lines 128 - 130 ] {
    assertEquals("testMethodB", method.getMethod().getName());
}
 [Lines 134 - 136 ] {
    assertThat(testResult(OverrideCreateTest.class), isSuccessful());
}
 [Lines 147 - 151 ] {
    super(klass);
    assert (klass.equals(CreateTestDefersToNoArgCreateTestTest.class));
}
 [Lines 154 - 160 ] {
    final CreateTestDefersToNoArgCreateTestTest obj = new CreateTestDefersToNoArgCreateTestTest();
    obj.createTestCalled = true;
    return obj;
}
 [Lines 168 - 170 ] {
    assertEquals(true, createTestCalled);
}
 [Lines 174 - 176 ] {
    assertThat(testResult(CreateTestDefersToNoArgCreateTestTest.class), isSuccessful());
}

/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionTest.java
============================================================================
 [Lines 36 - 92 ] {
    return asList(new Object[][] { { EmptyTestExpectingNoException.class, everyTestRunSuccessful() }, { ThrowExceptionWithExpectedType.class, everyTestRunSuccessful() }, { ThrowExceptionWithExpectedPartOfMessage.class, everyTestRunSuccessful() }, { ThrowExceptionWithWrongType.class, hasSingleFailureWithMessage(startsWith("\nExpected: an instance of java.lang.NullPointerException")) }, { HasWrongMessage.class, hasSingleFailureWithMessage(startsWith("\nExpected: exception with message a string containing \"expectedMessage\"\n" + "     but: message was \"actualMessage\"")) }, { ThrowNoExceptionButExpectExceptionWithType.class, hasSingleFailureWithMessage("Expected test to throw an instance of java.lang.NullPointerException") }, { WronglyExpectsExceptionMessage.class, hasSingleFailure() }, { ExpectsSubstring.class, everyTestRunSuccessful() }, { ExpectsSubstringNullMessage.class, hasSingleFailureWithMessage(startsWith("\nExpected: exception with message a string containing \"anything!\"")) }, { ExpectsMessageMatcher.class, everyTestRunSuccessful() }, { ExpectedMessageMatcherFails.class, hasSingleFailureWithMessage(startsWith("\nExpected: exception with message \"Wrong start\"")) }, { ExpectsMatcher.class, everyTestRunSuccessful() }, { ExpectAssertionErrorWhichIsNotThrown.class, hasSingleFailure() }, { FailedAssumptionAndExpectException.class, hasSingleAssumptionFailure() }, { FailBeforeExpectingException.class, hasSingleFailureWithMessage(ARBITRARY_MESSAGE) }, { ExpectsMultipleMatchers.class, hasSingleFailureWithMessage(startsWith("\nExpected: (an instance of java.lang.IllegalArgumentException and exception with message a string containing \"Ack!\")")) }, { ThrowExceptionWithMatchingCause.class, everyTestRunSuccessful() }, { ThrowExpectedNullCause.class, everyTestRunSuccessful() }, { ThrowUnexpectedCause.class, hasSingleFailureWithMessage(CoreMatchers.<String>allOf(startsWith("\nExpected: ("), containsString("exception with cause is <java.lang.NullPointerException: expected cause>"), containsString("cause was <java.lang.NullPointerException: an unexpected cause>"), containsString("Stacktrace was: java.lang.IllegalArgumentException: Ack!"), containsString("Caused by: java.lang.NullPointerException: an unexpected cause"))) }, { UseNoCustomMessage.class, hasSingleFailureWithMessage("Expected test to throw an instance of java.lang.IllegalArgumentException") }, { UseCustomMessageWithoutPlaceHolder.class, hasSingleFailureWithMessage(ARBITRARY_MESSAGE) }, { UseCustomMessageWithPlaceHolder.class, hasSingleFailureWithMessage(ARBITRARY_MESSAGE + " - an instance of java.lang.IllegalArgumentException") } });
}
 [Lines 99 - 102 ] {
    this.classUnderTest = classUnderTest;
    this.matcher = matcher;
}
 [Lines 105 - 111 ] {
    EventCollector collector = new EventCollector();
    JUnitCore core = new JUnitCore();
    core.addListener(collector);
    core.run(classUnderTest);
    assertThat(collector, matcher);
}
 [Lines 118 - 119 ] {
}
 [Lines 127 - 130 ] {
    thrown.expect(NullPointerException.class);
    throw new NullPointerException();
}
 [Lines 138 - 142 ] {
    thrown.expect(NullPointerException.class);
    thrown.expectMessage(ARBITRARY_MESSAGE);
    throw new NullPointerException(ARBITRARY_MESSAGE + "something else");
}
 [Lines 150 - 153 ] {
    thrown.expect(NullPointerException.class);
    throw new IllegalArgumentException();
}
 [Lines 161 - 164 ] {
    thrown.expectMessage("expectedMessage");
    throw new IllegalArgumentException("actualMessage");
}
 [Lines 172 - 174 ] {
    thrown.expect(NullPointerException.class);
}
 [Lines 182 - 184 ] {
    thrown.expectMessage("anything!");
}
 [Lines 192 - 196 ] {
    thrown.expectMessage("anything!");
    throw new NullPointerException("This could throw anything! (as long as it has the right substring)");
}
 [Lines 204 - 207 ] {
    thrown.expectMessage("anything!");
    throw new NullPointerException();
}
 [Lines 215 - 218 ] {
    thrown.expectMessage(startsWith(ARBITRARY_MESSAGE));
    throw new NullPointerException(ARBITRARY_MESSAGE + "!");
}
 [Lines 226 - 229 ] {
    thrown.expectMessage(equalTo("Wrong start"));
    throw new NullPointerException("Back!");
}
 [Lines 237 - 240 ] {
    thrown.expect(any(Exception.class));
    throw new NullPointerException("Ack!");
}
 [Lines 248 - 252 ] {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage("Ack!");
    throw new NullPointerException("Ack!");
}
 [Lines 261 - 263 ] {
    thrown.expect(AssertionError.class);
}
 [Lines 271 - 274 ] {
    fail(ARBITRARY_MESSAGE);
    thrown.expect(IllegalArgumentException.class);
}
 [Lines 282 - 285 ] {
    assumeTrue(false);
    thrown.expect(NullPointerException.class);
}
 [Lines 293 - 301 ] {
    NullPointerException expectedCause = new NullPointerException("expected cause");
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage("Ack!");
    thrown.expectCause(is(expectedCause));
    throw new IllegalArgumentException("Ack!", expectedCause);
}
 [Lines 309 - 315 ] {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage("Ack!");
    thrown.expectCause(nullValue(Throwable.class));
    throw new IllegalArgumentException("Ack!");
}
 [Lines 324 - 330 ] {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage("Ack!");
    thrown.expectCause(is(new NullPointerException("expected cause")));
    throw new IllegalArgumentException("Ack!", new NullPointerException("an unexpected cause"));
}
 [Lines 339 - 341 ] {
    thrown.expect(IllegalArgumentException.class);
}
 [Lines 350 - 354 ] {
    thrown.expect(IllegalArgumentException.class);
    thrown.reportMissingExceptionWithMessage(ARBITRARY_MESSAGE + " - %s");
}
 [Lines 363 - 366 ] {
    thrown.expect(IllegalArgumentException.class);
    thrown.reportMissingExceptionWithMessage(ARBITRARY_MESSAGE);
}

/src/test/java/org/junit/tests/experimental/rules/TemporaryFolderRuleAssuredDeletionTest.java
=============================================================================================
 [Lines 19 - 21 ] {
    super(builder);
}
 [Lines 27 - 28 ] {
}
 [Lines 34 - 36 ] {
    return false;
}
 [Lines 38 - 45 ] {
    return new TemporaryFolder.Builder() {

        @Override
        public TemporaryFolder build() {
            return new StubTemporaryFolder(this);
        }
    };
}
 [Lines 54 - 55 ] {
}
 [Lines 59 - 63 ] {
    PrintableResult result = testResult(HasTempFolderWithAssuredDeletion.class);
    assertThat(result, failureCountIs(1));
    assertThat(result.toString(), containsString("Unable to clean up temporary folder"));
}
 [Lines 69 - 70 ] {
}
 [Lines 74 - 77 ] {
    PrintableResult result = testResult(HasTempFolderWithoutAssuredDeletion.class);
    assertThat(result, isSuccessful());
}

/src/test/java/org/junit/tests/experimental/rules/TestWatchmanTest.java
=======================================================================
 [Lines 21 - 23 ] {
    assumeTrue(false);
}
 [Lines 27 - 31 ] {
    runClasses(ViolatedAssumptionTest.class);
    assertThat(ViolatedAssumptionTest.watchman.log.toString(), is("starting finished "));
}
 [Lines 38 - 40 ] {
    fail();
}
 [Lines 44 - 48 ] {
    runClasses(FailingTest.class);
    assertThat(FailingTest.watchman.log.toString(), is("starting failed finished "));
}
 [Lines 54 - 56 ] {
    log.append("succeeded ");
}
 [Lines 59 - 61 ] {
    log.append("failed ");
}
 [Lines 64 - 66 ] {
    log.append("starting ");
}
 [Lines 69 - 71 ] {
    log.append("finished ");
}

/src/test/java/org/junit/tests/experimental/categories/JavadocTest.java
=======================================================================
 [Lines 27 - 29 ] {
    fail();
}
 [Lines 33 - 34 ] {
}
 [Lines 38 - 39 ] {
}
 [Lines 45 - 46 ] {
}
 [Lines 64 - 69 ] {
    Result testResult = JUnitCore.runClasses(SlowTestSuite.class);
    assertTrue(testResult.wasSuccessful());
    assertThat("unexpected run count", testResult.getRunCount(), is(2));
    assertThat("unexpected failure count", testResult.getFailureCount(), is(0));
}
 [Lines 72 - 77 ] {
    Result testResult = JUnitCore.runClasses(FastOrSmokeTestSuite.class);
    assertTrue(testResult.wasSuccessful());
    assertThat("unexpected run count", testResult.getRunCount(), is(2));
    assertThat("unexpected failure count", testResult.getFailureCount(), is(0));
}

/src/test/java/org/junit/tests/experimental/categories/CategoriesAndParameterizedTest.java
==========================================================================================
 [Lines 27 - 29 ] {
    return Arrays.asList("first", "second");
}
 [Lines 35 - 37 ] {
    Assert.assertTrue(true);
}
 [Lines 43 - 45 ] {
    Assert.assertTrue(true);
}
 [Lines 56 - 61 ] {
    Result result = new JUnitCore().run(SuiteWithParameterizedTestWithoutCategory.class);
    assertEquals(1, result.getRunCount());
    assertEquals(0, result.getFailureCount());
}
 [Lines 67 - 69 ] {
    return Arrays.asList("first", "second");
}
 [Lines 75 - 77 ] {
    Assert.assertTrue(true);
}
 [Lines 87 - 92 ] {
    Result result = new JUnitCore().run(SuiteWithParameterizedTestWithCategory.class);
    assertEquals(2, result.getRunCount());
    assertEquals(0, result.getFailureCount());
}
 [Lines 97 - 99 ] {
    return Arrays.asList("first", "second");
}
 [Lines 106 - 108 ] {
    Assert.assertTrue(true);
}
 [Lines 111 - 113 ] {
    Assert.assertTrue(true);
}
 [Lines 123 - 128 ] {
    Result result = new JUnitCore().run(SuiteWithParameterizedTestWithMethodWithCategory.class);
    assertEquals(2, result.getRunCount());
    assertEquals(0, result.getFailureCount());
}

/src/test/java/org/junit/tests/experimental/categories/CategoryValidatorTest.java
=================================================================================
 [Lines 26 - 27 ] {
}
 [Lines 31 - 32 ] {
}
 [Lines 36 - 37 ] {
}
 [Lines 41 - 42 ] {
}
 [Lines 45 - 46 ] {
}
 [Lines 50 - 53 ] {
    FrameworkMethod method = new TestClass(CategoryTest.class).getAnnotatedMethods(BeforeClass.class).get(0);
    testAndAssertErrorMessage(method, "@BeforeClass can not be combined with @Category");
}
 [Lines 56 - 59 ] {
    FrameworkMethod method = new TestClass(CategoryTest.class).getAnnotatedMethods(AfterClass.class).get(0);
    testAndAssertErrorMessage(method, "@AfterClass can not be combined with @Category");
}
 [Lines 62 - 65 ] {
    FrameworkMethod method = new TestClass(CategoryTest.class).getAnnotatedMethods(Before.class).get(0);
    testAndAssertErrorMessage(method, "@Before can not be combined with @Category");
}
 [Lines 68 - 71 ] {
    FrameworkMethod method = new TestClass(CategoryTest.class).getAnnotatedMethods(After.class).get(0);
    testAndAssertErrorMessage(method, "@After can not be combined with @Category");
}
 [Lines 73 - 79 ] {
    List<Exception> errors = new CategoryValidator().validateAnnotatedMethod(method);
    assertThat(errors.size(), is(1));
    Exception exception = errors.get(0);
    assertThat(exception.getMessage(), is(expectedErrorMessage));
}
 [Lines 82 - 87 ] {
    FrameworkMethod method = new FrameworkMethod(CategoryTest.class.getMethod("methodWithCategory"));
    List<Exception> errors = new CategoryValidator().validateAnnotatedMethod(method);
    assertThat(errors.size(), is(0));
}

/src/test/java/org/junit/tests/experimental/categories/MultiCategoryTest.java
=============================================================================
 [Lines 32 - 39 ] {
    // Targeting Test:
    Result testResult = JUnitCore.runClasses(MultiCategorySuite.class);
    assertThat("unexpected run count", testResult.getRunCount(), is(equalTo(2)));
    assertThat("unexpected failure count", testResult.getFailureCount(), is(equalTo(0)));
    assertThat("unexpected failure count", testResult.getIgnoreCount(), is(equalTo(0)));
}
 [Lines 51 - 51 ] {
}
 [Lines 55 - 55 ] {
}
 [Lines 59 - 61 ] {
    fail();
}
 [Lines 64 - 66 ] {
    fail();
}
 [Lines 70 - 75 ] {
    Result testResult = JUnitCore.runClasses(InheritanceAny.class);
    assertThat("unexpected run count", testResult.getRunCount(), is(equalTo(3)));
    assertThat("unexpected failure count", testResult.getFailureCount(), is(equalTo(0)));
    assertThat("unexpected failure count", testResult.getIgnoreCount(), is(equalTo(0)));
}
 [Lines 78 - 83 ] {
    Result testResult = JUnitCore.runClasses(InheritanceAll.class);
    assertThat("unexpected run count", testResult.getRunCount(), is(equalTo(1)));
    assertThat("unexpected failure count", testResult.getFailureCount(), is(equalTo(0)));
    assertThat("unexpected failure count", testResult.getIgnoreCount(), is(equalTo(0)));
}
 [Lines 86 - 91 ] {
    //any included, all excluded
    Result testResult = JUnitCore.runClasses(InheritanceAnyAll.class);
    assertThat("unexpected run count", testResult.getRunCount(), is(equalTo(3)));
    assertThat("unexpected failure count", testResult.getFailureCount(), is(equalTo(0)));
    assertThat("unexpected failure count", testResult.getIgnoreCount(), is(equalTo(0)));
}
 [Lines 94 - 100 ] {
    //all included, any excluded
    Result testResult = JUnitCore.runClasses(InheritanceAllAny.class);
    assertThat("unexpected run count", testResult.getRunCount(), is(equalTo(1)));
    assertThat("unexpected failure count", testResult.getFailureCount(), is(equalTo(1)));
    assertThat("unexpected failure count", testResult.getIgnoreCount(), is(equalTo(0)));
    assertFalse(testResult.wasSuccessful());
}
 [Lines 133 - 133 ] {
}
 [Lines 134 - 134 ] {
}
 [Lines 135 - 135 ] {
}
 [Lines 136 - 136 ] {
    fail();
}
 [Lines 137 - 137 ] {
    fail();
}
 [Lines 138 - 138 ] {
    fail();
}
 [Lines 139 - 139 ] {
    fail();
}
 [Lines 143 - 143 ] {
    fail();
}
 [Lines 144 - 144 ] {
    fail();
}
 [Lines 145 - 145 ] {
}
 [Lines 146 - 146 ] {
    fail();
}
 [Lines 147 - 147 ] {
    fail();
}
 [Lines 148 - 148 ] {
    fail();
}
 [Lines 149 - 149 ] {
    fail();
}
 [Lines 153 - 153 ] {
}
 [Lines 154 - 154 ] {
}
 [Lines 155 - 155 ] {
}
 [Lines 156 - 156 ] {
    fail();
}
 [Lines 157 - 157 ] {
    fail();
}
 [Lines 158 - 158 ] {
    fail();
}
 [Lines 159 - 159 ] {
    fail();
}
 [Lines 163 - 163 ] {
    fail();
}
 [Lines 164 - 164 ] {
    fail();
}
 [Lines 165 - 165 ] {
    fail();
}
 [Lines 166 - 166 ] {
    fail();
}
 [Lines 167 - 167 ] {
    fail();
}
 [Lines 168 - 168 ] {
    fail();
}
 [Lines 169 - 169 ] {
    fail();
}

/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java
========================================================================
 [Lines 53 - 54 ] {
}
 [Lines 58 - 59 ] {
}
 [Lines 63 - 64 ] {
}
 [Lines 69 - 71 ] {
    fail();
}
 [Lines 75 - 76 ] {
}
 [Lines 82 - 84 ] {
}
 [Lines 89 - 91 ] {
    fail();
}
 [Lines 107 - 109 ] {
    assertThat(testResult(JustA.class), isSuccessful());
}
 [Lines 112 - 114 ] {
    assertThat(testResult(SlowTestSuite.class), isSuccessful());
}
 [Lines 124 - 125 ] {
}
 [Lines 129 - 130 ] {
}
 [Lines 134 - 135 ] {
}
 [Lines 139 - 140 ] {
}
 [Lines 144 - 145 ] {
}
 [Lines 155 - 160 ] {
    Result result = JUnitCore.runClasses(SomeAreSlowSuite.class);
    assertThat(testResult(SomeAreSlowSuite.class), isSuccessful());
    assertEquals(2, result.getRunCount());
    assertTrue(result.wasSuccessful());
}
 [Lines 170 - 174 ] {
    Result result = JUnitCore.runClasses(IncludeAndExcludeSuite.class);
    assertEquals(1, result.getRunCount());
    assertTrue(result.wasSuccessful());
}
 [Lines 182 - 188 ] {
    CategoryFilter include = CategoryFilter.include(SlowTests.class);
    Request baseRequest = Request.aClass(TestSuiteWithNoCategories.class);
    Result result = new JUnitCore().run(baseRequest.filterWith(include));
    assertTrue(result.wasSuccessful());
    assertEquals(2, result.getRunCount());
}
 [Lines 192 - 197 ] {
    CategoryFilter filter = CategoryFilter.include(SlowTests.class);
    BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner(A.class);
    filter.apply(runner);
    assertEquals(1, runner.testCount());
}
 [Lines 202 - 204 ] {
}
 [Lines 208 - 210 ] {
}
 [Lines 215 - 221 ] {
    CategoryFilter filter = CategoryFilter.include(SlowTests.class);
    BlockJUnit4ClassRunner runner = new BlockJUnit4ClassRunner(OneFastOneSlow.class);
    filter.apply(runner);
    assertEquals(1, runner.testCount());
}
 [Lines 226 - 228 ] {
}
 [Lines 238 - 243 ] {
    Result result = JUnitCore.runClasses(OneFastSuite.class);
    assertEquals(1, result.getRunCount());
    assertEquals(1, result.getFailureCount());
    assertFalse(result.wasSuccessful());
}
 [Lines 246 - 249 ] {
    CategoryFilter filter = CategoryFilter.include(SlowTests.class);
    assertEquals("categories [" + SlowTests.class + "]", filter.describe());
}
 [Lines 252 - 257 ] {
    CategoryFilter filter = CategoryFilter.include(FastTests.class, SlowTests.class);
    String d1 = format("categories [%s, %s]", FastTests.class, SlowTests.class);
    String d2 = format("categories [%s, %s]", SlowTests.class, FastTests.class);
    assertThat(filter.describe(), is(anyOf(equalTo(d1), equalTo(d2))));
}
 [Lines 263 - 265 ] {
}
 [Lines 275 - 277 ] {
    assertThat(testResult(ChooseSlowFromBoth.class), isSuccessful());
}
 [Lines 286 - 288 ] {
}
 [Lines 298 - 300 ] {
    assertThat(testResult(RunSlowFromVerySlow.class), isSuccessful());
}
 [Lines 320 - 321 ] {
}
 [Lines 325 - 328 ] {
    fail("When multiple categories are included in a Suite, " + "@Test method must match all include categories");
}
 [Lines 332 - 336 ] {
    Result result = JUnitCore.runClasses(AllIncludedMustBeMatchedSuite.class);
    assertEquals(1, result.getRunCount());
    assertEquals(0, result.getFailureCount());
}
 [Lines 348 - 349 ] {
}
 [Lines 353 - 356 ] {
    fail("When multiple categories are included and excluded in a Suite, " + "@Test method must match all include categories and contain non of the excluded");
}
 [Lines 360 - 364 ] {
    Result result = JUnitCore.runClasses(MultiIncludeWithExcludeCategorySuite.class);
    assertEquals(1, result.getRunCount());
    assertEquals(0, result.getFailureCount());
}
 [Lines 372 - 373 ] {
}
 [Lines 383 - 385 ] {
    assertThat(testResult(RunClassAsCategory.class), isSuccessful());
}
 [Lines 392 - 393 ] {
}
 [Lines 402 - 406 ] {
    Result result = JUnitCore.runClasses(InheritanceSuite.class);
    assertEquals(1, result.getRunCount());
    assertTrue(result.wasSuccessful());
}
 [Lines 415 - 417 ] {
    assertThat(testResult(EmptyCategoriesSuite.class), failureCountIs(1));
}
 [Lines 428 - 430 ] {
    fail();
}
 [Lines 440 - 446 ] {
    // behaves same as Suite
    Result result = JUnitCore.runClasses(IgnoredTestCategoriesSuite.class);
    assertFalse(result.wasSuccessful());
    assertThat(result.getRunCount(), is(1));
    assertThat(result.getFailureCount(), is(1));
    assertThat(result.getIgnoreCount(), is(1));
}
 [Lines 452 - 454 ] {
    fail();
}
 [Lines 462 - 464 ] {
    fail();
}
 [Lines 471 - 472 ] {
}
 [Lines 483 - 487 ] {
    Result result = JUnitCore.runClasses(IncludedExcludedSameSuite.class);
    assertEquals(1, result.getRunCount());
    assertTrue(result.wasSuccessful());
}
 [Lines 491 - 499 ] {
    Set<Class<?>> exclusions = new HashSet<Class<?>>(2);
    Collections.addAll(exclusions, SlowTests.class, FastTests.class);
    CategoryFilter exclude = CategoryFilter.categoryFilter(true, null, true, exclusions);
    Request baseRequest = Request.aClass(OneOfEach.class);
    Result result = new JUnitCore().run(baseRequest.filterWith(exclude));
    assertTrue(result.wasSuccessful());
    assertEquals(1, result.getRunCount());
}
 [Lines 502 - 508 ] {
    CategoryFilter exclude = CategoryFilter.include(true, SlowTests.class, FastTests.class);
    Request baseRequest = Request.aClass(OneOfEach.class);
    Result result = new JUnitCore().run(baseRequest.filterWith(exclude));
    assertTrue(result.wasSuccessful());
    assertEquals(2, result.getRunCount());
}
 [Lines 520 - 521 ] {
}
 [Lines 524 - 525 ] {
}
 [Lines 529 - 533 ] {
    Result testResult = JUnitCore.runClasses(NoIncludeCategoryAnnotationSuite.class);
    assertTrue(testResult.wasSuccessful());
    assertEquals(1, testResult.getRunCount());
}
 [Lines 543 - 547 ] {
    Result testResult = JUnitCore.runClasses(SameAsNoIncludeCategoryAnnotationSuite.class);
    assertTrue(testResult.wasSuccessful());
    assertEquals(1, testResult.getRunCount());
}

/src/test/java/org/junit/tests/listening/RunnerTest.java
========================================================
 [Lines 21 - 23 ] {
    this.testCount = description.testCount();
}
 [Lines 28 - 29 ] {
}
 [Lines 33 - 39 ] {
    JUnitCore runner = new JUnitCore();
    MyListener listener = new MyListener();
    runner.addListener(listener);
    runner.run(Example.class);
    assertEquals(1, listener.testCount);
}
 [Lines 42 - 43 ] {
}
 [Lines 47 - 53 ] {
    JUnitCore runner = new JUnitCore();
    MyListener listener = new MyListener();
    runner.addListener(listener);
    runner.run(ExampleTest.class);
    assertEquals(1, listener.testCount);
}
 [Lines 57 - 58 ] {
}
 [Lines 62 - 74 ] {
    JUnitCore runner = new JUnitCore();
    wasRun = false;
    RunListener listener = new MyListener() {

        @Override
        public void testFinished(Description description) {
            wasRun = true;
        }
    };
    runner.addListener(listener);
    runner.run(NewExample.class);
    assertTrue(wasRun);
}

/src/test/java/org/junit/tests/listening/TestListenerTest.java
==============================================================
 [Lines 19 - 21 ] {
    throw new Error();
}
 [Lines 26 - 27 ] {
}
 [Lines 31 - 35 ] {
    JUnitCore runner = new JUnitCore();
    runner.addListener(new ErrorListener());
    runner.run(OneTest.class);
}
 [Lines 39 - 42 ] {
    count++;
    throw new Exception();
}
 [Lines 46 - 56 ] {
    JUnitCore core = new JUnitCore();
    core.addListener(new ExceptionListener());
    count = 0;
    Result result = core.run(OneTest.class);
    assertEquals(1, count);
    assertEquals(1, result.getFailureCount());
    Failure testFailure = result.getFailures().get(0);
    assertEquals(Description.TEST_MECHANISM, testFailure.getDescription());
}
 [Lines 59 - 64 ] {
    JUnitCore core = new JUnitCore();
    Result first = core.run(OneTest.class);
    Result second = core.run(OneTest.class);
    assertNotSame(first, second);
}

/src/test/java/org/junit/tests/listening/ListenerTest.java
==========================================================
 [Lines 15 - 16 ] {
}
 [Lines 20 - 37 ] {
    JUnitCore core = new JUnitCore();
    log = "";
    core.addListener(new RunListener() {

        @Override
        public void testRunStarted(Description description) throws Exception {
            log += "first ";
        }
    });
    core.addListener(new RunListener() {

        @Override
        public void testRunStarted(Description description) throws Exception {
            log += "second ";
        }
    });
    core.run(OneTest.class);
    assertEquals("first second ", log);
}

/src/test/java/org/junit/tests/listening/UserStopTest.java
==========================================================
 [Lines 13 - 16 ] {
    fNotifier = new RunNotifier();
    fNotifier.pleaseStop();
}
 [Lines 19 - 21 ] {
    fNotifier.fireTestStarted(null);
}
 [Lines 25 - 26 ] {
}
 [Lines 30 - 32 ] {
    Request.aClass(OneTest.class).getRunner().run(fNotifier);
}

/src/test/java/org/junit/tests/listening/TextListenerTest.java
==============================================================
 [Lines 23 - 28 ] {
    runner = new JUnitCore();
    TestSystem system = new TestSystem();
    results = system.outContents();
    runner.addListener(new TextListener(system));
}
 [Lines 32 - 33 ] {
}
 [Lines 36 - 40 ] {
    runner.run(OneTest.class);
    assertTrue(results.toString().startsWith(convert(".\nTime: ")));
    assertTrue(results.toString().endsWith(convert("\n\nOK (1 test)\n\n")));
}
 [Lines 44 - 46 ] {
    throw new Exception();
}
 [Lines 49 - 53 ] {
    runner.run(ErrorTest.class);
    assertTrue(results.toString().startsWith(convert(".E\nTime: ")));
    assertTrue(results.toString().indexOf(convert("\nThere was 1 failure:\n1) error(org.junit.tests.listening.TextListenerTest$ErrorTest)\njava.lang.Exception")) != -1);
}
 [Lines 57 - 58 ] {
}
 [Lines 61 - 65 ] {
    runner.run(Time.class);
    assertThat(results.toString(), containsString("Time: "));
    assertThat(results.toString(), not(containsString(convert("Time: \n"))));
}
 [Lines 67 - 72 ] {
    OutputStream resultsStream = new ByteArrayOutputStream();
    PrintStream writer = new PrintStream(resultsStream);
    writer.println();
    return string.replace("\n", resultsStream.toString());
}

/src/test/java/org/junit/tests/manipulation/FilterTest.java
===========================================================
 [Lines 14 - 16 ] {
    fName = name;
}
 [Lines 19 - 21 ] {
    return false;
}
 [Lines 24 - 26 ] {
    return fName;
}
 [Lines 30 - 35 ] {
    NamedFilter a = new NamedFilter("a");
    NamedFilter b = new NamedFilter("b");
    assertEquals("a and b", a.intersect(b).describe());
    assertEquals("b and a", b.intersect(a).describe());
}
 [Lines 38 - 41 ] {
    NamedFilter a = new NamedFilter("a");
    assertSame(a, a.intersect(a));
}
 [Lines 44 - 49 ] {
    NamedFilter a = new NamedFilter("a");
    assertSame(a, a.intersect(Filter.ALL));
    assertSame(a, Filter.ALL.intersect(a));
    assertSame(Filter.ALL, Filter.ALL.intersect(Filter.ALL));
}

/src/test/java/org/junit/tests/manipulation/FilterableTest.java
===============================================================
 [Lines 20 - 34 ] {
    super(klass);
    filter(new Filter() {

        @Override
        public boolean shouldRun(Description description) {
            return !description.getDisplayName().contains("skip");
        }

        @Override
        public String describe() {
            return "skip methods containing the word 'skip'";
        }
    });
}
 [Lines 40 - 42 ] {
    return Arrays.asList(new Object[] { 3 }, new Object[] { 4 });
}
 [Lines 44 - 45 ] {
}
 [Lines 48 - 50 ] {
    Assert.fail();
}
 [Lines 53 - 54 ] {
}
 [Lines 58 - 61 ] {
    Result result = JUnitCore.runClasses(FilteredTest.class);
    assertTrue(result.wasSuccessful());
}

/src/test/java/org/junit/tests/manipulation/SingleMethodTest.java
=================================================================
 [Lines 32 - 34 ] {
    count++;
}
 [Lines 37 - 38 ] {
}
 [Lines 41 - 42 ] {
}
 [Lines 46 - 53 ] {
    count = 0;
    Runner runner = Request.method(OneTimeSetup.class, "one").getRunner();
    Result result = new JUnitCore().run(runner);
    assertEquals(1, count);
    assertEquals(1, result.getRunCount());
}
 [Lines 58 - 60 ] {
    return Arrays.asList(new Object[] { 1 }, new Object[] { 2 });
}
 [Lines 62 - 63 ] {
}
 [Lines 66 - 67 ] {
}
 [Lines 71 - 78 ] {
    count = 0;
    Runner runner = Request.method(ParameterizedOneTimeSetup.class, "one[0]").getRunner();
    Result result = new JUnitCore().run(runner);
    assertEquals(1, result.getRunCount());
}
 [Lines 83 - 85 ] {
    return Arrays.asList(new Object[] { 1 }, new Object[] { 2 });
}
 [Lines 87 - 88 ] {
}
 [Lines 91 - 93 ] {
    count++;
}
 [Lines 96 - 97 ] {
}
 [Lines 102 - 106 ] {
    count = 0;
    JUnitCore.runClasses(ParameterizedOneTimeBeforeClass.class);
    assertEquals(1, count);
}
 [Lines 109 - 112 ] {
    Runner runner = Request.method(OneTimeSetup.class, "one").getRunner();
    assertEquals(1, runner.testCount());
}
 [Lines 115 - 119 ] {
    assertEquals(1, new JUnitCore().run(Request.method(OneTimeSetup.class, "thisMethodDontExist")).getFailureCount());
}
 [Lines 122 - 135 ] {
    Filterable runner = (Filterable) Request.aClass(OneTimeSetup.class).getRunner();
    runner.filter(new Filter() {

        @Override
        public boolean shouldRun(Description description) {
            return false;
        }

        @Override
        public String describe() {
            return null;
        }
    });
}
 [Lines 139 - 140 ] {
}
 [Lines 143 - 144 ] {
}
 [Lines 149 - 150 ] {
}
 [Lines 153 - 154 ] {
}
 [Lines 163 - 169 ] {
    Runner runner = Request.aClass(OneTwoSuite.class).filterWith(Description.createTestDescription(TestOne.class, "a")).getRunner();
    Description description = runner.getDescription();
    assertEquals(1, description.getChildren().size());
}
 [Lines 173 - 174 ] {
}
 [Lines 177 - 178 ] {
}
 [Lines 180 - 182 ] {
    return new JUnit4TestAdapter(HasSuiteMethod.class);
}
 [Lines 186 - 189 ] {
    int testCount = Request.method(HasSuiteMethod.class, "a").getRunner().getDescription().testCount();
    assertThat(testCount, is(1));
}

/src/test/java/org/junit/tests/manipulation/SortableTest.java
=============================================================
 [Lines 20 - 26 ] {
    return new Comparator<Description>() {

        public int compare(Description o1, Description o2) {
            return o1.getDisplayName().compareTo(o2.getDisplayName());
        }
    };
}
 [Lines 28 - 34 ] {
    return new Comparator<Description>() {

        public int compare(Description o1, Description o2) {
            return o2.getDisplayName().compareTo(o1.getDisplayName());
        }
    };
}
 [Lines 41 - 43 ] {
    log += "a";
}
 [Lines 46 - 48 ] {
    log += "b";
}
 [Lines 51 - 53 ] {
    log += "c";
}
 [Lines 57 - 59 ] {
    log = "";
}
 [Lines 62 - 67 ] {
    Request forward = Request.aClass(SortMe.class).sortWith(forward());
    new JUnitCore().run(forward);
    assertEquals("abc", log);
}
 [Lines 70 - 75 ] {
    Request backward = Request.aClass(SortMe.class).sortWith(backward());
    new JUnitCore().run(backward);
    assertEquals("cba", log);
}
 [Lines 81 - 83 ] {
    log += "Aa";
}
 [Lines 86 - 88 ] {
    log += "Ab";
}
 [Lines 91 - 93 ] {
    log += "Ac";
}
 [Lines 98 - 100 ] {
    log += "Ba";
}
 [Lines 103 - 105 ] {
    log += "Bb";
}
 [Lines 108 - 110 ] {
    log += "Bc";
}
 [Lines 115 - 120 ] {
    Request forward = Request.aClass(Enclosing.class).sortWith(forward());
    new JUnitCore().run(forward);
    assertEquals("AaAbAcBaBbBc", log);
}
 [Lines 123 - 128 ] {
    Request backward = Request.aClass(Enclosing.class).sortWith(backward());
    new JUnitCore().run(backward);
    assertEquals("BcBbBaAcAbAa", log);
}
 [Lines 136 - 138 ] {
    log += "a";
}
 [Lines 141 - 143 ] {
    log += "b";
}
 [Lines 146 - 148 ] {
    log += "c";
}
 [Lines 150 - 152 ] {
    return new JUnit4TestAdapter(SortMe.class);
}
 [Lines 156 - 158 ] {
    log = "";
}
 [Lines 161 - 166 ] {
    Request forward = Request.aClass(SortMe.class).sortWith(forward());
    new JUnitCore().run(forward);
    assertEquals("abc", log);
}
 [Lines 169 - 174 ] {
    Request backward = Request.aClass(SortMe.class).sortWith(backward());
    new JUnitCore().run(backward);
    assertEquals("cba", log);
}
 [Lines 179 - 180 ] {
}
 [Lines 183 - 185 ] {
    return Description.EMPTY;
}
 [Lines 188 - 189 ] {
}
 [Lines 195 - 196 ] {
}
 [Lines 200 - 203 ] {
    Request unsorted = Request.aClass(Unsortable.class).sortWith(forward());
    new JUnitCore().run(unsorted);
}

/src/test/java/org/junit/tests/TestSystem.java
==============================================
 [Lines 14 - 17 ] {
    fOutContents = new ByteArrayOutputStream();
    out = new PrintStream(fOutContents);
}
 [Lines 23 - 25 ] {
    fCode = code;
}
 [Lines 27 - 29 ] {
    return out;
}
 [Lines 31 - 33 ] {
    return fOutContents;
}

/src/test/java/org/junit/tests/internal/runners/statements/FailOnTimeoutTest.java
=================================================================================
 [Lines 39 - 42 ] {
    thrown.expect(TestTimedOutException.class);
    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
}
 [Lines 45 - 48 ] {
    thrown.expectMessage("test timed out after 100 milliseconds");
    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
}
 [Lines 51 - 55 ] {
    RuntimeException exception = new RuntimeException();
    thrown.expect(is(exception));
    evaluateWithException(exception);
}
 [Lines 59 - 63 ] {
    thrown.expect(TestTimedOutException.class);
    evaluateWithWaitDuration(0);
    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
}
 [Lines 67 - 74 ] {
    thrown.expectMessage("test timed out after 100 milliseconds");
    try {
        evaluateWithException(new RuntimeException());
    } catch (Throwable expected) {
    }
    evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
}
 [Lines 78 - 86 ] {
    try {
        evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT);
        fail("No exception was thrown when test timed out");
    } catch (TestTimedOutException e) {
        assertEquals(TIMEOUT, e.getTimeout());
        assertEquals(TimeUnit.MILLISECONDS, e.getTimeUnit());
    }
}
 [Lines 88 - 92 ] {
    statement.nextException = exception;
    statement.waitDuration = 0;
    failOnTimeout.evaluate();
}
 [Lines 94 - 98 ] {
    statement.nextException = null;
    statement.waitDuration = waitDuration;
    failOnTimeout.evaluate();
}
 [Lines 106 - 111 ] {
    sleep(waitDuration);
    if (nextException != null) {
        throw nextException;
    }
}
 [Lines 115 - 127 ] {
    InfiniteLoopStatement infiniteLoop = new InfiniteLoopStatement();
    FailOnTimeout infiniteLoopTimeout = builder().withTimeout(TIMEOUT, MILLISECONDS).build(infiniteLoop);
    try {
        infiniteLoopTimeout.evaluate();
    } catch (Exception timeoutException) {
        // time to interrupt the thread
        sleep(20);
        int firstCount = InfiniteLoopStatement.COUNT;
        // time to increment the count
        sleep(20);
        assertTrue("Thread has not been stopped.", firstCount == InfiniteLoopStatement.COUNT);
    }
}
 [Lines 133 - 138 ] {
    while (true) {
        // sleep in order to enable interrupting thread
        sleep(10);
        ++COUNT;
    }
}
 [Lines 142 - 169 ] {
    StuckStatement stuck = new StuckStatement();
    FailOnTimeout stuckTimeout = builder().withTimeout(TIMEOUT, MILLISECONDS).build(stuck);
    try {
        stuckTimeout.evaluate();
        // We must not get here, we expect a timeout exception
        fail("Expected timeout exception");
    } catch (Exception timeoutException) {
        StackTraceElement[] stackTrace = timeoutException.getStackTrace();
        boolean stackTraceContainsTheRealCauseOfTheTimeout = false;
        boolean stackTraceContainsOtherThanTheRealCauseOfTheTimeout = false;
        for (StackTraceElement element : stackTrace) {
            String methodName = element.getMethodName();
            if ("theRealCauseOfTheTimeout".equals(methodName)) {
                stackTraceContainsTheRealCauseOfTheTimeout = true;
            }
            if ("notTheRealCauseOfTheTimeout".equals(methodName)) {
                stackTraceContainsOtherThanTheRealCauseOfTheTimeout = true;
            }
        }
        assertTrue("Stack trace does not contain the real cause of the timeout", stackTraceContainsTheRealCauseOfTheTimeout);
        assertFalse("Stack trace contains other than the real cause of the timeout, which can be very misleading", stackTraceContainsOtherThanTheRealCauseOfTheTimeout);
    }
}
 [Lines 174 - 183 ] {
    try {
        // Must show up in stack trace
        theRealCauseOfTheTimeout();
    } catch (InterruptedException e) {
    } finally {
        // Must _not_ show up in stack trace
        notTheRealCauseOfTheTimeout();
    }
}
 [Lines 185 - 187 ] {
    sleep(MAX_VALUE);
}
 [Lines 189 - 194 ] {
    for (long now = currentTimeMillis(), eta = now + 1000L; now < eta; now = currentTimeMillis()) {
        // Doesn't matter, just pretend to be busy
        atan(now);
    }
}

/src/test/java/org/junit/tests/internal/runners/ErrorReportingRunnerTest.java
=============================================================================
 [Lines 9 - 11 ] {
    new ErrorReportingRunner(null, new RuntimeException());
}
 [Lines 14 - 16 ] {
    new ErrorReportingRunner(new RuntimeException(), (Class<?>) null);
}
 [Lines 19 - 21 ] {
    new ErrorReportingRunner(new RuntimeException(), (Class<?>[]) null);
}
 [Lines 24 - 26 ] {
    new ErrorReportingRunner(new RuntimeException());
}

/src/test/java/org/junit/tests/assertion/MultipleFailureExceptionTest.java
==========================================================================
 [Lines 25 - 27 ] {
    MultipleFailureException.assertEmpty(Collections.<Throwable>emptyList());
}
 [Lines 30 - 39 ] {
    Throwable exception = new ExpectedException("pesto");
    List<Throwable> errors = Collections.singletonList(exception);
    try {
        MultipleFailureException.assertEmpty(errors);
        fail();
    } catch (ExpectedException e) {
        assertSame(e, exception);
    }
}
 [Lines 42 - 51 ] {
    Throwable exception = new AnnotationFormatError("changeo");
    List<Throwable> errors = Collections.singletonList(exception);
    try {
        MultipleFailureException.assertEmpty(errors);
        fail();
    } catch (AnnotationFormatError e) {
        assertSame(e, exception);
    }
}
 [Lines 54 - 68 ] {
    List<Throwable> errors = new ArrayList<Throwable>();
    errors.add(new ExpectedException("basil"));
    errors.add(new RuntimeException("garlic"));
    try {
        MultipleFailureException.assertEmpty(errors);
        fail();
    } catch (MultipleFailureException expected) {
        assertThat(expected.getFailures(), equalTo(errors));
        assertTrue(expected.getMessage().startsWith("There were 2 errors:\n"));
        assertTrue(expected.getMessage().contains("ExpectedException(basil)\n"));
        assertTrue(expected.getMessage().contains("RuntimeException(garlic)"));
    }
}
 [Lines 74 - 76 ] {
    super(message);
}

/src/test/java/org/junit/tests/assertion/ComparisonFailureTest.java
===================================================================
 [Lines 19 - 23 ] {
    expected = e;
    actual = a;
    message = m;
}
 [Lines 26 - 70 ] {
    return Arrays.asList(new Object[][] { // simple base case
    { "a", "b", "expected:<[a]> but was:<[b]>" }, // common prefix
    { "ba", "bc", "expected:<b[a]> but was:<b[c]>" }, // common suffix
    { "ab", "cb", "expected:<[a]b> but was:<[c]b>" }, // common pre and suffix
    { "abc", "adc", "expected:<a[b]c> but was:<a[d]c>" }, // expected is subset of actual
    { "ab", "abc", "expected:<ab[]> but was:<ab[c]>" }, // expected is superset of actual
    { "abc", "ab", "expected:<ab[c]> but was:<ab[]>" }, // overlapping matches.
    { "abc", "abbc", "expected:<ab[]c> but was:<ab[b]c>" }, // long prefix yielding "..."
    { "01234567890123456789PRE:hello:POST", "01234567890123456789PRE:world:POST", "expected:<...4567890123456789PRE:[hello]:POST> but was:<...4567890123456789PRE:[world]:POST>" }, // long suffix	yielding "..."
    { "PRE:hello:01234567890123456789POST", "PRE:world:01234567890123456789POST", "expected:<PRE:[hello]:0123456789012345678...> but was:<PRE:[world]:0123456789012345678...>" }, // bug609972
    { "S&P500", "0", "expected:<[S&P50]0> but was:<[]0>" }, // empty expected string
    { "", "a", "expected:<[]> but was:<[a]>" }, // empty actual string
    { "a", "", "expected:<[a]> but was:<[]>" } });
}
 [Lines 73 - 76 ] {
    ComparisonFailure failure = new ComparisonFailure("", expected, actual);
    assertEquals(message, failure.getMessage());
}

/src/test/java/org/junit/tests/assertion/AssertionTest.java
===========================================================
 [Lines 38 - 40 ] {
    Assert.fail();
}
 [Lines 43 - 49 ] {
    try {
        Assert.fail();
    } catch (AssertionError exception) {
        assertEquals("java.lang.AssertionError", exception.toString());
    }
}
 [Lines 52 - 58 ] {
    try {
        Assert.fail("woops!");
    } catch (AssertionError exception) {
        assertEquals("java.lang.AssertionError: woops!", exception.toString());
    }
}
 [Lines 61 - 63 ] {
    assertArrayEquals((new Object[] { new Object() }), (new Object[] { new Object() }));
}
 [Lines 66 - 68 ] {
    assertArrayEquals("not equal", (new Object[] { new Object() }), (new Object[] { new Object() }));
}
 [Lines 71 - 77 ] {
    try {
        assertArrayEquals("not equal", null, (new Object[] { new Object() }));
    } catch (AssertionError exception) {
        assertEquals("not equal: expected array was null", exception.getMessage());
    }
}
 [Lines 80 - 86 ] {
    try {
        assertArrayEquals("not equal", (new Object[] { new Object() }), null);
    } catch (AssertionError exception) {
        assertEquals("not equal: actual array was null", exception.getMessage());
    }
}
 [Lines 89 - 95 ] {
    try {
        assertArrayEquals("not equal", (new Object[0]), (new Object[1]));
    } catch (AssertionError exception) {
        assertEquals("not equal: array lengths differed, expected.length=0 actual.length=1", exception.getMessage());
    }
}
 [Lines 98 - 100 ] {
    assertArrayEquals("not equal", (new Object[] { "this is a very long string in the middle of an array" }), (new Object[] { "this is another very long string in the middle of an array" }));
}
 [Lines 103 - 110 ] {
    try {
        assertArrayEquals((new Object[] { true }), (new Object[] { false }));
    } catch (AssertionError exception) {
        assertEquals("arrays first differed at element [0]; expected:<true> but was:<false>", exception.getMessage());
    }
}
 [Lines 113 - 121 ] {
    try {
        assertArrayEquals((new Object[] { true, true }), (new Object[] { true, false }));
    } catch (AssertionError exception) {
        assertEquals("arrays first differed at element [1]; expected:<true> but was:<false>", exception.getMessage());
    }
}
 [Lines 124 - 131 ] {
    try {
        assertArrayEquals("message", (new Object[] { true }), (new Object[] { false }));
    } catch (AssertionError exception) {
        assertEquals("message: arrays first differed at element [0]; expected:<true> but was:<false>", exception.getMessage());
    }
}
 [Lines 134 - 141 ] {
    try {
        assertArrayEquals("message", (new Object[] { true, true }), (new Object[] { true, false }));
        fail();
    } catch (AssertionError exception) {
        assertEquals("message: arrays first differed at element [1]; expected:<true> but was:<false>", exception.getMessage());
    }
}
 [Lines 144 - 146 ] {
    assertArrayEquals((new Object[][] { { true, true }, { false, false } }), (new Object[][] { { true, true }, { false, false } }));
}
 [Lines 149 - 153 ] {
    int[][] int1 = { { 1, 2, 3 }, { 4, 5, 6 } };
    int[][] int2 = { { 1, 2, 3 }, { 4, 5, 6 } };
    assertArrayEquals(int1, int2);
}
 [Lines 156 - 165 ] {
    assertArrayEquals(new boolean[] { true }, new boolean[] { true });
    assertArrayEquals(new byte[] { 1 }, new byte[] { 1 });
    assertArrayEquals(new char[] { 1 }, new char[] { 1 });
    assertArrayEquals(new short[] { 1 }, new short[] { 1 });
    assertArrayEquals(new int[] { 1 }, new int[] { 1 });
    assertArrayEquals(new long[] { 1 }, new long[] { 1 });
    assertArrayEquals(new double[] { 1.0 }, new double[] { 1.0 }, 1.0);
    assertArrayEquals(new float[] { 1.0f }, new float[] { 1.0f }, 1.0f);
}
 [Lines 168 - 170 ] {
    assertArrayEquals(new double[] { 1.0 }, new double[] { 2.5 }, 1.0);
}
 [Lines 173 - 175 ] {
    assertArrayEquals(new float[] { 1.0f }, new float[] { 2.5f }, 1.0f);
}
 [Lines 178 - 180 ] {
    assertArrayEquals(new boolean[] { true }, new boolean[] { false });
}
 [Lines 183 - 185 ] {
    assertEquals(new Integer(1), new Long(1));
}
 [Lines 188 - 190 ] {
    assertEquals(1, 1L);
}
 [Lines 193 - 195 ] {
    assertArrayEquals((new Object[] { new Object[] { true, true }, new Object[] { false, false } }), (new Object[] { new Object[] { true, true }, new Object[] { false, false } }));
}
 [Lines 198 - 205 ] {
    try {
        assertArrayEquals("message", (new Object[][] { { true, true }, { false, false } }), (new Object[][] { { true, true }, { true, false } }));
        fail();
    } catch (AssertionError exception) {
        assertEquals("message: arrays first differed at element [1][0]; expected:<false> but was:<true>", exception.getMessage());
    }
}
 [Lines 208 - 215 ] {
    try {
        assertArrayEquals((new Object[][] { { true, true }, { false, false } }), (new Object[][] { { true, true }, { true, false } }));
        fail();
    } catch (AssertionError exception) {
        assertEquals("arrays first differed at element [1][0]; expected:<false> but was:<true>", exception.getMessage());
    }
}
 [Lines 218 - 227 ] {
    try {
        assertArrayEquals("message", new Object[][] { { true, true }, { false, false } }, new Object[][] { { true, true }, { false } });
    } catch (AssertionError exception) {
        assertEquals("message: arrays first differed at element [1]; array lengths differed, expected.length=2 actual.length=1", exception.getMessage());
        return;
    }
    fail("Expected AssertionError to be thrown");
}
 [Lines 230 - 239 ] {
    try {
        assertArrayEquals(new Object[][] { { true, true }, { false, false } }, new Object[][] { { true, true }, { false } });
    } catch (AssertionError exception) {
        assertEquals("arrays first differed at element [1]; array lengths differed, expected.length=2 actual.length=1", exception.getMessage());
        return;
    }
    fail("Expected AssertionError to be thrown");
}
 [Lines 242 - 246 ] {
    Object[] objects1 = new Object[] { null };
    Object[] objects2 = new Object[] { null };
    assertArrayEquals(objects1, objects2);
}
 [Lines 249 - 255 ] {
    try {
        assertEquals("not equal", "one", "two");
    } catch (Throwable exception) {
        assertEquals("not equal expected:<[one]> but was:<[two]>", exception.getMessage());
    }
}
 [Lines 258 - 263 ] {
    Object element = new Object();
    Object[] objects1 = new Object[] { element };
    Object[] objects2 = new Object[] { element };
    assertArrayEquals(objects1, objects2);
}
 [Lines 266 - 271 ] {
    Object element = new Object();
    Object[] objects1 = new Object[] { element };
    Object[] objects2 = new Object[] { element };
    assertArrayEquals("equal", objects1, objects2);
}
 [Lines 274 - 286 ] {
    Object o = new Object();
    assertEquals(o, o);
    assertEquals("abc", "abc");
    assertEquals(true, true);
    assertEquals((byte) 1, (byte) 1);
    assertEquals('a', 'a');
    assertEquals((short) 1, (short) 1);
    // int by default, cast is unnecessary
    assertEquals(1, 1);
    assertEquals(1l, 1l);
    assertEquals(1.0, 1.0, 0.0);
    assertEquals(1.0d, 1.0d, 0.0d);
}
 [Lines 289 - 291 ] {
    assertEquals(new Object(), null);
}
 [Lines 294 - 296 ] {
    assertEquals(null, new Object());
}
 [Lines 299 - 307 ] {
    Object o = new Object();
    try {
        assertEquals("message", null, o);
        fail();
    } catch (AssertionError e) {
        assertEquals("message expected:<null> but was:<" + o.toString() + ">", e.getMessage());
    }
}
 [Lines 310 - 318 ] {
    Object o = new Object();
    try {
        assertEquals("message", o, null);
        fail();
    } catch (AssertionError e) {
        assertEquals("message expected:<" + o.toString() + "> but was:<null>", e.getMessage());
    }
}
 [Lines 321 - 323 ] {
    assertEquals(new Object(), new Object());
}
 [Lines 326 - 328 ] {
    assertEquals("abc", "def");
}
 [Lines 331 - 333 ] {
    assertEquals(true, false);
}
 [Lines 336 - 338 ] {
    assertEquals((byte) 1, (byte) 2);
}
 [Lines 341 - 343 ] {
    assertEquals('a', 'b');
}
 [Lines 346 - 348 ] {
    assertEquals((short) 1, (short) 2);
}
 [Lines 351 - 353 ] {
    assertEquals(1, 2);
}
 [Lines 356 - 358 ] {
    assertEquals(1l, 2l);
}
 [Lines 361 - 363 ] {
    assertEquals(1.0, 2.0, 0.9);
}
 [Lines 367 - 369 ] {
    assertEquals(1.0, 1.1);
}
 [Lines 372 - 377 ] {
    float delta = 4.444f;
    float[] f1 = new float[] { 1.111f };
    float[] f2 = new float[] { 5.555f };
    Assert.assertArrayEquals(f1, f2, delta);
}
 [Lines 380 - 382 ] {
    assertEquals(new BigDecimal("123.4"), new BigDecimal("123.0"));
}
 [Lines 386 - 388 ] {
    assertEquals(1.0d, 2.0d, 0.9d);
}
 [Lines 391 - 394 ] {
    assertEquals(Float.NaN, Float.NaN, Float.POSITIVE_INFINITY);
    assertEquals(Double.NaN, Double.NaN, Double.POSITIVE_INFINITY);
}
 [Lines 398 - 405 ] {
    try {
        assertNull("junit");
        fail();
    } catch (AssertionError e) {
        assertEquals("expected null, but was:<junit>", e.getMessage());
    }
}
 [Lines 409 - 416 ] {
    try {
        assertNull("message", "hello");
        fail();
    } catch (AssertionError exception) {
        assertEquals("message expected null, but was:<hello>", exception.getMessage());
    }
}
 [Lines 419 - 422 ] {
    Object o1 = new Object();
    assertSame(o1, o1);
}
 [Lines 425 - 429 ] {
    Object o1 = new Object();
    Object o2 = new Object();
    assertNotSame(o1, o2);
}
 [Lines 432 - 434 ] {
    assertSame(new Object(), new Object());
}
 [Lines 437 - 440 ] {
    Object o = new Object();
    assertNotSame(o, o);
}
 [Lines 443 - 451 ] {
    try {
        assertSame("not same", "hello", "good-bye");
        fail();
    } catch (AssertionError exception) {
        assertEquals("not same expected same:<hello> was not:<good-bye>", exception.getMessage());
    }
}
 [Lines 454 - 461 ] {
    try {
        assertSame("hello", "good-bye");
        fail();
    } catch (AssertionError exception) {
        assertEquals("expected same:<hello> was not:<good-bye>", exception.getMessage());
    }
}
 [Lines 464 - 472 ] {
    Object o = new Object();
    try {
        assertNotSame("message", o, o);
        fail();
    } catch (AssertionError exception) {
        assertEquals("message expected not same", exception.getMessage());
    }
}
 [Lines 475 - 483 ] {
    Object o = new Object();
    try {
        assertNotSame(o, o);
        fail();
    } catch (AssertionError exception) {
        assertEquals("expected not same", exception.getMessage());
    }
}
 [Lines 486 - 493 ] {
    try {
        fail(null);
    } catch (AssertionError exception) {
        // we used to expect getMessage() to return ""; see failWithNoMessageToString()
        assertNull(exception.getMessage());
    }
}
 [Lines 496 - 503 ] {
    try {
        assertEquals(null, "a", "b");
        fail();
    } catch (ComparisonFailure e) {
        assertEquals("expected:<[a]> but was:<[b]>", e.getMessage());
    }
}
 [Lines 506 - 513 ] {
    try {
        assertEquals(null, 1, 2);
        fail();
    } catch (AssertionError e) {
        assertEquals("expected:<1> but was:<2>", e.getMessage());
    }
}
 [Lines 516 - 520 ] {
    Object a1 = new Object[] { "abc" };
    Object a2 = new Object[] { "abc" };
    assertEquals(a1, a2);
}
 [Lines 523 - 538 ] {
    byte b = 1;
    short s = 1;
    int i = 1;
    long l = 1L;
    float f = 1.0f;
    double d = 1.0;
    assertEquals(b, s);
    assertEquals(b, i);
    assertEquals(b, l);
    assertEquals(s, i);
    assertEquals(s, l);
    assertEquals(i, l);
    assertEquals(f, d, 0);
}
 [Lines 541 - 547 ] {
    try {
        assertEquals("4", new Integer(4));
    } catch (AssertionError e) {
        assertEquals("expected: java.lang.String<4> but was: java.lang.Integer<4>", e.getMessage());
    }
}
 [Lines 550 - 561 ] {
    String expected = "expected";
    String actual = "actual";
    String expectedMessage = "identifier\nExpected: \"expected\"\n     but: was \"actual\"";
    try {
        assertThat("identifier", actual, equalTo(expected));
    } catch (AssertionError e) {
        assertEquals(expectedMessage, e.getMessage());
    }
}
 [Lines 564 - 572 ] {
    String expectedMessage = "identifier\nExpected: is an instance of java.lang.Integer\n     but: \"actual\" is a java.lang.String";
    try {
        assertThat("identifier", "actual", is(instanceOf(Integer.class)));
    } catch (AssertionError e) {
        assertEquals(expectedMessage, e.getMessage());
    }
}
 [Lines 575 - 586 ] {
    String expected = "expected";
    String actual = "actual";
    String expectedMessage = "\nExpected: \"expected\"\n     but: was \"actual\"";
    try {
        assertThat(actual, equalTo(expected));
    } catch (AssertionError e) {
        assertEquals(expectedMessage, e.getMessage());
    }
}
 [Lines 589 - 595 ] {
    try {
        assertEquals(null, "null");
    } catch (AssertionError e) {
        assertEquals("expected: null<null> but was: java.lang.String<null>", e.getMessage());
    }
}
 [Lines 598 - 600 ] {
    assertEquals("null", null);
}
 [Lines 603 - 607 ] {
    final BigDecimal bigDecimal = new BigDecimal("1.2");
    final Integer integer = Integer.valueOf("1");
    assertEquals(bigDecimal, integer);
}
 [Lines 610 - 613 ] {
    Object o = new Object();
    assertNotEquals(o, o);
}
 [Lines 616 - 618 ] {
    assertNotEquals(new Object(), new Object());
}
 [Lines 621 - 634 ] {
    Integer value1 = new Integer(1);
    Integer value2 = new Integer(1);
    String message = "The values should be different";
    try {
        assertNotEquals(message, value1, value2);
    } catch (AssertionError e) {
        assertEquals(message + ". Actual: " + value1, e.getMessage());
        return;
    }
    fail("Failed on assertion.");
}
 [Lines 637 - 649 ] {
    Integer value1 = new Integer(1);
    Integer value2 = new Integer(1);
    try {
        assertNotEquals(value1, value2);
    } catch (AssertionError e) {
        assertTrue(e.getMessage().contains(value1.toString()));
        return;
    }
    fail("Failed on assertion.");
}
 [Lines 652 - 659 ] {
    assertNotEquals(1L, 2L);
    assertNotEquals("The values should be different", 1L, 2L);
    assertNotEquals(1.0, 2.0, 0);
    assertNotEquals("The values should be different", 1.0, 2.0, 0);
    assertNotEquals(1.0f, 2.0f, 0f);
    assertNotEquals("The values should be different", 1.0f, 2.0f, 0f);
}
 [Lines 662 - 664 ] {
    assertNotEquals(1.0, 0.9, 0.1);
}
 [Lines 667 - 669 ] {
    assertNotEquals(1.0f, 0.75f, 0.25f);
}
 [Lines 672 - 674 ] {
    assertNotEquals(Double.NaN, Double.NaN, 1);
}
 [Lines 677 - 679 ] {
    assertNotEquals(Float.NaN, Float.NaN, 1f);
}
 [Lines 682 - 684 ] {
    expectThrows(Throwable.class, nonThrowingRunnable());
}
 [Lines 687 - 695 ] {
    try {
        expectThrows(Throwable.class, nonThrowingRunnable());
    } catch (AssertionError ex) {
        assertEquals("expected Throwable to be thrown, but nothing was thrown", ex.getMessage());
        return;
    }
    fail();
}
 [Lines 698 - 704 ] {
    NullPointerException npe = new NullPointerException();
    Throwable throwable = expectThrows(Throwable.class, throwingRunnable(npe));
    assertSame(npe, throwable);
}
 [Lines 707 - 711 ] {
    NullPointerException npe = new NullPointerException();
    expectThrows(IOException.class, throwingRunnable(npe));
}
 [Lines 714 - 725 ] {
    NullPointerException npe = new NullPointerException("inner-message");
    try {
        expectThrows(IOException.class, throwingRunnable(npe));
    } catch (AssertionError ex) {
        assertSame(npe, ex.getCause());
        assertEquals("inner-message", ex.getCause().getMessage());
        return;
    }
    fail();
}
 [Lines 728 - 740 ] {
    NullPointerException npe = new NullPointerException();
    try {
        expectThrows(IOException.class, throwingRunnable(npe));
    } catch (AssertionError error) {
        assertEquals("unexpected exception type thrown; expected:<IOException> but was:<NullPointerException>", error.getMessage());
        assertSame(npe, error.getCause());
        return;
    }
    fail();
}
 [Lines 742 - 747 ] {
    return new ThrowingRunnable() {

        public void run() throws Throwable {
        }
    };
}
 [Lines 749 - 755 ] {
    return new ThrowingRunnable() {

        public void run() throws Throwable {
            throw t;
        }
    };
}

/src/test/java/org/junit/tests/junit3compatibility/AllTestsTest.java
====================================================================
 [Lines 20 - 22 ] {
    run = true;
}
 [Lines 27 - 31 ] {
    TestSuite suite = new TestSuite();
    suite.addTestSuite(OneTest.class);
    return suite;
}
 [Lines 35 - 40 ] {
    JUnitCore runner = new JUnitCore();
    // Have to explicitly set run here because the runner might independently run OneTest above
    run = false;
    runner.run(All.class);
    assertTrue(run);
}
 [Lines 43 - 46 ] {
    AllTests tests = new AllTests(All.class);
    assertEquals(1, tests.testCount());
}
 [Lines 49 - 52 ] {
    AllTests tests = new AllTests(All.class);
    assertThat(tests.getDescription().toString(), containsString("OneTest"));
}
 [Lines 56 - 58 ] {
    run = true;
}
 [Lines 63 - 67 ] {
    TestSuite suite = new TestSuite();
    suite.addTest(new JUnit4TestAdapter(JUnit4Test.class));
    return suite;
}
 [Lines 71 - 74 ] {
    AllTests tests = new AllTests(AllJUnit4.class);
    assertEquals(1, tests.testCount());
}
 [Lines 78 - 80 ] {
    throw new RuntimeException("can't construct");
}
 [Lines 84 - 86 ] {
    new AllTests(BadSuiteMethod.class);
}

/src/test/java/org/junit/tests/junit3compatibility/ClassRequestTest.java
========================================================================
 [Lines 10 - 12 ] {
    return null;
}
 [Lines 16 - 19 ] {
    assertNull(new SuiteMethodBuilder().runnerForClass(PrivateSuiteMethod.class));
}

/src/test/java/org/junit/tests/junit3compatibility/JUnit38ClassRunnerTest.java
==============================================================================
 [Lines 28 - 30 ] {
}
 [Lines 34 - 37 ] {
    JUnit38ClassRunner runner = new JUnit38ClassRunner(new TestDecorator(new TestSuite(MyTest.class)));
    assertEquals(1, runner.testCount());
}
 [Lines 41 - 43 ] {
    Assert.fail();
}
 [Lines 47 - 52 ] {
    JUnit38ClassRunner runner = new JUnit38ClassRunner(new JUnit4TestAdapter(AnnotatedTest.class));
    Result result = new JUnitCore().run(runner);
    Failure failure = result.getFailures().get(0);
    assertEquals(Description.createTestDescription(AnnotatedTest.class, "foo"), failure.getDescription());
}
 [Lines 57 - 58 ] {
}
 [Lines 62 - 78 ] {
    JUnitCore runner = new JUnitCore();
    RunListener listener = new RunListener() {

        @Override
        public void testStarted(Description description) {
            assertEquals(Description.createTestDescription(OneTest.class, "testOne"), description);
            count++;
        }
    };
    runner.addListener(listener);
    count = 0;
    Result result = runner.run(OneTest.class);
    assertEquals(1, count);
    assertEquals(1, result.getRunCount());
}
 [Lines 82 - 83 ] {
}
 [Lines 87 - 92 ] {
    Result result = JUnitCore.runClasses(ClassWithInvalidMethod.class);
    Failure failure = result.getFailures().get(0);
    assertEquals("warning", failure.getDescription().getMethodName());
    assertEquals("junit.framework.TestSuite$1", failure.getDescription().getClassName());
}
 [Lines 101 - 102 ] {
}
 [Lines 104 - 105 ] {
}
 [Lines 112 - 115 ] {
    JUnit38ClassRunner runner = new JUnit38ClassRunner(JUnit3ClassWithAnnotatedMethod.class);
    assertAnnotationFiltering(runner);
}
 [Lines 118 - 121 ] {
    JUnit38ClassRunner runner = new JUnit38ClassRunner(DerivedAnnotatedMethod.class);
    assertAnnotationFiltering(runner);
}
 [Lines 123 - 133 ] {
    Description d = runner.getDescription();
    assertEquals(2, d.testCount());
    for (Description methodDesc : d.getChildren()) {
        if (methodDesc.getMethodName().equals("testAnnotated")) {
            assertNotNull(methodDesc.getAnnotation(MyAnnotation.class));
        } else {
            assertNull(methodDesc.getAnnotation(MyAnnotation.class));
        }
    }
}
 [Lines 137 - 139 ] {
    return description.isSuite();
}
 [Lines 142 - 144 ] {
    return "filter all";
}
 [Lines 151 - 154 ] {
    JUnit38ClassRunner runner = new JUnit38ClassRunner(OneTest.class);
    runner.filter(new RejectAllTestsFilter());
}

/src/test/java/org/junit/tests/junit3compatibility/OldTests.java
================================================================
 [Lines 9 - 11 ] {
    return junit.tests.AllTests.suite();
}

/src/test/java/org/junit/tests/junit3compatibility/InitializationErrorForwardCompatibilityTest.java
===================================================================================================
 [Lines 23 - 25 ] {
    throw new Exception(UNIQUE_ERROR_MESSAGE);
}
 [Lines 28 - 30 ] {
    return Description.EMPTY;
}
 [Lines 33 - 34 ] {
}
 [Lines 44 - 47 ] {
    fAdapter = new JUnit4TestAdapter(CantInitializeTests.class);
}
 [Lines 50 - 52 ] {
    assertEquals(1, fAdapter.getTests().size());
}
 [Lines 55 - 61 ] {
    TestResult result = new TestResult();
    fAdapter.run(result);
    assertEquals(1, result.errorCount());
    assertEquals(CantInitialize.UNIQUE_ERROR_MESSAGE, result.errors().nextElement().exceptionMessage());
}
 [Lines 66 - 68 ] {
    fError = test;
}
 [Lines 71 - 72 ] {
}
 [Lines 74 - 75 ] {
}
 [Lines 77 - 78 ] {
}
 [Lines 80 - 82 ] {
    return fError;
}
 [Lines 86 - 94 ] {
    junit.framework.Test shouldFail = fAdapter.getTests().get(0);
    TestResult result = new TestResult();
    ErrorRememberingListener listener = new ErrorRememberingListener();
    result.addListener(listener);
    fAdapter.run(result);
    assertNotNull(listener.getError());
    assertTrue(shouldFail == listener.getError());
}
 [Lines 97 - 100 ] {
    super(klass);
    throw new Exception();
}

/src/test/java/org/junit/tests/junit3compatibility/ForwardCompatibilityPrintingTest.java
========================================================================================
 [Lines 18 - 20 ] {
    super(writer);
}
 [Lines 26 - 28 ] {
    return "0";
}
 [Lines 31 - 55 ] {
    ByteArrayOutputStream output = new ByteArrayOutputStream();
    TestRunner runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));
    String expected = expected(new String[] { ".E", "Time: 0", "Errors here", "", "FAILURES!!!", "Tests run: 1,  Failures: 0,  Errors: 1", "" });
    ResultPrinter printer = new TestResultPrinter(new PrintStream(output)) {

        @Override
        public void printErrors(TestResult result) {
            getWriter().println("Errors here");
        }
    };
    runner.setPrinter(printer);
    TestSuite suite = new TestSuite();
    suite.addTest(new TestCase() {

        @Override
        public void runTest() throws Exception {
            throw new Exception();
        }
    });
    runner.doRun(suite);
    assertEquals(expected, output.toString());
}
 [Lines 59 - 61 ] {
    Assert.fail();
}
 [Lines 64 - 81 ] {
    ByteArrayOutputStream output = new ByteArrayOutputStream();
    TestRunner runner = new TestRunner(new TestResultPrinter(new PrintStream(output)));
    String expected = expected(new String[] { ".E", "Time: 0", "Errors here", "", "FAILURES!!!", "Tests run: 1,  Failures: 0,  Errors: 1", "" });
    ResultPrinter printer = new TestResultPrinter(new PrintStream(output)) {

        @Override
        public void printErrors(TestResult result) {
            getWriter().println("Errors here");
        }
    };
    runner.setPrinter(printer);
    runner.doRun(new JUnit4TestAdapter(ATest.class));
    assertEquals(expected, output.toString());
}
 [Lines 83 - 90 ] {
    OutputStream expected = new ByteArrayOutputStream();
    PrintStream expectedWriter = new PrintStream(expected);
    for (int i = 0; i < lines.length; i++) {
        expectedWriter.println(lines[i]);
    }
    return expected.toString();
}

/src/test/java/org/junit/tests/junit3compatibility/ForwardCompatibilityTest.java
================================================================================
 [Lines 24 - 26 ] {
    fLog += "before ";
}
 [Lines 29 - 31 ] {
    fLog += "after ";
}
 [Lines 34 - 36 ] {
    fLog += "test ";
}
 [Lines 39 - 45 ] {
    fLog = "";
    TestResult result = new TestResult();
    junit.framework.Test adapter = new JUnit4TestAdapter(NewTest.class);
    adapter.run(result);
    assertEquals("before test after ", fLog);
}
 [Lines 47 - 51 ] {
    JUnit4TestAdapter adapter = new JUnit4TestAdapter(NewTest.class);
    junit.framework.Test test = adapter.getTests().get(0);
    assertEquals(String.format("test(%s)", NewTest.class.getName()), test.toString());
}
 [Lines 53 - 57 ] {
    JUnit4TestAdapter adapter1 = new JUnit4TestAdapter(NewTest.class);
    JUnit4TestAdapter adapter2 = new JUnit4TestAdapter(NewTest.class);
    assertSame(adapter1.getTests().get(0), adapter2.getTests().get(0));
}
 [Lines 63 - 65 ] {
    throw exception;
}
 [Lines 68 - 73 ] {
    TestResult result = new TestResult();
    junit.framework.Test adapter = new JUnit4TestAdapter(ErrorTest.class);
    adapter.run(result);
    assertEquals(exception, result.errors().nextElement().thrownException());
}
 [Lines 75 - 100 ] {
    JUnit4TestAdapter adapter = new JUnit4TestAdapter(ErrorTest.class);
    TestResult result = new TestResult();
    final StringBuffer log = new StringBuffer();
    result.addListener(new TestListener() {

        public void startTest(junit.framework.Test test) {
            log.append(" start ").append(test);
        }

        public void endTest(junit.framework.Test test) {
            log.append(" end ").append(test);
        }

        public void addFailure(junit.framework.Test test, AssertionFailedError t) {
            log.append(" failure ").append(test);
        }

        public void addError(junit.framework.Test test, Throwable e) {
            log.append(" error " + test);
        }
    });
    adapter.run(result);
    String testName = String.format("error(%s)", ErrorTest.class.getName());
    assertEquals(String.format(" start %s error %s end %s", testName, testName, testName), log.toString());
}
 [Lines 105 - 106 ] {
}
 [Lines 109 - 114 ] {
    TestResult result = new TestResult();
    junit.framework.Test adapter = new JUnit4TestAdapter(NoExceptionTest.class);
    adapter.run(result);
    assertFalse(result.wasSuccessful());
}
 [Lines 118 - 120 ] {
    throw new Exception();
}
 [Lines 123 - 128 ] {
    TestResult result = new TestResult();
    junit.framework.Test adapter = new JUnit4TestAdapter(ExpectedTest.class);
    adapter.run(result);
    assertTrue(result.wasSuccessful());
}
 [Lines 132 - 134 ] {
    throw new Error();
}
 [Lines 141 - 143 ] {
    log += "before class ";
}
 [Lines 146 - 148 ] {
    log += "before ";
}
 [Lines 151 - 153 ] {
    log += "test ";
}
 [Lines 156 - 158 ] {
    log += "test ";
}
 [Lines 161 - 163 ] {
    log += "after ";
}
 [Lines 166 - 168 ] {
    log += "after class ";
}
 [Lines 171 - 177 ] {
    log = "";
    TestResult result = new TestResult();
    junit.framework.Test adapter = new JUnit4TestAdapter(BeforeClassTest.class);
    adapter.run(result);
    assertEquals("before class before test after before test after after class ", log);
}
 [Lines 181 - 183 ] {
    throw new Error();
}
 [Lines 186 - 187 ] {
}
 [Lines 190 - 195 ] {
    TestResult result = new TestResult();
    junit.framework.Test adapter = new JUnit4TestAdapter(ExceptionInBeforeTest.class);
    adapter.run(result);
    assertEquals(1, result.errorCount());
}
 [Lines 199 - 200 ] {
}
 [Lines 203 - 204 ] {
}
 [Lines 207 - 214 ] {
    TestResult result = new TestResult();
    junit.framework.Test adapter = new JUnit4TestAdapter(InvalidMethodTest.class);
    adapter.run(result);
    assertEquals(1, result.errorCount());
    TestFailure failure = result.errors().nextElement();
    assertTrue(failure.exceptionMessage().contains("Method shouldBeStatic() should be static"));
}
 [Lines 219 - 220 ] {
}
 [Lines 223 - 225 ] {
    wasRun = true;
}
 [Lines 228 - 230 ] {
    return 0;
}
 [Lines 233 - 235 ] {
    return Description.EMPTY;
}
 [Lines 242 - 248 ] {
    wasRun = false;
    TestResult result = new TestResult();
    junit.framework.Test adapter = new JUnit4TestAdapter(NoTests.class);
    adapter.run(result);
    assertTrue(wasRun);
}
 [Lines 250 - 253 ] {
    junit.framework.Test adapter = new JUnit4TestAdapter(NoTests.class);
    assertEquals(NoTests.class.getName(), adapter.toString());
}

/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java
=======================================================================
 [Lines 22 - 24 ] {
    super(name);
}
 [Lines 26 - 30 ] {
    TestSuite suite = new TestSuite();
    suite.addTest(new OldTest("notObviouslyATest"));
    return suite;
}
 [Lines 32 - 34 ] {
    wasRun = true;
}
 [Lines 38 - 42 ] {
    wasRun = false;
    JUnitCore.runClasses(OldTest.class);
    assertTrue(wasRun);
}
 [Lines 46 - 48 ] {
    wasRun = true;
}
 [Lines 50 - 52 ] {
    return new JUnit4TestAdapter(NewTest.class);
}
 [Lines 56 - 60 ] {
    wasRun = false;
    JUnitCore.runClasses(NewTest.class);
    assertTrue(wasRun);
}
 [Lines 66 - 67 ] {
}
 [Lines 69 - 71 ] {
    return new JUnit4TestAdapter(CompatibilityTest.class);
}
 [Lines 76 - 82 ] {
    Result result = JUnitCore.runClasses(CompatibilityTest.class);
    assertEquals(0, result.getIgnoreCount());
    Description description = Request.aClass(CompatibilityTest.class).getRunner().getDescription();
    assertEquals(0, description.getChildren().size());
}
 [Lines 86 - 88 ] {
    wasRun = true;
}
 [Lines 90 - 93 ] {
    fail("called with JUnit 4 runner");
    return null;
}
 [Lines 97 - 102 ] {
    wasRun = false;
    Result result = JUnitCore.runClasses(NewTestSuiteFails.class);
    assertEquals(1, result.getFailureCount());
    assertFalse(wasRun);
}
 [Lines 108 - 110 ] {
    wasRun = true;
}
 [Lines 114 - 116 ] {
    wasIgnoredRun = true;
}
 [Lines 118 - 120 ] {
    return new JUnit4TestAdapter(NewTestSuiteNotUsed.class);
}
 [Lines 124 - 133 ] {
    wasRun = false;
    NewTestSuiteNotUsed.wasIgnoredRun = false;
    Result res = JUnitCore.runClasses(NewTestSuiteNotUsed.class);
    assertTrue(wasRun);
    assertFalse(NewTestSuiteNotUsed.wasIgnoredRun);
    assertEquals(0, res.getFailureCount());
    assertEquals(1, res.getRunCount());
    assertEquals(0, res.getIgnoreCount());
}

/src/test/java/org/junit/tests/junit3compatibility/OldTestClassAdaptingListenerTest.java
========================================================================================
 [Lines 16 - 27 ] {
    Result result = new Result();
    RunListener listener = result.createListener();
    RunNotifier notifier = new RunNotifier();
    notifier.addFirstListener(listener);
    TestCase testCase = new TestCase() {
    };
    TestListener adaptingListener = new JUnit38ClassRunner(testCase).createAdaptingListener(notifier);
    adaptingListener.addFailure(testCase, new AssertionFailedError());
    assertEquals(1, result.getFailureCount());
}

/src/test/java/org/junit/tests/description/TestDescriptionMethodNameTest.java
=============================================================================
 [Lines 23 - 25 ] {
    this.methodName = methodName;
}
 [Lines 28 - 42 ] {
    return Arrays.asList(new Object[] { "simple" }, new Object[] { "with space" }, new Object[] { "[]!@#$%^&*()" }, new Object[] { "" }, new Object[] { "\t" }, new Object[] { "\n" }, new Object[] { "\r\n" }, new Object[] { "\r" }, new Object[] { "" }, new Object[] { " " }, new Object[] { " " });
}
 [Lines 45 - 49 ] {
    Description description = Description.createTestDescription("some-class-name", methodName);
    assertNotNull("Method name should be not null", description.getMethodName());
    assertEquals(methodName, description.getMethodName());
}

/src/test/java/org/junit/tests/description/TestDescriptionTest.java
===================================================================
 [Lines 11 - 13 ] {
    assertFalse(Description.createTestDescription(getClass(), "a").equals(new Integer(5)));
}
 [Lines 16 - 18 ] {
    assertTrue(Description.createSuiteDescription("Hello").equals(Description.createSuiteDescription("Hello")));
}
 [Lines 21 - 23 ] {
    assertFalse(Description.createSuiteDescription("Hello", 2).equals(Description.createSuiteDescription("Hello", 3)));
}

/src/test/java/org/junit/tests/description/SuiteDescriptionTest.java
====================================================================
 [Lines 18 - 24 ] {
    assertEquals(childless, anotherChildless);
    assertFalse(childless.equals(namedB));
    assertEquals(childless, twoKids);
    assertEquals(twoKids, anotherTwoKids);
    assertFalse(twoKids.equals(new Integer(5)));
}
 [Lines 27 - 30 ] {
    assertEquals(childless.hashCode(), anotherChildless.hashCode());
    assertFalse(childless.hashCode() == namedB.hashCode());
}
 [Lines 32 - 37 ] {
    Description twoKids = Description.createSuiteDescription("a");
    twoKids.addChild(Description.createTestDescription(getClass(), first));
    twoKids.addChild(Description.createTestDescription(getClass(), second));
    return twoKids;
}

/src/test/java/org/junit/tests/description/AnnotatedDescriptionTest.java
========================================================================
 [Lines 24 - 25 ] {
}
 [Lines 29 - 32 ] {
    assertTrue((describe(AnnotatedClass.class).getAnnotation(MyOwnAnnotation.class) != null));
}
 [Lines 35 - 38 ] {
    assertEquals(1, describe(ValueAnnotatedClass.class).getAnnotations().size());
}
 [Lines 43 - 44 ] {
}
 [Lines 48 - 50 ] {
    assertTrue((describe(IgnoredClass.class).getAnnotation(Ignore.class) != null));
}
 [Lines 60 - 61 ] {
}
 [Lines 65 - 69 ] {
    Description description = describe(ValueAnnotatedClass.class);
    assertEquals("hello", description.getAnnotation(ValuedAnnotation.class).value());
}
 [Lines 72 - 76 ] {
    Description description = describe(ValueAnnotatedClass.class);
    assertEquals("hello", description.childlessCopy().getAnnotation(ValuedAnnotation.class).value());
}
 [Lines 79 - 91 ] {
    Annotation annotation = new Ignore() {

        public String value() {
            return "message";
        }

        public Class<? extends Annotation> annotationType() {
            return Ignore.class;
        }
    };
    assertEquals(Ignore.class, annotation.annotationType());
}
 [Lines 93 - 95 ] {
    return Request.aClass(testClass).getRunner().getDescription();
}

/src/test/java/org/junit/tests/package-info.java
================================================

/src/test/java/org/junit/tests/validation/BadlyFormedClassesTest.java
=====================================================================
 [Lines 16 - 18 ] {
    throw new Exception("Thrown during construction");
}
 [Lines 21 - 26 ] {
/*
                * Empty test just to fool JUnit and IDEs into running this class as
                * a JUnit test
                */
}
 [Lines 34 - 36 ] {
}
 [Lines 39 - 40 ] {
}
 [Lines 50 - 53 ] {
    String message = exceptionMessageFrom(FaultyConstructor.class);
    assertEquals("Thrown during construction", message);
}
 [Lines 56 - 58 ] {
    assertEquals("No runnable methods", exceptionMessageFrom(NoTests.class));
}
 [Lines 61 - 64 ] {
    assertEquals("Method before should be public", exceptionMessageFrom(BadBeforeMethodWithLegacyRunner.class));
}
 [Lines 66 - 72 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(testClass);
    Failure failure = result.getFailures().get(0);
    String message = failure.getException().getMessage();
    return message;
}

/src/test/java/org/junit/tests/validation/anotherpackage/Super.java
===================================================================
 [Lines 7 - 8 ] {
}

/src/test/java/org/junit/tests/validation/anotherpackage/Sub.java
=================================================================

/src/test/java/org/junit/tests/validation/FailedConstructionTest.java
=====================================================================
 [Lines 12 - 14 ] {
    throw new RuntimeException();
}
 [Lines 17 - 18 ] {
}
 [Lines 22 - 27 ] {
    Result result = JUnitCore.runClasses(CantConstruct.class);
    Failure failure = result.getFailures().get(0);
    Description expected = Description.createTestDescription(CantConstruct.class, "foo");
    Assert.assertEquals(expected, failure.getDescription());
}

/src/test/java/org/junit/tests/validation/ValidationTest.java
=============================================================
 [Lines 14 - 16 ] {
    return 0;
}
 [Lines 20 - 23 ] {
    assertEquals(WrongBeforeClass.class.getName(), Request.aClass(WrongBeforeClass.class).getRunner().getDescription().getDisplayName());
}
 [Lines 27 - 28 ] {
}
 [Lines 31 - 32 ] {
}
 [Lines 36 - 39 ] {
    Result result = JUnitCore.runClasses(NonStaticBeforeClass.class);
    assertEquals("Method before() should be static", result.getFailures().get(0).getMessage());
}

/src/test/java/org/junit/tests/ObjectContractTest.java
======================================================
 [Lines 26 - 29 ] {
    assumeNotNull(a);
    a.equals(b);
}
 [Lines 32 - 36 ] {
    assumeNotNull(a, b);
    assumeThat(a, is(b));
    assertThat(a.hashCode(), is(b.hashCode()));
}
 [Lines 38 - 45 ] {
    try {
        return Object.class.getMethod("toString");
    } catch (SecurityException e) {
    } catch (NoSuchMethodException e) {
    }
    return null;
}

/src/test/java/org/junit/tests/deprecated/JUnit4ClassRunnerTest.java
====================================================================
 [Lines 24 - 25 ] {
}
 [Lines 28 - 30 ] {
    fail();
}
 [Lines 34 - 38 ] {
    Result result = JUnitCore.runClasses(Example.class);
    assertThat(result.getRunCount(), is(2));
    assertThat(result.getFailureCount(), is(1));
}
 [Lines 43 - 45 ] {
    throw new UnsupportedOperationException();
}
 [Lines 48 - 49 ] {
}
 [Lines 52 - 54 ] {
    fail();
}
 [Lines 59 - 63 ] {
    Result result = JUnitCore.runClasses(UnconstructableExample.class);
    assertThat(result.getRunCount(), is(2));
    assertThat(result.getFailureCount(), is(2));
}

/src/test/java/org/junit/internal/builders/AnnotatedBuilderTest.java
====================================================================
 [Lines 18 - 21 ] {
    Runner runner = builder.runnerForClass(Object.class);
    assertThat(runner, is(nullValue()));
}
 [Lines 24 - 30 ] {
    Runner runner = builder.runnerForClass(OuterClass.class);
    assertThat(runner, is(instanceOf(RunnerSpy.class)));
    RunnerSpy runnerSpy = (RunnerSpy) runner;
    assertThat(runnerSpy.getInvokedTestClass(), is((Object) OuterClass.class));
}
 [Lines 33 - 39 ] {
    Runner runner = builder.runnerForClass(OuterClass.InnerClassWithoutOwnRunWith.class);
    assertThat(runner, is(instanceOf(RunnerSpy.class)));
    RunnerSpy runnerSpy = (RunnerSpy) runner;
    assertThat(runnerSpy.getInvokedTestClass(), is((Object) OuterClass.InnerClassWithoutOwnRunWith.class));
}
 [Lines 42 - 48 ] {
    Runner runner = builder.runnerForClass(OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class);
    assertThat(runner, is(instanceOf(RunnerSpy.class)));
    RunnerSpy runnerSpy = (RunnerSpy) runner;
    assertThat(runnerSpy.getInvokedTestClass(), is((Object) OuterClass.InnerClassWithoutOwnRunWith.MostInnerClass.class));
}
 [Lines 51 - 57 ] {
    Runner runner = builder.runnerForClass(OuterClass.InnerClassWithOwnRunWith.class);
    assertThat(runner, is(instanceOf(InnerRunner.class)));
    RunnerSpy runnerSpy = (RunnerSpy) runner;
    assertThat(runnerSpy.getInvokedTestClass(), is((Object) OuterClass.InnerClassWithOwnRunWith.class));
}
 [Lines 60 - 66 ] {
    Runner runner = builder.runnerForClass(OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class);
    assertThat(runner, is(instanceOf(InnerRunner.class)));
    RunnerSpy runnerSpy = (RunnerSpy) runner;
    assertThat(runnerSpy.getInvokedTestClass(), is((Object) OuterClass.InnerClassWithOwnRunWith.MostInnerClass.class));
}
 [Lines 72 - 73 ] {
}
 [Lines 77 - 78 ] {
}
 [Lines 85 - 86 ] {
}
 [Lines 90 - 91 ] {
}
 [Lines 97 - 99 ] {
    super(testClass);
}
 [Lines 101 - 103 ] {
    super(testClass, runnerBuilder);
}

/src/test/java/org/junit/internal/MethodSorterTest.java
=======================================================
 [Lines 26 - 28 ] {
    return null;
}
 [Lines 30 - 31 ] {
}
 [Lines 33 - 35 ] {
    return 0;
}
 [Lines 37 - 38 ] {
}
 [Lines 40 - 41 ] {
}
 [Lines 43 - 44 ] {
}
 [Lines 48 - 49 ] {
}
 [Lines 53 - 54 ] {
}
 [Lines 57 - 70 ] {
    Method[] actualMethods = MethodSorter.getDeclaredMethods(clazz);
    // Obtain just the names instead of the full methods.
    List<String> names = new ArrayList<String>();
    for (Method m : actualMethods) {
        // Filter out synthetic methods from, e.g., coverage tools.
        if (!m.isSynthetic()) {
            names.add(m.toString().replace(clazz.getName() + '.', ""));
        }
    }
    return names;
}
 [Lines 73 - 77 ] {
    List<String> expected = Arrays.asList(EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN);
    List<String> actual = getDeclaredMethodNames(DummySortWithoutAnnotation.class);
    assertEquals(expected, actual);
}
 [Lines 80 - 84 ] {
    List<String> expected = Arrays.asList(SUPER_METHOD);
    List<String> actual = getDeclaredMethodNames(Super.class);
    assertEquals(expected, actual);
}
 [Lines 87 - 91 ] {
    List<String> expected = Arrays.asList(SUB_METHOD);
    List<String> actual = getDeclaredMethodNames(Sub.class);
    assertEquals(expected, actual);
}
 [Lines 95 - 97 ] {
    return null;
}
 [Lines 99 - 100 ] {
}
 [Lines 102 - 104 ] {
    return 0;
}
 [Lines 106 - 107 ] {
}
 [Lines 109 - 110 ] {
}
 [Lines 112 - 113 ] {
}
 [Lines 117 - 121 ] {
    List<String> expected = Arrays.asList(EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN);
    List<String> actual = getDeclaredMethodNames(DummySortWithDefault.class);
    assertEquals(expected, actual);
}
 [Lines 125 - 127 ] {
    return null;
}
 [Lines 129 - 130 ] {
}
 [Lines 132 - 134 ] {
    return 0;
}
 [Lines 136 - 137 ] {
}
 [Lines 139 - 140 ] {
}
 [Lines 142 - 143 ] {
}
 [Lines 147 - 151 ] {
    Method[] fromJvmWithSynthetics = DummySortJvm.class.getDeclaredMethods();
    Method[] sorted = MethodSorter.getDeclaredMethods(DummySortJvm.class);
    assertArrayEquals(fromJvmWithSynthetics, sorted);
}
 [Lines 155 - 157 ] {
    return null;
}
 [Lines 159 - 160 ] {
}
 [Lines 162 - 164 ] {
    return 0;
}
 [Lines 166 - 167 ] {
}
 [Lines 169 - 170 ] {
}
 [Lines 172 - 173 ] {
}
 [Lines 177 - 181 ] {
    List<String> expected = Arrays.asList(ALPHA, BETA, DELTA, EPSILON, GAMMA_VOID, GAMMA_BOOLEAN);
    List<String> actual = getDeclaredMethodNames(DummySortWithNameAsc.class);
    assertEquals(expected, actual);
}

/src/test/java/org/junit/internal/matchers/ThrowableCauseMatcherTest.java
=========================================================================
 [Lines 12 - 17 ] {
    NullPointerException expectedCause = new NullPointerException("expected");
    Exception actual = new Exception(expectedCause);
    assertThat(actual, hasCause(is(expectedCause)));
}

/src/test/java/org/junit/internal/matchers/StacktracePrintingMatcherTest.java
=============================================================================
 [Lines 18 - 20 ] {
    assertTrue(isThrowable(any(Throwable.class)).matches(new Exception()));
}
 [Lines 23 - 25 ] {
    assertFalse(isException(notNullValue(Exception.class)).matches(null));
}
 [Lines 28 - 37 ] {
    Exception actual = new IllegalArgumentException("my message");
    Exception expected = new NullPointerException();
    try {
        assertThat(actual, isThrowable(equalTo(expected)));
    } catch (AssertionError e) {
        assertThat(e.getMessage(), containsString("Stacktrace was: java.lang.IllegalArgumentException: my message"));
    }
}

/src/test/java/org/junit/samples/ListTest.java
==============================================
 [Lines 22 - 24 ] {
    junit.textui.TestRunner.run(suite());
}
 [Lines 27 - 32 ] {
    fgHeavy = new ArrayList<Integer>();
    for (int i = 0; i < 1000; i++) {
        fgHeavy.add(i);
    }
}
 [Lines 35 - 41 ] {
    fEmpty = new ArrayList<Integer>();
    fFull = new ArrayList<Integer>();
    fFull.add(1);
    fFull.add(2);
    fFull.add(3);
}
 [Lines 43 - 45 ] {
    return new JUnit4TestAdapter(ListTest.class);
}
 [Lines 49 - 55 ] {
    int size = fFull.size();
    for (int i = 0; i < 100; i++) {
        fFull.add(i);
    }
    assertTrue(fFull.size() == 100 + size);
}
 [Lines 58 - 63 ] {
    List<Integer> copy = new ArrayList<Integer>(fFull.size());
    copy.addAll(fFull);
    assertTrue(copy.size() == fFull.size());
    assertTrue(copy.contains(1));
}
 [Lines 66 - 69 ] {
    assertTrue(fFull.contains(1));
    assertTrue(!fEmpty.contains(1));
}
 [Lines 72 - 76 ] {
    int i = fFull.get(0);
    assertTrue(i == 1);
    // Should throw IndexOutOfBoundsException
    fFull.get(fFull.size());
}
 [Lines 79 - 84 ] {
    fFull.removeAll(fFull);
    fEmpty.removeAll(fEmpty);
    assertTrue(fFull.isEmpty());
    assertTrue(fEmpty.isEmpty());
}
 [Lines 87 - 90 ] {
    fFull.remove(new Integer(3));
    assertTrue(!fFull.contains(3));
}

/src/test/java/org/junit/samples/SimpleTest.java
================================================
 [Lines 17 - 20 ] {
    fValue1 = 2;
    fValue2 = 3;
}
 [Lines 22 - 24 ] {
    return new JUnit4TestAdapter(SimpleTest.class);
}
 [Lines 29 - 33 ] {
    int zero = 0;
    int result = 8 / zero;
    // avoid warning for not using result
    unused = result;
}
 [Lines 36 - 43 ] {
    assertEquals(12, 12);
    assertEquals(12L, 12L);
    assertEquals(new Long(12), new Long(12));
    assertEquals("Size", 12, 13);
    assertEquals("Capacity", 12.0, 11.99, 0.0);
}

/src/test/java/org/junit/samples/money/MoneyTest.java
=====================================================
 [Lines 23 - 25 ] {
    return new JUnit4TestAdapter(MoneyTest.class);
}
 [Lines 28 - 36 ] {
    f12CHF = new Money(12, "CHF");
    f14CHF = new Money(14, "CHF");
    f7USD = new Money(7, "USD");
    f21USD = new Money(21, "USD");
    fMB1 = MoneyBag.create(f12CHF, f7USD);
    fMB2 = MoneyBag.create(f14CHF, f21USD);
}
 [Lines 39 - 45 ] {
    // {[12 CHF][7 USD]} *2 == {[24 CHF][14 USD]}
    IMoney expected = MoneyBag.create(new Money(24, "CHF"), new Money(14, "USD"));
    assertEquals(expected, fMB1.multiply(2));
    assertEquals(fMB1, fMB1.multiply(1));
    assertTrue(fMB1.multiply(0).isZero());
}
 [Lines 48 - 52 ] {
    // {[12 CHF][7 USD]} negate == {[-12 CHF][-7 USD]}
    IMoney expected = MoneyBag.create(new Money(-12, "CHF"), new Money(-7, "USD"));
    assertEquals(expected, fMB1.negate());
}
 [Lines 55 - 59 ] {
    // {[12 CHF][7 USD]} + [14 CHF] == {[26 CHF][7 USD]}
    IMoney expected = MoneyBag.create(new Money(26, "CHF"), new Money(7, "USD"));
    assertEquals(expected, fMB1.add(f14CHF));
}
 [Lines 62 - 66 ] {
    // {[12 CHF][7 USD]} - {[14 CHF][21 USD] == {[-2 CHF][-14 USD]}
    IMoney expected = MoneyBag.create(new Money(-2, "CHF"), new Money(-14, "USD"));
    assertEquals(expected, fMB1.subtract(fMB2));
}
 [Lines 69 - 73 ] {
    // {[12 CHF][7 USD]} + {[14 CHF][21 USD]} == {[26 CHF][28 USD]}
    IMoney expected = MoneyBag.create(new Money(26, "CHF"), new Money(28, "USD"));
    assertEquals(expected, fMB1.add(fMB2));
}
 [Lines 76 - 79 ] {
    assertTrue(fMB1.subtract(fMB1).isZero());
    assertTrue(MoneyBag.create(new Money(0, "CHF"), new Money(0, "USD")).isZero());
}
 [Lines 82 - 86 ] {
    // [12 CHF] + [7 USD] == {[12 CHF][7 USD]}
    IMoney expected = MoneyBag.create(f12CHF, f7USD);
    assertEquals(expected, f12CHF.add(f7USD));
}
 [Lines 89 - 92 ] {
    IMoney bag = MoneyBag.create(f12CHF, f7USD);
    assertFalse(bag.equals(new Money(12, "DEM").add(f7USD)));
}
 [Lines 95 - 104 ] {
    assertTrue(!fMB1.equals(null));
    assertEquals(fMB1, fMB1);
    IMoney equal = MoneyBag.create(new Money(12, "CHF"), new Money(7, "USD"));
    assertTrue(fMB1.equals(equal));
    assertTrue(!fMB1.equals(f12CHF));
    assertTrue(!f12CHF.equals(fMB1));
    assertTrue(!fMB1.equals(fMB2));
}
 [Lines 107 - 110 ] {
    IMoney equal = MoneyBag.create(new Money(12, "CHF"), new Money(7, "USD"));
    assertEquals(fMB1.hashCode(), equal.hashCode());
}
 [Lines 113 - 120 ] {
    assertTrue(!f12CHF.equals(null));
    Money equalMoney = new Money(12, "CHF");
    assertEquals(f12CHF, f12CHF);
    assertEquals(f12CHF, equalMoney);
    assertEquals(f12CHF.hashCode(), equalMoney.hashCode());
    assertTrue(!f12CHF.equals(f14CHF));
}
 [Lines 123 - 129 ] {
    Money zeroDollars = new Money(0, "USD");
    Money zeroFrancs = new Money(0, "CHF");
    assertEquals(zeroDollars, zeroFrancs);
    assertEquals(zeroDollars.hashCode(), zeroFrancs.hashCode());
}
 [Lines 132 - 136 ] {
    assertTrue(!f12CHF.equals(null));
    Money equal = new Money(12, "CHF");
    assertEquals(f12CHF.hashCode(), equal.hashCode());
}
 [Lines 139 - 142 ] {
    IMoney money = MoneyBag.create(new Money(26, "CHF"), new Money(28, "CHF"));
    assertEquals(new Money(54, "CHF"), money);
}
 [Lines 145 - 149 ] {
    // {[12 CHF][7 USD]} - [12 CHF] == [7 USD]
    Money expected = new Money(7, "USD");
    assertEquals(expected, fMB1.subtract(f12CHF));
}
 [Lines 152 - 157 ] {
    // {[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]
    IMoney ms1 = MoneyBag.create(new Money(12, "CHF"), new Money(3, "USD"));
    Money expected = new Money(4, "USD");
    assertEquals(expected, fMB1.subtract(ms1));
}
 [Lines 160 - 164 ] {
    // [12 CHF] - {[12 CHF][3 USD]} == [-3 USD]
    IMoney ms1 = MoneyBag.create(new Money(12, "CHF"), new Money(3, "USD"));
    Money expected = new Money(-3, "USD");
    assertEquals(expected, f12CHF.subtract(ms1));
}
 [Lines 167 - 169 ] {
    assertEquals("[12 CHF]", f12CHF.toString());
}
 [Lines 172 - 176 ] {
    // [12 CHF] + [14 CHF] == [26 CHF]
    Money expected = new Money(26, "CHF");
    assertEquals(expected, f12CHF.add(f14CHF));
}
 [Lines 179 - 183 ] {
    // [14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}
    IMoney expected = MoneyBag.create(new Money(26, "CHF"), new Money(7, "USD"));
    assertEquals(expected, f14CHF.add(fMB1));
}
 [Lines 186 - 190 ] {
    // [14 CHF] *2 == [28 CHF]
    Money expected = new Money(28, "CHF");
    assertEquals(expected, f14CHF.multiply(2));
}
 [Lines 193 - 197 ] {
    // [14 CHF] negate == [-14 CHF]
    Money expected = new Money(-14, "CHF");
    assertEquals(expected, f14CHF.negate());
}
 [Lines 200 - 204 ] {
    // [14 CHF] - [12 CHF] == [2 CHF]
    Money expected = new Money(2, "CHF");
    assertEquals(expected, f14CHF.subtract(f12CHF));
}

/src/test/java/org/junit/samples/money/package-info.java
========================================================

/src/test/java/org/junit/samples/package-info.java
==================================================

/src/test/java/org/junit/AssumptionViolatedExceptionTest.java
=============================================================
 [Lines 27 - 31 ] {
    assumeThat(matcher, notNullValue());
    assertThat(new AssumptionViolatedException(actual, matcher).toString(), containsString(matcher.toString()));
}
 [Lines 34 - 37 ] {
    assertThat(new AssumptionViolatedException(actual, matcher).toString(), containsString(String.valueOf(actual)));
}
 [Lines 40 - 43 ] {
    AssumptionViolatedException e = new AssumptionViolatedException(3, is(2));
    assertThat(StringDescription.asString(e), is("got: <3>, expected: is <2>"));
}
 [Lines 46 - 49 ] {
    AssumptionViolatedException e = new AssumptionViolatedException("not enough money");
    assertThat(StringDescription.asString(e), is("not enough money"));
}
 [Lines 52 - 57 ] {
    AssumptionViolatedException e = new AssumptionViolatedException("invalid number");
    Throwable cause = new RuntimeException("cause");
    e.initCause(cause);
    assertThat(e.getCause(), is(cause));
}
 [Lines 61 - 67 ] {
    Throwable testObject = new Exception();
    org.junit.internal.AssumptionViolatedException e = new org.junit.internal.AssumptionViolatedException(testObject, containsString("test matcher"));
    assertThat(e.getCause(), is(testObject));
}
 [Lines 71 - 77 ] {
    Throwable testObject = new Exception();
    org.junit.internal.AssumptionViolatedException e = new org.junit.internal.AssumptionViolatedException("sample assumption", testObject, containsString("test matcher"));
    assertThat(e.getCause(), is(testObject));
}
 [Lines 81 - 87 ] {
    Throwable testObject = new Exception();
    org.junit.internal.AssumptionViolatedException e = new org.junit.internal.AssumptionViolatedException("sample assumption", false, testObject, containsString("test matcher"));
    assertThat(e.getCause(), is(testObject));
}
 [Lines 90 - 94 ] {
    Throwable cause = new Exception();
    AssumptionViolatedException e = new AssumptionViolatedException("invalid number", cause);
    assertThat(e.getCause(), is(cause));
}

/src/test/java/org/junit/rules/DisableOnDebugTest.java
======================================================
 [Lines 39 - 47 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            throw new AssertionError();
        }
    };
}
 [Lines 56 - 59 ] {
    this.failOnExecution = new DisableOnDebug(new FailOnExecution(), arguments);
}
 [Lines 62 - 63 ] {
}
 [Lines 69 - 71 ] {
    super(PRE_JAVA5_DEBUG_ARGUMENTS);
}
 [Lines 78 - 80 ] {
    super(PRE_JAVA5_DEBUG_ARGUMENTS_IN_REVERSE_ORDER);
}
 [Lines 87 - 89 ] {
    super(POST_JAVA5_DEBUG_ARGUMENTS);
}
 [Lines 96 - 98 ] {
    super(WITHOUT_DEBUG_ARGUMENTS);
}
 [Lines 103 - 107 ] {
    DisableOnDebug subject = new DisableOnDebug(new FailOnExecution(), PRE_JAVA5_DEBUG_ARGUMENTS);
    assertTrue("Should be debugging", subject.isDebugging());
}
 [Lines 110 - 115 ] {
    DisableOnDebug subject = new DisableOnDebug(new FailOnExecution(), PRE_JAVA5_DEBUG_ARGUMENTS_IN_REVERSE_ORDER);
    assertTrue("Should be debugging", subject.isDebugging());
}
 [Lines 118 - 122 ] {
    DisableOnDebug subject = new DisableOnDebug(new FailOnExecution(), POST_JAVA5_DEBUG_ARGUMENTS);
    assertTrue("Should be debugging", subject.isDebugging());
}
 [Lines 125 - 129 ] {
    DisableOnDebug subject = new DisableOnDebug(new FailOnExecution(), WITHOUT_DEBUG_ARGUMENTS);
    Assert.assertFalse("Should not be debugging", subject.isDebugging());
}
 [Lines 132 - 137 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(PreJava5DebugArgumentsTest.class);
    assertEquals("Should run the test", 1, result.getRunCount());
    assertEquals("Test should not have failed", 0, result.getFailureCount());
}
 [Lines 140 - 146 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(PreJava5DebugArgumentsReversedTest.class);
    assertEquals("Should run the test", 1, result.getRunCount());
    assertEquals("Test should not have failed", 0, result.getFailureCount());
}
 [Lines 149 - 154 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(PostJava5DebugArgumentsTest.class);
    assertEquals("Should run the test", 1, result.getRunCount());
    assertEquals("Test should not have failed", 0, result.getFailureCount());
}
 [Lines 157 - 162 ] {
    JUnitCore core = new JUnitCore();
    Result result = core.run(WithoutDebugArgumentsTest.class);
    assertEquals("Should run the test", 1, result.getRunCount());
    assertEquals("Test should have failed", 1, result.getFailureCount());
}

/src/test/java/org/junit/rules/StopwatchTest.java
=================================================
 [Lines 37 - 39 ] {
    this(0, null, null);
}
 [Lines 41 - 43 ] {
    this(duration, null, description);
}
 [Lines 45 - 49 ] {
    this.duration = duration;
    this.status = status;
    this.name = description == null ? null : description.getMethodName();
}
 [Lines 60 - 62 ] {
    return fakeTimeNanos++;
}
 [Lines 67 - 70 ] {
    StopwatchTest.record = new Record(nanos, TestStatus.SUCCEEDED, description);
    simulateTimePassing(1);
}
 [Lines 73 - 76 ] {
    StopwatchTest.record = new Record(nanos, TestStatus.FAILED, description);
    simulateTimePassing(1);
}
 [Lines 79 - 82 ] {
    StopwatchTest.record = new Record(nanos, TestStatus.SKIPPED, description);
    simulateTimePassing(1);
}
 [Lines 85 - 87 ] {
    StopwatchTest.finishedRecord = new Record(nanos, description);
}
 [Lines 92 - 94 ] {
    afterStopwatchRule();
}
 [Lines 102 - 103 ] {
}
 [Lines 108 - 109 ] {
}
 [Lines 114 - 116 ] {
    fail();
}
 [Lines 121 - 123 ] {
    assumeTrue(false);
}
 [Lines 128 - 133 ] {
    simulateTimePassing(300L);
    assertEquals(300L, stopwatch.runtime(MILLISECONDS));
    simulateTimePassing(500L);
    assertEquals(800L, stopwatch.runtime(MILLISECONDS));
}
 [Lines 138 - 141 ] {
    simulateTimePassing(300L);
    assertEquals(300L, stopwatch.runtime(MILLISECONDS));
}
 [Lines 144 - 148 ] {
    assertEquals(300L, stopwatch.runtime(MILLISECONDS));
    simulateTimePassing(500L);
    assertEquals(300L, stopwatch.runtime(MILLISECONDS));
}
 [Lines 152 - 156 ] {
    record = new Record();
    finishedRecord = new Record();
    simulateTimePassing(1L);
}
 [Lines 158 - 162 ] {
    simulateTimePassing(1L);
    JUnitCore junitCore = new JUnitCore();
    return junitCore.run(Request.aClass(test).getRunner());
}
 [Lines 164 - 166 ] {
    fakeTimeNanos += TimeUnit.MILLISECONDS.toNanos(millis);
}
 [Lines 169 - 177 ] {
    Result result = runTest(SuccessfulTest.class);
    assertEquals(0, result.getFailureCount());
    assertThat(record.name, is("successfulTest"));
    assertThat(record.name, is(finishedRecord.name));
    assertThat(record.status, is(TestStatus.SUCCEEDED));
    assertTrue("timeSpent > 0", record.duration > 0);
    assertThat(record.duration, is(finishedRecord.duration));
}
 [Lines 180 - 188 ] {
    Result result = runTest(FailedTest.class);
    assertEquals(1, result.getFailureCount());
    assertThat(record.name, is("failedTest"));
    assertThat(record.name, is(finishedRecord.name));
    assertThat(record.status, is(TestStatus.FAILED));
    assertTrue("timeSpent > 0", record.duration > 0);
    assertThat(record.duration, is(finishedRecord.duration));
}
 [Lines 191 - 199 ] {
    Result result = runTest(SkippedTest.class);
    assertEquals(0, result.getFailureCount());
    assertThat(record.name, is("skippedTest"));
    assertThat(record.name, is(finishedRecord.name));
    assertThat(record.status, is(TestStatus.SKIPPED));
    assertTrue("timeSpent > 0", record.duration > 0);
    assertThat(record.duration, is(finishedRecord.duration));
}
 [Lines 202 - 205 ] {
    Result result = runTest(DurationDuringTestTest.class);
    assertTrue(result.wasSuccessful());
}
 [Lines 208 - 211 ] {
    Result result = runTest(DurationAfterTestTest.class);
    assertTrue(result.wasSuccessful());
}

/src/test/java/org/junit/runners/parameterized/BlockJUnit4ClassRunnerWithParametersTest.java
============================================================================================
 [Lines 25 - 26 ] {
}
 [Lines 30 - 39 ] {
    TestWithParameters testWithParameters = new TestWithParameters("dummy name", new TestClass(ClassWithParameterizedAnnotation.class), NO_PARAMETERS);
    BlockJUnit4ClassRunnerWithParameters runner = new BlockJUnit4ClassRunnerWithParameters(testWithParameters);
    Annotation[] annotations = runner.getRunnerAnnotations();
    assertEquals(1, annotations.length);
    assertEquals(annotations[0].annotationType(), DummyAnnotation.class);
}

/src/test/java/org/junit/runners/parameterized/ParameterizedNamesTest.java
==========================================================================
 [Lines 22 - 23 ] {
}
 [Lines 26 - 35 ] {
    return Arrays.asList(new Object[] { "\n" }, new Object[] { "\r\n" }, new Object[] { "\r" }, new Object[] { "" }, new Object[] { " " }, new Object[] { " " });
}
 [Lines 38 - 39 ] {
}
 [Lines 43 - 50 ] {
    Request request = Request.aClass(ParametrizedWithSpecialCharsInName.class);
    for (Description parent : request.getRunner().getDescription().getChildren()) {
        for (Description description : parent.getChildren()) {
            assertEquals("test" + parent.getDisplayName(), description.getMethodName());
        }
    }
}

/src/test/java/org/junit/runners/parameterized/TestWithParametersTest.java
==========================================================================
 [Lines 29 - 33 ] {
    thrown.expect(NullPointerException.class);
    thrown.expectMessage("The name is missing.");
    new TestWithParameters(null, DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
}
 [Lines 36 - 40 ] {
    thrown.expect(NullPointerException.class);
    thrown.expectMessage("The test class is missing.");
    new TestWithParameters(DUMMY_NAME, null, DUMMY_PARAMETERS);
}
 [Lines 43 - 48 ] {
    thrown.expect(NullPointerException.class);
    thrown.expectMessage("The parameters are missing.");
    new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS, (List<Object>) null);
}
 [Lines 51 - 56 ] {
    TestWithParameters test = new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
    thrown.expect(UnsupportedOperationException.class);
    test.getParameters().set(0, "another parameter");
}
 [Lines 59 - 65 ] {
    List<Object> parameters = Arrays.<Object>asList("dummy parameter");
    TestWithParameters test = new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS, parameters);
    parameters.set(0, "another parameter");
    assertEquals(asList("dummy parameter"), test.getParameters());
}
 [Lines 68 - 76 ] {
    TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME, new TestClass(DummyClass.class), Arrays.<Object>asList("a", "b"));
    TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME, new TestClass(DummyClass.class), Arrays.<Object>asList("a", "b"));
    assertEquals(firstTest, secondTest);
}
 [Lines 79 - 85 ] {
    TestWithParameters firstTest = new TestWithParameters("name", DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
    TestWithParameters secondTest = new TestWithParameters("another name", DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
    assertNotEquals(firstTest, secondTest);
}
 [Lines 88 - 94 ] {
    TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME, new TestClass(DummyClass.class), DUMMY_PARAMETERS);
    TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME, new TestClass(AnotherDummyClass.class), DUMMY_PARAMETERS);
    assertNotEquals(firstTest, secondTest);
}
 [Lines 97 - 103 ] {
    TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS, Arrays.<Object>asList("a"));
    TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS, Arrays.<Object>asList("b"));
    assertNotEquals(firstTest, secondTest);
}
 [Lines 106 - 110 ] {
    TestWithParameters test = new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
    assertNotEquals(test, new Integer(3));
}
 [Lines 113 - 119 ] {
    TestWithParameters firstTest = new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
    TestWithParameters secondTest = new TestWithParameters(DUMMY_NAME, DUMMY_TEST_CLASS, DUMMY_PARAMETERS);
    assertEquals(firstTest.hashCode(), secondTest.hashCode());
}
 [Lines 122 - 130 ] {
    TestWithParameters test = new TestWithParameters("name", new TestClass(DummyClass.class), Arrays.<Object>asList("first parameter", "second parameter"));
    assertEquals("Wrong toString().", "org.junit.runners.parameterized.TestWithParametersTest$DummyClass 'name' with parameters [first parameter, second parameter]", test.toString());
}

/src/test/java/org/junit/runners/CustomBlockJUnit4ClassRunnerTest.java
======================================================================
 [Lines 26 - 35 ] {
    TrackingRunListener listener = new TrackingRunListener();
    RunNotifier notifier = new RunNotifier();
    notifier.addListener(listener);
    new CustomBlockJUnit4ClassRunner(CustomBlockJUnit4ClassRunnerTestCase.class).run(notifier);
    assertEquals("tests started.", 2, listener.testStartedCount.get());
    assertEquals("tests failed.", 1, listener.testFailureCount.get());
    assertEquals("tests finished.", 2, listener.testFinishedCount.get());
}
 [Lines 39 - 39 ] {
/* no-op */
}
 [Lines 40 - 40 ] {
/* no-op */
}
 [Lines 50 - 52 ] {
    super(testClass);
}
 [Lines 55 - 60 ] {
    if ("throwException".equals(method.getName())) {
        throw new RuntimeException("throwException() test method invoked");
    }
    return super.methodBlock(method);
}
 [Lines 75 - 77 ] {
    testStartedCount.incrementAndGet();
}
 [Lines 80 - 82 ] {
    testFailureCount.incrementAndGet();
}
 [Lines 85 - 87 ] {
    testFinishedCount.incrementAndGet();
}

/src/test/java/org/junit/runners/model/FrameworkMethodTest.java
===============================================================
 [Lines 22 - 26 ] {
    thrown.expect(NullPointerException.class);
    thrown.expectMessage("FrameworkMethod cannot be created without an underlying method.");
    new FrameworkMethod(null);
}
 [Lines 29 - 33 ] {
    Method method = ClassWithDummyMethod.class.getMethod("dummyMethod");
    FrameworkMethod frameworkMethod = new FrameworkMethod(method);
    assertTrue(frameworkMethod.toString().contains("dummyMethod"));
}
 [Lines 36 - 41 ] {
    Method method = ClassWithDummyMethod.class.getMethod("annotatedDummyMethod");
    FrameworkMethod frameworkMethod = new FrameworkMethod(method);
    Annotation annotation = frameworkMethod.getAnnotation(Rule.class);
    assertTrue(Rule.class.isAssignableFrom(annotation.getClass()));
}
 [Lines 44 - 49 ] {
    Method method = ClassWithDummyMethod.class.getMethod("annotatedDummyMethod");
    FrameworkMethod frameworkMethod = new FrameworkMethod(method);
    Annotation annotation = frameworkMethod.getAnnotation(ClassRule.class);
    assertThat(annotation, is(nullValue()));
}
 [Lines 53 - 54 ] {
}
 [Lines 57 - 58 ] {
}

/src/test/java/org/junit/runners/model/FrameworkFieldTest.java
==============================================================
 [Lines 22 - 26 ] {
    thrown.expect(NullPointerException.class);
    thrown.expectMessage("FrameworkField cannot be created without an underlying field.");
    new FrameworkField(null);
}
 [Lines 29 - 33 ] {
    Field field = ClassWithDummyField.class.getField("dummyField");
    FrameworkField frameworkField = new FrameworkField(field);
    assertTrue(frameworkField.toString().contains("dummyField"));
}
 [Lines 36 - 41 ] {
    Field field = ClassWithDummyField.class.getField("annotatedField");
    FrameworkField frameworkField = new FrameworkField(field);
    Annotation annotation = frameworkField.getAnnotation(Rule.class);
    assertTrue(Rule.class.isAssignableFrom(annotation.getClass()));
}
 [Lines 44 - 49 ] {
    Field field = ClassWithDummyField.class.getField("annotatedField");
    FrameworkField frameworkField = new FrameworkField(field);
    Annotation annotation = frameworkField.getAnnotation(ClassRule.class);
    assertThat(annotation, is(nullValue()));
}

/src/test/java/org/junit/runners/model/RunnerBuilderStub.java
=============================================================
 [Lines 8 - 10 ] {
    return new RunnerSpy(testClass, this);
}

/src/test/java/org/junit/runners/model/TestClassTest.java
=========================================================
 [Lines 27 - 28 ] {
}
 [Lines 30 - 31 ] {
}
 [Lines 35 - 37 ] {
    new TestClass(TwoConstructors.class);
}
 [Lines 50 - 53 ] {
    assertThat(new TestClass(SubclassWithField.class).getAnnotatedFields(Rule.class).size(), is(1));
}
 [Lines 61 - 66 ] {
    assertThat(new TestClass(OuterClass.NonStaticInnerClass.class).isANonStaticInnerClass(), is(true));
}
 [Lines 74 - 79 ] {
    assertThat(new TestClass(OuterClass2.StaticInnerClass.class).isANonStaticInnerClass(), is(false));
}
 [Lines 85 - 88 ] {
    assertThat(new TestClass(SimpleClass.class).isANonStaticInnerClass(), is(false));
}
 [Lines 102 - 108 ] {
    TestClass tc = new TestClass(FieldAnnotated.class);
    List<FrameworkField> annotatedFields = tc.getAnnotatedFields();
    assertThat("Wrong number of annotated fields.", annotatedFields.size(), is(3));
    assertThat("First annotated field is wrong.", annotatedFields.iterator().next().getName(), is("fieldA"));
}
 [Lines 111 - 116 ] {
    TestClass tc = new TestClass(FieldAnnotated.class);
    List<String> values = tc.getAnnotatedFieldValues(new FieldAnnotated(), Rule.class, String.class);
    assertThat(values, hasItem("andromeda"));
    assertThat(values.size(), is(1));
}
 [Lines 121 - 123 ] {
    return 0;
}
 [Lines 127 - 129 ] {
    return "jupiter";
}
 [Lines 133 - 135 ] {
    return 0;
}
 [Lines 139 - 146 ] {
    TestClass tc = new TestClass(MethodsAnnotated.class);
    List<FrameworkMethod> annotatedMethods = tc.getAnnotatedMethods();
    assertThat("Wrong number of annotated methods.", annotatedMethods.size(), is(3));
    assertThat("First annotated method is wrong.", annotatedMethods.iterator().next().getName(), is("methodA"));
}
 [Lines 149 - 155 ] {
    TestClass tc = new TestClass(MethodsAnnotated.class);
    List<String> values = tc.getAnnotatedMethodValues(new MethodsAnnotated(), Ignore.class, String.class);
    assertThat(values, hasItem("jupiter"));
    assertThat(values.size(), is(1));
}
 [Lines 158 - 163 ] {
    TestClass testClass = new TestClass(DummyClass.class);
    TestClass testClassThatWrapsSameJavaClass = new TestClass(DummyClass.class);
    assertTrue(testClass.equals(testClassThatWrapsSameJavaClass));
}
 [Lines 166 - 170 ] {
    TestClass testClass = new TestClass(null);
    TestClass testClassThatWrapsNoJavaClassToo = new TestClass(null);
    assertTrue(testClass.equals(testClassThatWrapsNoJavaClassToo));
}
 [Lines 173 - 178 ] {
    TestClass testClass = new TestClass(DummyClass.class);
    TestClass testClassThatWrapsADifferentJavaClass = new TestClass(AnotherDummyClass.class);
    assertFalse(testClass.equals(testClassThatWrapsADifferentJavaClass));
}
 [Lines 181 - 184 ] {
    TestClass testClass = new TestClass(DummyClass.class);
    assertFalse(testClass.equals(null));
}
 [Lines 193 - 199 ] {
    TestClass testClass = new TestClass(DummyClass.class);
    TestClass testClassThatWrapsSameJavaClass = new TestClass(DummyClass.class);
    assertEquals(testClass.hashCode(), testClassThatWrapsSameJavaClass.hashCode());
}
 [Lines 202 - 206 ] {
    TestClass testClass = new TestClass(null);
    testClass.hashCode();
// everything is fine if no exception is thrown.
}
 [Lines 213 - 216 ] {
    TestClass tc = new TestClass(PublicClass.class);
    assertEquals("Wrong flag 'public',", true, tc.isPublic());
}
 [Lines 223 - 226 ] {
    TestClass tc = new TestClass(NonPublicClass.class);
    assertEquals("Wrong flag 'public',", false, tc.isPublic());
}
 [Lines 233 - 237 ] {
    TestClass tc = new TestClass(AnnotatedClass.class);
    Annotation annotation = tc.getAnnotation(Ignore.class);
    assertTrue(Ignore.class.isAssignableFrom(annotation.getClass()));
}
 [Lines 240 - 244 ] {
    TestClass tc = new TestClass(AnnotatedClass.class);
    Annotation annotation = tc.getAnnotation(RunWith.class);
    assertThat(annotation, is(nullValue()));
}

/src/main/java/junit/textui/TestRunner.java
===========================================
 [Lines 40 - 42 ] {
    this(System.out);
}
 [Lines 47 - 49 ] {
    this(new ResultPrinter(writer));
}
 [Lines 54 - 56 ] {
    fPrinter = printer;
}
 [Lines 61 - 63 ] {
    run(new TestSuite(testClass));
}
 [Lines 75 - 78 ] {
    TestRunner runner = new TestRunner();
    return runner.doRun(test);
}
 [Lines 84 - 87 ] {
    TestRunner aTestRunner = new TestRunner();
    aTestRunner.doRun(suite, true);
}
 [Lines 90 - 91 ] {
}
 [Lines 94 - 95 ] {
}
 [Lines 98 - 99 ] {
}
 [Lines 104 - 106 ] {
    return new TestResult();
}
 [Lines 108 - 110 ] {
    return doRun(test, false);
}
 [Lines 112 - 123 ] {
    TestResult result = createTestResult();
    result.addListener(fPrinter);
    long startTime = System.currentTimeMillis();
    suite.run(result);
    long endTime = System.currentTimeMillis();
    long runTime = endTime - startTime;
    fPrinter.print(result, runTime);
    pause(wait);
    return result;
}
 [Lines 125 - 132 ] {
    if (!wait)
        return;
    fPrinter.printWaitPrompt();
    try {
        System.in.read();
    } catch (Exception e) {
    }
}
 [Lines 134 - 146 ] {
    TestRunner aTestRunner = new TestRunner();
    try {
        TestResult r = aTestRunner.start(args);
        if (!r.wasSuccessful()) {
            System.exit(FAILURE_EXIT);
        }
        System.exit(SUCCESS_EXIT);
    } catch (Exception e) {
        System.err.println(e.getMessage());
        System.exit(EXCEPTION_EXIT);
    }
}
 [Lines 152 - 187 ] {
    String testCase = "";
    String method = "";
    boolean wait = false;
    for (int i = 0; i < args.length; i++) {
        if (args[i].equals("-wait")) {
            wait = true;
        } else if (args[i].equals("-c")) {
            testCase = extractClassName(args[++i]);
        } else if (args[i].equals("-m")) {
            String arg = args[++i];
            int lastIndex = arg.lastIndexOf('.');
            testCase = arg.substring(0, lastIndex);
            method = arg.substring(lastIndex + 1);
        } else if (args[i].equals("-v")) {
            System.err.println("JUnit " + Version.id() + " by Kent Beck and Erich Gamma");
        } else {
            testCase = args[i];
        }
    }
    if (testCase.equals("")) {
        throw new Exception("Usage: TestRunner [-wait] testCaseName, where name is the name of the TestCase class");
    }
    try {
        if (!method.equals("")) {
            return runSingleMethod(testCase, method, wait);
        }
        Test suite = getTest(testCase);
        return doRun(suite, wait);
    } catch (Exception e) {
        throw new Exception("Could not create and run test suite: " + e);
    }
}
 [Lines 189 - 193 ] {
    Class<? extends TestCase> testClass = loadSuiteClass(testCase).asSubclass(TestCase.class);
    Test test = TestSuite.createTest(testClass, method);
    return doRun(test, wait);
}
 [Lines 196 - 199 ] {
    System.err.println(message);
    System.exit(FAILURE_EXIT);
}
 [Lines 201 - 203 ] {
    fPrinter = printer;
}

/src/main/java/junit/textui/ResultPrinter.java
==============================================
 [Lines 18 - 20 ] {
    fWriter = writer;
}
 [Lines 24 - 29 ] {
    printHeader(runTime);
    printErrors(result);
    printFailures(result);
    printFooter(result);
}
 [Lines 31 - 34 ] {
    getWriter().println();
    getWriter().println("<RETURN> to continue");
}
 [Lines 38 - 41 ] {
    getWriter().println();
    getWriter().println("Time: " + elapsedTimeAsString(runTime));
}
 [Lines 43 - 45 ] {
    printDefects(result.errors(), result.errorCount(), "error");
}
 [Lines 47 - 49 ] {
    printDefects(result.failures(), result.failureCount(), "failure");
}
 [Lines 51 - 61 ] {
    if (count == 0)
        return;
    if (count == 1) {
        getWriter().println("There was " + count + " " + type + ":");
    } else {
        getWriter().println("There were " + count + " " + type + "s:");
    }
    for (int i = 1; booBoos.hasMoreElements(); i++) {
        printDefect(booBoos.nextElement(), i);
    }
}
 [Lines 63 - 66 ] {
    // only public for testing purposes
    printDefectHeader(booBoo, count);
    printDefectTrace(booBoo);
}
 [Lines 68 - 72 ] {
    // I feel like making this a println, then adding a line giving the throwable a chance to print something
    // before we get to the stack trace.
    getWriter().print(count + ") " + booBoo.failedTest());
}
 [Lines 74 - 76 ] {
    getWriter().print(BaseTestRunner.getFilteredTrace(booBoo.trace()));
}
 [Lines 78 - 92 ] {
    if (result.wasSuccessful()) {
        getWriter().println();
        getWriter().print("OK");
        getWriter().println(" (" + result.runCount() + " test" + (result.runCount() == 1 ? "" : "s") + ")");
    } else {
        getWriter().println();
        getWriter().println("FAILURES!!!");
        getWriter().println("Tests run: " + result.runCount() + ",  Failures: " + result.failureCount() + ",  Errors: " + result.errorCount());
    }
    getWriter().println();
}
 [Lines 98 - 100 ] {
    return NumberFormat.getInstance().format((double) runTime / 1000);
}
 [Lines 102 - 104 ] {
    return fWriter;
}
 [Lines 109 - 111 ] {
    getWriter().print("E");
}
 [Lines 116 - 118 ] {
    getWriter().print("F");
}
 [Lines 123 - 124 ] {
}
 [Lines 129 - 135 ] {
    getWriter().print(".");
    if (fColumn++ >= 40) {
        getWriter().println();
        fColumn = 0;
    }
}

/src/main/java/junit/textui/package-info.java
=============================================

/src/main/java/junit/framework/ComparisonCompactor.java
=======================================================
 [Lines 15 - 19 ] {
    fContextLength = contextLength;
    fExpected = expected;
    fActual = actual;
}
 [Lines 22 - 32 ] {
    if (fExpected == null || fActual == null || areStringsEqual()) {
        return Assert.format(message, fExpected, fActual);
    }
    findCommonPrefix();
    findCommonSuffix();
    String expected = compactString(fExpected);
    String actual = compactString(fActual);
    return Assert.format(message, expected, actual);
}
 [Lines 34 - 43 ] {
    String result = DELTA_START + source.substring(fPrefix, source.length() - fSuffix + 1) + DELTA_END;
    if (fPrefix > 0) {
        result = computeCommonPrefix() + result;
    }
    if (fSuffix > 0) {
        result = result + computeCommonSuffix();
    }
    return result;
}
 [Lines 45 - 53 ] {
    fPrefix = 0;
    int end = Math.min(fExpected.length(), fActual.length());
    for (; fPrefix < end; fPrefix++) {
        if (fExpected.charAt(fPrefix) != fActual.charAt(fPrefix)) {
            break;
        }
    }
}
 [Lines 55 - 64 ] {
    int expectedSuffix = fExpected.length() - 1;
    int actualSuffix = fActual.length() - 1;
    for (; actualSuffix >= fPrefix && expectedSuffix >= fPrefix; actualSuffix--, expectedSuffix--) {
        if (fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix)) {
            break;
        }
    }
    fSuffix = fExpected.length() - expectedSuffix;
}
 [Lines 66 - 68 ] {
    return (fPrefix > fContextLength ? ELLIPSIS : "") + fExpected.substring(Math.max(0, fPrefix - fContextLength), fPrefix);
}
 [Lines 70 - 73 ] {
    int end = Math.min(fExpected.length() - fSuffix + 1 + fContextLength, fExpected.length());
    return fExpected.substring(fExpected.length() - fSuffix + 1, end) + (fExpected.length() - fSuffix + 1 < fExpected.length() - fContextLength ? ELLIPSIS : "");
}
 [Lines 75 - 77 ] {
    return fExpected.equals(fActual);
}

/src/main/java/junit/framework/JUnit4TestCaseFacade.java
========================================================
 [Lines 9 - 11 ] {
    fDescription = description;
}
 [Lines 14 - 16 ] {
    return getDescription().toString();
}
 [Lines 18 - 20 ] {
    return 1;
}
 [Lines 22 - 25 ] {
    throw new RuntimeException("This test stub created only for informational purposes.");
}
 [Lines 27 - 29 ] {
    return fDescription;
}

/src/main/java/junit/framework/JUnit4TestAdapter.java
=====================================================
 [Lines 23 - 25 ] {
    this(newTestClass, JUnit4TestAdapterCache.getDefault());
}
 [Lines 27 - 31 ] {
    fCache = cache;
    fNewTestClass = newTestClass;
    fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();
}
 [Lines 33 - 35 ] {
    return fRunner.testCount();
}
 [Lines 37 - 39 ] {
    fRunner.run(fCache.getNotifier(result, this));
}
 [Lines 42 - 44 ] {
    return fCache.asTestList(getDescription());
}
 [Lines 47 - 49 ] {
    return fNewTestClass;
}
 [Lines 51 - 54 ] {
    Description description = fRunner.getDescription();
    return removeIgnored(description);
}
 [Lines 56 - 68 ] {
    if (isIgnored(description)) {
        return Description.EMPTY;
    }
    Description result = description.childlessCopy();
    for (Description each : description.getChildren()) {
        Description child = removeIgnored(each);
        if (!child.isEmpty()) {
            result.addChild(child);
        }
    }
    return result;
}
 [Lines 70 - 72 ] {
    return description.getAnnotation(Ignore.class) != null;
}
 [Lines 75 - 77 ] {
    return fNewTestClass.getName();
}
 [Lines 79 - 81 ] {
    filter.apply(fRunner);
}
 [Lines 83 - 85 ] {
    sorter.apply(fRunner);
}

/src/main/java/junit/framework/TestListener.java
================================================

/src/main/java/junit/framework/ComparisonFailure.java
=====================================================
 [Lines 22 - 26 ] {
    super(message);
    fExpected = expected;
    fActual = actual;
}
 [Lines 35 - 37 ] {
    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());
}
 [Lines 44 - 46 ] {
    return fActual;
}
 [Lines 53 - 55 ] {
    return fExpected;
}

/src/main/java/junit/framework/AssertionFailedError.java
========================================================
 [Lines 13 - 14 ] {
}
 [Lines 22 - 24 ] {
    super(defaultString(message));
}
 [Lines 26 - 28 ] {
    return message == null ? "" : message;
}

/src/main/java/junit/framework/TestFailure.java
===============================================
 [Lines 20 - 23 ] {
    fFailedTest = failedTest;
    fThrownException = thrownException;
}
 [Lines 28 - 30 ] {
    return fFailedTest;
}
 [Lines 35 - 37 ] {
    return fThrownException;
}
 [Lines 43 - 45 ] {
    return fFailedTest + ": " + fThrownException.getMessage();
}
 [Lines 51 - 56 ] {
    StringWriter stringWriter = new StringWriter();
    PrintWriter writer = new PrintWriter(stringWriter);
    thrownException().printStackTrace(writer);
    return stringWriter.toString();
}
 [Lines 61 - 63 ] {
    return thrownException().getMessage();
}
 [Lines 70 - 72 ] {
    return thrownException() instanceof AssertionFailedError;
}

/src/main/java/junit/framework/Assert.java
==========================================
 [Lines 13 - 14 ] {
}
 [Lines 20 - 24 ] {
    if (!condition) {
        fail(message);
    }
}
 [Lines 30 - 32 ] {
    assertTrue(null, condition);
}
 [Lines 38 - 40 ] {
    assertTrue(message, !condition);
}
 [Lines 46 - 48 ] {
    assertFalse(null, condition);
}
 [Lines 53 - 58 ] {
    if (message == null) {
        throw new AssertionFailedError();
    }
    throw new AssertionFailedError(message);
}
 [Lines 63 - 65 ] {
    fail(null);
}
 [Lines 71 - 79 ] {
    if (expected == null && actual == null) {
        return;
    }
    if (expected != null && expected.equals(actual)) {
        return;
    }
    failNotEquals(message, expected, actual);
}
 [Lines 85 - 87 ] {
    assertEquals(null, expected, actual);
}
 [Lines 92 - 101 ] {
    if (expected == null && actual == null) {
        return;
    }
    if (expected != null && expected.equals(actual)) {
        return;
    }
    String cleanMessage = message == null ? "" : message;
    throw new ComparisonFailure(cleanMessage, expected, actual);
}
 [Lines 106 - 108 ] {
    assertEquals(null, expected, actual);
}
 [Lines 115 - 122 ] {
    if (Double.compare(expected, actual) == 0) {
        return;
    }
    if (!(Math.abs(expected - actual) <= delta)) {
        failNotEquals(message, new Double(expected), new Double(actual));
    }
}
 [Lines 128 - 130 ] {
    assertEquals(null, expected, actual, delta);
}
 [Lines 137 - 144 ] {
    if (Float.compare(expected, actual) == 0) {
        return;
    }
    if (!(Math.abs(expected - actual) <= delta)) {
        failNotEquals(message, new Float(expected), new Float(actual));
    }
}
 [Lines 150 - 152 ] {
    assertEquals(null, expected, actual, delta);
}
 [Lines 158 - 160 ] {
    assertEquals(message, Long.valueOf(expected), Long.valueOf(actual));
}
 [Lines 165 - 167 ] {
    assertEquals(null, expected, actual);
}
 [Lines 173 - 175 ] {
    assertEquals(message, Boolean.valueOf(expected), Boolean.valueOf(actual));
}
 [Lines 180 - 182 ] {
    assertEquals(null, expected, actual);
}
 [Lines 188 - 190 ] {
    assertEquals(message, Byte.valueOf(expected), Byte.valueOf(actual));
}
 [Lines 195 - 197 ] {
    assertEquals(null, expected, actual);
}
 [Lines 203 - 205 ] {
    assertEquals(message, Character.valueOf(expected), Character.valueOf(actual));
}
 [Lines 210 - 212 ] {
    assertEquals(null, expected, actual);
}
 [Lines 218 - 220 ] {
    assertEquals(message, Short.valueOf(expected), Short.valueOf(actual));
}
 [Lines 225 - 227 ] {
    assertEquals(null, expected, actual);
}
 [Lines 233 - 235 ] {
    assertEquals(message, Integer.valueOf(expected), Integer.valueOf(actual));
}
 [Lines 240 - 242 ] {
    assertEquals(null, expected, actual);
}
 [Lines 247 - 249 ] {
    assertNotNull(null, object);
}
 [Lines 255 - 257 ] {
    assertTrue(message, object != null);
}
 [Lines 266 - 270 ] {
    if (object != null) {
        assertNull("Expected: <null> but was: " + object.toString(), object);
    }
}
 [Lines 276 - 278 ] {
    assertTrue(message, object == null);
}
 [Lines 284 - 289 ] {
    if (expected == actual) {
        return;
    }
    failNotSame(message, expected, actual);
}
 [Lines 295 - 297 ] {
    assertSame(null, expected, actual);
}
 [Lines 304 - 308 ] {
    if (expected == actual) {
        failSame(message);
    }
}
 [Lines 314 - 316 ] {
    assertNotSame(null, expected, actual);
}
 [Lines 318 - 321 ] {
    String formatted = (message != null) ? message + " " : "";
    fail(formatted + "expected not same");
}
 [Lines 323 - 326 ] {
    String formatted = (message != null) ? message + " " : "";
    fail(formatted + "expected same:<" + expected + "> was not:<" + actual + ">");
}
 [Lines 328 - 330 ] {
    fail(format(message, expected, actual));
}
 [Lines 332 - 338 ] {
    String formatted = "";
    if (message != null && message.length() > 0) {
        formatted = message + " ";
    }
    return formatted + "expected:<" + expected + "> but was:<" + actual + ">";
}

/src/main/java/junit/framework/Test.java
========================================

/src/main/java/junit/framework/Protectable.java
===============================================

/src/main/java/junit/framework/TestResult.java
==============================================
 [Lines 24 - 30 ] {
    fFailures = new ArrayList<TestFailure>();
    fErrors = new ArrayList<TestFailure>();
    fListeners = new ArrayList<TestListener>();
    fRunTests = 0;
    fStop = false;
}
 [Lines 36 - 41 ] {
    fErrors.add(new TestFailure(test, e));
    for (TestListener each : cloneListeners()) {
        each.addError(test, e);
    }
}
 [Lines 47 - 52 ] {
    fFailures.add(new TestFailure(test, e));
    for (TestListener each : cloneListeners()) {
        each.addFailure(test, e);
    }
}
 [Lines 57 - 59 ] {
    fListeners.add(listener);
}
 [Lines 64 - 66 ] {
    fListeners.remove(listener);
}
 [Lines 71 - 75 ] {
    List<TestListener> result = new ArrayList<TestListener>();
    result.addAll(fListeners);
    return result;
}
 [Lines 80 - 84 ] {
    for (TestListener each : cloneListeners()) {
        each.endTest(test);
    }
}
 [Lines 89 - 91 ] {
    return fErrors.size();
}
 [Lines 96 - 98 ] {
    return Collections.enumeration(fErrors);
}
 [Lines 104 - 106 ] {
    return fFailures.size();
}
 [Lines 111 - 113 ] {
    return Collections.enumeration(fFailures);
}
 [Lines 118 - 128 ] {
    startTest(test);
    Protectable p = new Protectable() {

        public void protect() throws Throwable {
            test.runBare();
        }
    };
    runProtected(test, p);
    endTest(test);
}
 [Lines 133 - 135 ] {
    return fRunTests;
}
 [Lines 140 - 150 ] {
    try {
        p.protect();
    } catch (AssertionFailedError e) {
        addFailure(test, e);
    } catch (ThreadDeath e) {
        // don't catch ThreadDeath by accident
        throw e;
    } catch (Throwable e) {
        addError(test, e);
    }
}
 [Lines 155 - 157 ] {
    return fStop;
}
 [Lines 162 - 170 ] {
    final int count = test.countTestCases();
    synchronized (this) {
        fRunTests += count;
    }
    for (TestListener each : cloneListeners()) {
        each.startTest(test);
    }
}
 [Lines 175 - 177 ] {
    fStop = true;
}
 [Lines 182 - 184 ] {
    return failureCount() == 0 && errorCount() == 0;
}

/src/main/java/junit/framework/TestCase.java
============================================
 [Lines 87 - 89 ] {
    fName = null;
}
 [Lines 94 - 96 ] {
    fName = name;
}
 [Lines 101 - 103 ] {
    return 1;
}
 [Lines 110 - 112 ] {
    return new TestResult();
}
 [Lines 120 - 124 ] {
    TestResult result = createResult();
    run(result);
    return result;
}
 [Lines 129 - 131 ] {
    result.run(this);
}
 [Lines 138 - 153 ] {
    Throwable exception = null;
    setUp();
    try {
        runTest();
    } catch (Throwable running) {
        exception = running;
    } finally {
        try {
            tearDown();
        } catch (Throwable tearingDown) {
            if (exception == null)
                exception = tearingDown;
        }
    }
    if (exception != null)
        throw exception;
}
 [Lines 160 - 185 ] {
    // Some VMs crash when calling getMethod(null,null);
    assertNotNull("TestCase.fName cannot be null", fName);
    Method runMethod = null;
    try {
        // use getMethod to get all public inherited
        // methods. getDeclaredMethods returns all
        // methods of this class but excludes the
        // inherited ones.
        runMethod = getClass().getMethod(fName, (Class[]) null);
    } catch (NoSuchMethodException e) {
        fail("Method \"" + fName + "\" not found");
    }
    if (!Modifier.isPublic(runMethod.getModifiers())) {
        fail("Method \"" + fName + "\" should be public");
    }
    try {
        runMethod.invoke(this);
    } catch (InvocationTargetException e) {
        e.fillInStackTrace();
        throw e.getTargetException();
    } catch (IllegalAccessException e) {
        e.fillInStackTrace();
        throw e;
    }
}
 [Lines 191 - 193 ] {
    Assert.assertTrue(message, condition);
}
 [Lines 199 - 201 ] {
    Assert.assertTrue(condition);
}
 [Lines 207 - 209 ] {
    Assert.assertFalse(message, condition);
}
 [Lines 215 - 217 ] {
    Assert.assertFalse(condition);
}
 [Lines 222 - 224 ] {
    Assert.fail(message);
}
 [Lines 229 - 231 ] {
    Assert.fail();
}
 [Lines 237 - 239 ] {
    Assert.assertEquals(message, expected, actual);
}
 [Lines 245 - 247 ] {
    Assert.assertEquals(expected, actual);
}
 [Lines 252 - 254 ] {
    Assert.assertEquals(message, expected, actual);
}
 [Lines 259 - 261 ] {
    Assert.assertEquals(expected, actual);
}
 [Lines 268 - 270 ] {
    Assert.assertEquals(message, expected, actual, delta);
}
 [Lines 276 - 278 ] {
    Assert.assertEquals(expected, actual, delta);
}
 [Lines 285 - 287 ] {
    Assert.assertEquals(message, expected, actual, delta);
}
 [Lines 293 - 295 ] {
    Assert.assertEquals(expected, actual, delta);
}
 [Lines 301 - 303 ] {
    Assert.assertEquals(message, expected, actual);
}
 [Lines 308 - 310 ] {
    Assert.assertEquals(expected, actual);
}
 [Lines 316 - 318 ] {
    Assert.assertEquals(message, expected, actual);
}
 [Lines 323 - 325 ] {
    Assert.assertEquals(expected, actual);
}
 [Lines 331 - 333 ] {
    Assert.assertEquals(message, expected, actual);
}
 [Lines 338 - 340 ] {
    Assert.assertEquals(expected, actual);
}
 [Lines 346 - 348 ] {
    Assert.assertEquals(message, expected, actual);
}
 [Lines 353 - 355 ] {
    Assert.assertEquals(expected, actual);
}
 [Lines 361 - 363 ] {
    Assert.assertEquals(message, expected, actual);
}
 [Lines 368 - 370 ] {
    Assert.assertEquals(expected, actual);
}
 [Lines 376 - 378 ] {
    Assert.assertEquals(message, expected, actual);
}
 [Lines 383 - 385 ] {
    Assert.assertEquals(expected, actual);
}
 [Lines 390 - 392 ] {
    Assert.assertNotNull(object);
}
 [Lines 398 - 400 ] {
    Assert.assertNotNull(message, object);
}
 [Lines 409 - 411 ] {
    Assert.assertNull(object);
}
 [Lines 417 - 419 ] {
    Assert.assertNull(message, object);
}
 [Lines 425 - 427 ] {
    Assert.assertSame(message, expected, actual);
}
 [Lines 433 - 435 ] {
    Assert.assertSame(expected, actual);
}
 [Lines 442 - 444 ] {
    Assert.assertNotSame(message, expected, actual);
}
 [Lines 450 - 452 ] {
    Assert.assertNotSame(expected, actual);
}
 [Lines 454 - 456 ] {
    Assert.failSame(message);
}
 [Lines 458 - 460 ] {
    Assert.failNotSame(message, expected, actual);
}
 [Lines 462 - 464 ] {
    Assert.failNotEquals(message, expected, actual);
}
 [Lines 466 - 468 ] {
    return Assert.format(message, expected, actual);
}
 [Lines 474 - 475 ] {
}
 [Lines 481 - 482 ] {
}
 [Lines 488 - 490 ] {
    return getName() + "(" + getClass().getName() + ")";
}
 [Lines 497 - 499 ] {
    return fName;
}
 [Lines 506 - 508 ] {
    fName = name;
}

/src/main/java/junit/framework/package-info.java
================================================

/src/main/java/junit/framework/JUnit4TestAdapterCache.java
==========================================================
 [Lines 17 - 19 ] {
    return fInstance;
}
 [Lines 21 - 30 ] {
    if (description.isSuite()) {
        return createTest(description);
    } else {
        if (!containsKey(description)) {
            put(description, createTest(description));
        }
        return get(description);
    }
}
 [Lines 32 - 42 ] {
    if (description.isTest()) {
        return new JUnit4TestCaseFacade(description);
    } else {
        TestSuite suite = new TestSuite(description.getDisplayName());
        for (Description child : description.getChildren()) {
            suite.addTest(asTest(child));
        }
        return suite;
    }
}
 [Lines 44 - 63 ] {
    RunNotifier notifier = new RunNotifier();
    notifier.addListener(new RunListener() {

        @Override
        public void testFailure(Failure failure) throws Exception {
            result.addError(asTest(failure.getDescription()), failure.getException());
        }

        @Override
        public void testFinished(Description description) throws Exception {
            result.endTest(asTest(description));
        }

        @Override
        public void testStarted(Description description) throws Exception {
            result.startTest(asTest(description));
        }
    });
    return notifier;
}
 [Lines 65 - 75 ] {
    if (description.isTest()) {
        return Arrays.asList(asTest(description));
    } else {
        List<Test> returnThis = new ArrayList<Test>();
        for (Description child : description.getChildren()) {
            returnThis.add(asTest(child));
        }
        return returnThis;
    }
}

/src/main/java/junit/framework/TestSuite.java
=============================================
 [Lines 50 - 75 ] {
    Constructor<?> constructor;
    try {
        constructor = getTestConstructor(theClass);
    } catch (NoSuchMethodException e) {
        return warning("Class " + theClass.getName() + " has no public constructor TestCase(String name) or TestCase()");
    }
    Object test;
    try {
        if (constructor.getParameterTypes().length == 0) {
            test = constructor.newInstance(new Object[0]);
            if (test instanceof TestCase) {
                ((TestCase) test).setName(name);
            }
        } else {
            test = constructor.newInstance(new Object[] { name });
        }
    } catch (InstantiationException e) {
        return (warning("Cannot instantiate test case: " + name + " (" + exceptionToString(e) + ")"));
    } catch (InvocationTargetException e) {
        return (warning("Exception in constructor: " + name + " (" + exceptionToString(e.getTargetException()) + ")"));
    } catch (IllegalAccessException e) {
        return (warning("Cannot access test case: " + name + " (" + exceptionToString(e) + ")"));
    }
    return (Test) test;
}
 [Lines 81 - 88 ] {
    try {
        return theClass.getConstructor(String.class);
    } catch (NoSuchMethodException e) {
    // fall through
    }
    return theClass.getConstructor();
}
 [Lines 93 - 100 ] {
    return new TestCase("warning") {

        @Override
        protected void runTest() {
            fail(message);
        }
    };
}
 [Lines 105 - 110 ] {
    StringWriter stringWriter = new StringWriter();
    PrintWriter writer = new PrintWriter(stringWriter);
    e.printStackTrace(writer);
    return stringWriter.toString();
}
 [Lines 119 - 120 ] {
}
 [Lines 128 - 130 ] {
    addTestsFromTestCase(theClass);
}
 [Lines 132 - 157 ] {
    fName = theClass.getName();
    try {
        // Avoid generating multiple error messages
        getTestConstructor(theClass);
    } catch (NoSuchMethodException e) {
        addTest(warning("Class " + theClass.getName() + " has no public constructor TestCase(String name) or TestCase()"));
        return;
    }
    if (!Modifier.isPublic(theClass.getModifiers())) {
        addTest(warning("Class " + theClass.getName() + " is not public"));
        return;
    }
    Class<?> superClass = theClass;
    List<String> names = new ArrayList<String>();
    while (Test.class.isAssignableFrom(superClass)) {
        for (Method each : MethodSorter.getDeclaredMethods(superClass)) {
            addTestMethod(each, names, theClass);
        }
        superClass = superClass.getSuperclass();
    }
    if (fTests.size() == 0) {
        addTest(warning("No tests found in " + theClass.getName()));
    }
}
 [Lines 164 - 167 ] {
    this(theClass);
    setName(name);
}
 [Lines 172 - 174 ] {
    setName(name);
}
 [Lines 181 - 185 ] {
    for (Class<?> each : classes) {
        addTest(testCaseForClass(each));
    }
}
 [Lines 187 - 193 ] {
    if (TestCase.class.isAssignableFrom(each)) {
        return new TestSuite(each.asSubclass(TestCase.class));
    } else {
        return warning(each.getCanonicalName() + " does not extend TestCase");
    }
}
 [Lines 200 - 203 ] {
    this(classes);
    setName(name);
}
 [Lines 208 - 210 ] {
    fTests.add(test);
}
 [Lines 215 - 217 ] {
    addTest(new TestSuite(testClass));
}
 [Lines 222 - 228 ] {
    int count = 0;
    for (Test each : fTests) {
        count += each.countTestCases();
    }
    return count;
}
 [Lines 235 - 237 ] {
    return fName;
}
 [Lines 242 - 249 ] {
    for (Test each : fTests) {
        if (result.shouldStop()) {
            break;
        }
        runTest(each, result);
    }
}
 [Lines 251 - 253 ] {
    test.run(result);
}
 [Lines 260 - 262 ] {
    fName = name;
}
 [Lines 267 - 269 ] {
    return fTests.get(index);
}
 [Lines 274 - 276 ] {
    return fTests.size();
}
 [Lines 281 - 283 ] {
    return fTests.elements();
}
 [Lines 288 - 293 ] {
    if (getName() != null) {
        return getName();
    }
    return super.toString();
}
 [Lines 295 - 308 ] {
    String name = m.getName();
    if (names.contains(name)) {
        return;
    }
    if (!isPublicTestMethod(m)) {
        if (isTestMethod(m)) {
            addTest(warning("Test method isn't public: " + m.getName() + "(" + theClass.getCanonicalName() + ")"));
        }
        return;
    }
    names.add(name);
    addTest(createTest(theClass, name));
}
 [Lines 310 - 312 ] {
    return isTestMethod(m) && Modifier.isPublic(m.getModifiers());
}
 [Lines 314 - 318 ] {
    return m.getParameterTypes().length == 0 && m.getName().startsWith("test") && m.getReturnType().equals(Void.TYPE);
}

/src/main/java/junit/runner/BaseTestRunner.java
===============================================
 [Lines 38 - 40 ] {
    testStarted(test.toString());
}
 [Lines 42 - 44 ] {
    fPreferences = preferences;
}
 [Lines 46 - 54 ] {
    if (fPreferences == null) {
        fPreferences = new Properties();
        fPreferences.put("loading", "true");
        fPreferences.put("filterstack", "true");
        readPreferences();
    }
    return fPreferences;
}
 [Lines 56 - 63 ] {
    FileOutputStream fos = new FileOutputStream(getPreferencesFile());
    try {
        getPreferences().store(fos, "");
    } finally {
        fos.close();
    }
}
 [Lines 65 - 67 ] {
    getPreferences().put(key, value);
}
 [Lines 69 - 71 ] {
    testEnded(test.toString());
}
 [Lines 73 - 75 ] {
    testFailed(TestRunListener.STATUS_ERROR, test, e);
}
 [Lines 77 - 79 ] {
    testFailed(TestRunListener.STATUS_FAILURE, test, e);
}
 [Lines 93 - 140 ] {
    if (suiteClassName.length() <= 0) {
        clearStatus();
        return null;
    }
    Class<?> testClass = null;
    try {
        testClass = loadSuiteClass(suiteClassName);
    } catch (ClassNotFoundException e) {
        String clazz = e.getMessage();
        if (clazz == null) {
            clazz = suiteClassName;
        }
        runFailed("Class not found \"" + clazz + "\"");
        return null;
    } catch (Exception e) {
        runFailed("Error: " + e.toString());
        return null;
    }
    Method suiteMethod = null;
    try {
        suiteMethod = testClass.getMethod(SUITE_METHODNAME);
    } catch (Exception e) {
        // try to extract a test suite automatically
        clearStatus();
        return new TestSuite(testClass);
    }
    if (!Modifier.isStatic(suiteMethod.getModifiers())) {
        runFailed("Suite() method must be static");
        return null;
    }
    Test test = null;
    try {
        // static method
        test = (Test) suiteMethod.invoke(null);
        if (test == null) {
            return test;
        }
    } catch (InvocationTargetException e) {
        runFailed("Failed to invoke suite():" + e.getTargetException().toString());
        return null;
    } catch (IllegalAccessException e) {
        runFailed("Failed to invoke suite():" + e.toString());
        return null;
    }
    clearStatus();
    return test;
}
 [Lines 145 - 147 ] {
    return NumberFormat.getInstance().format((double) runTime / 1000);
}
 [Lines 153 - 172 ] {
    String suiteName = null;
    for (int i = 0; i < args.length; i++) {
        if (args[i].equals("-noloading")) {
            setLoading(false);
        } else if (args[i].equals("-nofilterstack")) {
            fgFilterStack = false;
        } else if (args[i].equals("-c")) {
            if (args.length > i + 1) {
                suiteName = extractClassName(args[i + 1]);
            } else {
                System.out.println("Missing Test class name");
            }
            i++;
        } else {
            suiteName = args[i];
        }
    }
    return suiteName;
}
 [Lines 177 - 179 ] {
    fLoading = enable;
}
 [Lines 184 - 189 ] {
    if (className.startsWith("Default package for")) {
        return className.substring(className.lastIndexOf(".") + 1);
    }
    return className;
}
 [Lines 194 - 199 ] {
    if (fgMaxMessageLength != -1 && s.length() > fgMaxMessageLength) {
        s = s.substring(0, fgMaxMessageLength) + "...";
    }
    return s;
}
 [Lines 210 - 212 ] {
    return Class.forName(suiteClassName);
}
 [Lines 217 - 218 ] {
// Belongs in the GUI TestRunner class
}
 [Lines 220 - 222 ] {
    return getPreference("loading").equals("true") && fLoading;
}
 [Lines 224 - 227 ] {
    String home = System.getProperty("user.home");
    return new File(home, "junit.properties");
}
 [Lines 229 - 244 ] {
    InputStream is = null;
    try {
        is = new FileInputStream(getPreferencesFile());
        setPreferences(new Properties(getPreferences()));
        getPreferences().load(is);
    } catch (IOException ignored) {
    } finally {
        try {
            if (is != null) {
                is.close();
            }
        } catch (IOException e1) {
        }
    }
}
 [Lines 246 - 248 ] {
    return getPreferences().getProperty(key);
}
 [Lines 250 - 261 ] {
    String value = getPreference(key);
    int intValue = dflt;
    if (value == null) {
        return intValue;
    }
    try {
        intValue = Integer.parseInt(value);
    } catch (NumberFormatException ne) {
    }
    return intValue;
}
 [Lines 266 - 272 ] {
    StringWriter stringWriter = new StringWriter();
    PrintWriter writer = new PrintWriter(stringWriter);
    e.printStackTrace(writer);
    String trace = stringWriter.toString();
    return BaseTestRunner.getFilteredTrace(trace);
}
 [Lines 277 - 298 ] {
    if (showStackRaw()) {
        return stack;
    }
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    StringReader sr = new StringReader(stack);
    BufferedReader br = new BufferedReader(sr);
    String line;
    try {
        while ((line = br.readLine()) != null) {
            if (!filterLine(line)) {
                pw.println(line);
            }
        }
    } catch (Exception IOException) {
        // return the stack unfiltered
        return stack;
    }
    return sw.toString();
}
 [Lines 300 - 302 ] {
    return !getPreference("filterstack").equals("true") || fgFilterStack == false;
}
 [Lines 304 - 321 ] {
    String[] patterns = new String[] { "junit.framework.TestCase", "junit.framework.TestResult", "junit.framework.TestSuite", // don't filter AssertionFailure
    "junit.framework.Assert.", "junit.swingui.TestRunner", "junit.awtui.TestRunner", "junit.textui.TestRunner", "java.lang.reflect.Method.invoke(" };
    for (int i = 0; i < patterns.length; i++) {
        if (line.indexOf(patterns[i]) > 0) {
            return true;
        }
    }
    return false;
}
 [Lines 323 - 325 ] {
    fgMaxMessageLength = getPreference("maxmessage", fgMaxMessageLength);
}

/src/main/java/junit/runner/TestRunListener.java
================================================

/src/main/java/junit/runner/Version.java
========================================
 [Lines 7 - 9 ] {
// don't instantiate
}
 [Lines 11 - 13 ] {
    return "4.13-SNAPSHOT";
}
 [Lines 15 - 17 ] {
    System.out.println(id());
}

/src/main/java/junit/runner/package-info.java
=============================================

/src/main/java/junit/extensions/ActiveTestSuite.java
====================================================
 [Lines 17 - 18 ] {
}
 [Lines 20 - 22 ] {
    super(theClass);
}
 [Lines 24 - 26 ] {
    super(name);
}
 [Lines 28 - 30 ] {
    super(theClass, name);
}
 [Lines 33 - 37 ] {
    fActiveTestDeathCount = 0;
    super.run(result);
    waitUntilFinished();
}
 [Lines 40 - 54 ] {
    Thread t = new Thread() {

        @Override
        public void run() {
            try {
                // inlined due to limitation in VA/Java
                //ActiveTestSuite.super.runTest(test, result);
                test.run(result);
            } finally {
                ActiveTestSuite.this.runFinished();
            }
        }
    };
    t.start();
}
 [Lines 56 - 64 ] {
    while (fActiveTestDeathCount < testCount()) {
        try {
            wait();
        } catch (InterruptedException e) {
            // ignore
            return;
        }
    }
}
 [Lines 66 - 69 ] {
    fActiveTestDeathCount++;
    notifyAll();
}

/src/main/java/junit/extensions/RepeatedTest.java
=================================================
 [Lines 12 - 18 ] {
    super(test);
    if (repeat < 0) {
        throw new IllegalArgumentException("Repetition count must be >= 0");
    }
    fTimesRepeat = repeat;
}
 [Lines 21 - 23 ] {
    return super.countTestCases() * fTimesRepeat;
}
 [Lines 26 - 33 ] {
    for (int i = 0; i < fTimesRepeat; i++) {
        if (result.shouldStop()) {
            break;
        }
        super.run(result);
    }
}
 [Lines 36 - 38 ] {
    return super.toString() + "(repeated)";
}

/src/main/java/junit/extensions/TestSetup.java
==============================================
 [Lines 14 - 16 ] {
    super(test);
}
 [Lines 19 - 28 ] {
    Protectable p = new Protectable() {

        public void protect() throws Exception {
            setUp();
            basicRun(result);
            tearDown();
        }
    };
    result.runProtected(this, p);
}
 [Lines 33 - 34 ] {
}
 [Lines 40 - 41 ] {
}

/src/main/java/junit/extensions/TestDecorator.java
==================================================
 [Lines 16 - 18 ] {
    fTest = test;
}
 [Lines 23 - 25 ] {
    fTest.run(result);
}
 [Lines 27 - 29 ] {
    return fTest.countTestCases();
}
 [Lines 31 - 33 ] {
    basicRun(result);
}
 [Lines 36 - 38 ] {
    return fTest.toString();
}
 [Lines 40 - 42 ] {
    return fTest;
}

/src/main/java/junit/extensions/package-info.java
=================================================

/src/main/java/org/junit/ClassRule.java
=======================================

/src/main/java/org/junit/experimental/ParallelComputer.java
===========================================================
 [Lines 19 - 22 ] {
    this.classes = classes;
    this.methods = methods;
}
 [Lines 24 - 26 ] {
    return new ParallelComputer(true, false);
}
 [Lines 28 - 30 ] {
    return new ParallelComputer(false, true);
}
 [Lines 32 - 52 ] {
    if (runner instanceof ParentRunner) {
        ((ParentRunner<?>) runner).setScheduler(new RunnerScheduler() {

            private final ExecutorService fService = Executors.newCachedThreadPool();

            public void schedule(Runnable childStatement) {
                fService.submit(childStatement);
            }

            public void finished() {
                try {
                    fService.shutdown();
                    fService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
                } catch (InterruptedException e) {
                    e.printStackTrace(System.err);
                }
            }
        });
    }
    return runner;
}
 [Lines 56 - 59 ] {
    Runner suite = super.getSuite(builder, classes);
    return this.classes ? parallelize(suite) : suite;
}
 [Lines 63 - 66 ] {
    Runner runner = super.getRunner(builder, testClass);
    return methods ? parallelize(runner) : runner;
}

/src/main/java/org/junit/experimental/theories/PotentialAssignment.java
=======================================================================
 [Lines 9 - 10 ] {
}
 [Lines 12 - 14 ] {
    super(e);
}
 [Lines 17 - 47 ] {
    return new PotentialAssignment() {

        @Override
        public Object getValue() {
            return value;
        }

        @Override
        public String toString() {
            return format("[%s]", value);
        }

        @Override
        public String getDescription() {
            String valueString;
            if (value == null) {
                valueString = "null";
            } else {
                try {
                    valueString = format("\"%s\"", value);
                } catch (Throwable e) {
                    valueString = format("[toString() threw %s: %s]", e.getClass().getSimpleName(), e.getMessage());
                }
            }
            return format("%s <from %s>", valueString, name);
        }
    };
}

/src/main/java/org/junit/experimental/theories/Theories.java
============================================================
 [Lines 72 - 74 ] {
    super(klass);
}
 [Lines 77 - 81 ] {
    super.collectInitializationErrors(errors);
    validateDataPointFields(errors);
    validateDataPointMethods(errors);
}
 [Lines 83 - 97 ] {
    Field[] fields = getTestClass().getJavaClass().getDeclaredFields();
    for (Field field : fields) {
        if (field.getAnnotation(DataPoint.class) == null && field.getAnnotation(DataPoints.class) == null) {
            continue;
        }
        if (!Modifier.isStatic(field.getModifiers())) {
            errors.add(new Error("DataPoint field " + field.getName() + " must be static"));
        }
        if (!Modifier.isPublic(field.getModifiers())) {
            errors.add(new Error("DataPoint field " + field.getName() + " must be public"));
        }
    }
}
 [Lines 99 - 113 ] {
    Method[] methods = getTestClass().getJavaClass().getDeclaredMethods();
    for (Method method : methods) {
        if (method.getAnnotation(DataPoint.class) == null && method.getAnnotation(DataPoints.class) == null) {
            continue;
        }
        if (!Modifier.isStatic(method.getModifiers())) {
            errors.add(new Error("DataPoint method " + method.getName() + " must be static"));
        }
        if (!Modifier.isPublic(method.getModifiers())) {
            errors.add(new Error("DataPoint method " + method.getName() + " must be public"));
        }
    }
}
 [Lines 116 - 118 ] {
    validateOnlyOneConstructor(errors);
}
 [Lines 121 - 137 ] {
    for (FrameworkMethod each : computeTestMethods()) {
        if (each.getAnnotation(Theory.class) != null) {
            each.validatePublicVoid(false, errors);
            each.validateNoTypeParametersOnArgs(errors);
        } else {
            each.validatePublicVoidNoArg(false, errors);
        }
        for (ParameterSignature signature : ParameterSignature.signatures(each.getMethod())) {
            ParametersSuppliedBy annotation = signature.findDeepAnnotation(ParametersSuppliedBy.class);
            if (annotation != null) {
                validateParameterSupplier(annotation.value(), errors);
            }
        }
    }
}
 [Lines 139 - 152 ] {
    Constructor<?>[] constructors = supplierClass.getConstructors();
    if (constructors.length != 1) {
        errors.add(new Error("ParameterSupplier " + supplierClass.getName() + " must have only one constructor (either empty or taking only a TestClass)"));
    } else {
        Class<?>[] paramTypes = constructors[0].getParameterTypes();
        if (!(paramTypes.length == 0) && !paramTypes[0].equals(TestClass.class)) {
            errors.add(new Error("ParameterSupplier " + supplierClass.getName() + " constructor must take either nothing or a single TestClass instance"));
        }
    }
}
 [Lines 155 - 161 ] {
    List<FrameworkMethod> testMethods = new ArrayList<FrameworkMethod>(super.computeTestMethods());
    List<FrameworkMethod> theoryMethods = getTestClass().getAnnotatedMethods(Theory.class);
    testMethods.removeAll(theoryMethods);
    testMethods.addAll(theoryMethods);
    return testMethods;
}
 [Lines 164 - 166 ] {
    return new TheoryAnchor(method, getTestClass());
}
 [Lines 176 - 179 ] {
    this.testMethod = testMethod;
    this.testClass = testClass;
}
 [Lines 181 - 183 ] {
    return testClass;
}
 [Lines 186 - 197 ] {
    runWithAssignment(Assignments.allUnassigned(testMethod.getMethod(), getTestClass()));
    //if this test method is not annotated with Theory, then no successes is a valid case
    boolean hasTheoryAnnotation = testMethod.getAnnotation(Theory.class) != null;
    if (successes == 0 && hasTheoryAnnotation) {
        Assert.fail("Never found parameters that satisfied method assumptions.  Violated assumptions: " + fInvalidParameters);
    }
}
 [Lines 200 - 206 ] {
    if (!parameterAssignment.isComplete()) {
        runWithIncompleteAssignment(parameterAssignment);
    } else {
        runWithCompleteAssignment(parameterAssignment);
    }
}
 [Lines 209 - 214 ] {
    for (PotentialAssignment source : incomplete.potentialsForNextUnassigned()) {
        runWithAssignment(incomplete.assignNext(source));
    }
}
 [Lines 217 - 261 ] {
    new BlockJUnit4ClassRunner(getTestClass().getJavaClass()) {

        @Override
        protected void collectInitializationErrors(List<Throwable> errors) {
        // do nothing
        }

        @Override
        public Statement methodBlock(FrameworkMethod method) {
            final Statement statement = super.methodBlock(method);
            return new Statement() {

                @Override
                public void evaluate() throws Throwable {
                    try {
                        statement.evaluate();
                        handleDataPointSuccess();
                    } catch (AssumptionViolatedException e) {
                        handleAssumptionViolation(e);
                    } catch (Throwable e) {
                        reportParameterizedError(e, complete.getArgumentStrings(nullsOk()));
                    }
                }
            };
        }

        @Override
        protected Statement methodInvoker(FrameworkMethod method, Object test) {
            return methodCompletesWithParameters(method, complete, test);
        }

        @Override
        public Object createTest() throws Exception {
            Object[] params = complete.getConstructorArguments();
            if (!nullsOk()) {
                Assume.assumeNotNull(params);
            }
            return getTestClass().getOnlyConstructor().newInstance(params);
        }
    }.methodBlock(testMethod).evaluate();
}
 [Lines 264 - 277 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            final Object[] values = complete.getMethodArguments();
            if (!nullsOk()) {
                Assume.assumeNotNull(values);
            }
            method.invokeExplosively(freshInstance, values);
        }
    };
}
 [Lines 279 - 281 ] {
    fInvalidParameters.add(e);
}
 [Lines 284 - 290 ] {
    if (params.length == 0) {
        throw e;
    }
    throw new ParameterizedAssertionError(e, testMethod.getName(), params);
}
 [Lines 292 - 299 ] {
    Theory annotation = testMethod.getMethod().getAnnotation(Theory.class);
    if (annotation == null) {
        return false;
    }
    return annotation.nullsAccepted();
}
 [Lines 301 - 303 ] {
    successes++;
}

/src/main/java/org/junit/experimental/theories/suppliers/TestedOnSupplier.java
==============================================================================
 [Lines 16 - 24 ] {
    List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();
    TestedOn testedOn = sig.getAnnotation(TestedOn.class);
    int[] ints = testedOn.ints();
    for (final int i : ints) {
        list.add(PotentialAssignment.forValue("ints", i));
    }
    return list;
}

/src/main/java/org/junit/experimental/theories/suppliers/TestedOn.java
======================================================================

/src/main/java/org/junit/experimental/theories/ParameterSupplier.java
=====================================================================

/src/main/java/org/junit/experimental/theories/DataPoints.java
==============================================================

/src/main/java/org/junit/experimental/theories/DataPoint.java
=============================================================

/src/main/java/org/junit/experimental/theories/internal/AllMembersSupplier.java
===============================================================================
 [Lines 27 - 29 ] {
    method = dataPointMethod;
}
 [Lines 32 - 47 ] {
    try {
        return method.invokeExplosively(null);
    } catch (IllegalArgumentException e) {
        throw new RuntimeException("unexpected: argument length is checked");
    } catch (IllegalAccessException e) {
        throw new RuntimeException("unexpected: getMethods returned an inaccessible method");
    } catch (Throwable throwable) {
        DataPoint annotation = method.getAnnotation(DataPoint.class);
        Assume.assumeTrue(annotation == null || !isAssignableToAnyOf(annotation.ignoredExceptions(), throwable));
        throw new CouldNotGenerateValueException(throwable);
    }
}
 [Lines 50 - 52 ] {
    return method.getName();
}
 [Lines 60 - 62 ] {
    clazz = type;
}
 [Lines 65 - 74 ] {
    List<PotentialAssignment> list = new ArrayList<PotentialAssignment>();
    addSinglePointFields(sig, list);
    addMultiPointFields(sig, list);
    addSinglePointMethods(sig, list);
    addMultiPointMethods(sig, list);
    return list;
}
 [Lines 76 - 95 ] {
    for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {
        Class<?> returnType = dataPointsMethod.getReturnType();
        if ((returnType.isArray() && sig.canPotentiallyAcceptType(returnType.getComponentType())) || Iterable.class.isAssignableFrom(returnType)) {
            try {
                addDataPointsValues(returnType, sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));
            } catch (Throwable throwable) {
                DataPoints annotation = dataPointsMethod.getAnnotation(DataPoints.class);
                if (annotation != null && isAssignableToAnyOf(annotation.ignoredExceptions(), throwable)) {
                    return;
                } else {
                    throw throwable;
                }
            }
        }
    }
}
 [Lines 97 - 103 ] {
    for (FrameworkMethod dataPointMethod : getSingleDataPointMethods(sig)) {
        if (sig.canAcceptType(dataPointMethod.getType())) {
            list.add(new MethodParameterValue(dataPointMethod));
        }
    }
}
 [Lines 105 - 110 ] {
    for (final Field field : getDataPointsFields(sig)) {
        Class<?> type = field.getType();
        addDataPointsValues(type, sig, field.getName(), list, getStaticFieldValue(field));
    }
}
 [Lines 112 - 120 ] {
    for (final Field field : getSingleDataPointFields(sig)) {
        Object value = getStaticFieldValue(field);
        if (sig.canAcceptValue(value)) {
            list.add(PotentialAssignment.forValue(field.getName(), value));
        }
    }
}
 [Lines 123 - 130 ] {
    if (type.isArray()) {
        addArrayValues(sig, name, list, value);
    } else if (Iterable.class.isAssignableFrom(type)) {
        addIterableValues(sig, name, list, (Iterable<?>) value);
    }
}
 [Lines 132 - 139 ] {
    for (int i = 0; i < Array.getLength(array); i++) {
        Object value = Array.get(array, i);
        if (sig.canAcceptValue(value)) {
            list.add(PotentialAssignment.forValue(name + "[" + i + "]", value));
        }
    }
}
 [Lines 141 - 151 ] {
    Iterator<?> iterator = iterable.iterator();
    int i = 0;
    while (iterator.hasNext()) {
        Object value = iterator.next();
        if (sig.canAcceptValue(value)) {
            list.add(PotentialAssignment.forValue(name + "[" + i + "]", value));
        }
        i += 1;
    }
}
 [Lines 153 - 163 ] {
    try {
        return field.get(null);
    } catch (IllegalArgumentException e) {
        throw new RuntimeException("unexpected: field from getClass doesn't exist on object");
    } catch (IllegalAccessException e) {
        throw new RuntimeException("unexpected: getFields returned an inaccessible field");
    }
}
 [Lines 165 - 172 ] {
    for (Class<?> type : typeArray) {
        if (type.isAssignableFrom(target.getClass())) {
            return true;
        }
    }
    return false;
}
 [Lines 174 - 176 ] {
    return clazz.getAnnotatedMethods(DataPoints.class);
}
 [Lines 178 - 187 ] {
    List<FrameworkField> fields = clazz.getAnnotatedFields(DataPoint.class);
    Collection<Field> validFields = new ArrayList<Field>();
    for (FrameworkField frameworkField : fields) {
        validFields.add(frameworkField.getField());
    }
    return validFields;
}
 [Lines 189 - 198 ] {
    List<FrameworkField> fields = clazz.getAnnotatedFields(DataPoints.class);
    Collection<Field> validFields = new ArrayList<Field>();
    for (FrameworkField frameworkField : fields) {
        validFields.add(frameworkField.getField());
    }
    return validFields;
}
 [Lines 200 - 202 ] {
    return clazz.getAnnotatedMethods(DataPoint.class);
}

/src/main/java/org/junit/experimental/theories/internal/BooleanSupplier.java
============================================================================
 [Lines 13 - 16 ] {
    return Arrays.asList(PotentialAssignment.forValue("true", true), PotentialAssignment.forValue("false", false));
}

/src/main/java/org/junit/experimental/theories/internal/ParameterizedAssertionError.java
========================================================================================
 [Lines 11 - 14 ] {
    super(String.format("%s(%s)", methodName, join(", ", params)));
    this.initCause(targetException);
}
 [Lines 17 - 19 ] {
    return obj instanceof ParameterizedAssertionError && toString().equals(obj.toString());
}
 [Lines 22 - 24 ] {
    return toString().hashCode();
}
 [Lines 26 - 28 ] {
    return join(delimiter, Arrays.asList(params));
}
 [Lines 30 - 41 ] {
    StringBuilder sb = new StringBuilder();
    Iterator<Object> iter = values.iterator();
    while (iter.hasNext()) {
        Object next = iter.next();
        sb.append(stringValueOf(next));
        if (iter.hasNext()) {
            sb.append(delimiter);
        }
    }
    return sb.toString();
}
 [Lines 43 - 49 ] {
    try {
        return String.valueOf(next);
    } catch (Throwable e) {
        return "[toString failed]";
    }
}

/src/main/java/org/junit/experimental/theories/internal/EnumSupplier.java
=========================================================================
 [Lines 14 - 16 ] {
    this.enumType = enumType;
}
 [Lines 19 - 28 ] {
    Object[] enumValues = enumType.getEnumConstants();
    List<PotentialAssignment> assignments = new ArrayList<PotentialAssignment>();
    for (Object value : enumValues) {
        assignments.add(PotentialAssignment.forValue(value.toString(), value));
    }
    return assignments;
}

/src/main/java/org/junit/experimental/theories/internal/SpecificDataPointsSupplier.java
=======================================================================================
 [Lines 18 - 20 ] {
    super(testClass);
}
 [Lines 23 - 37 ] {
    Collection<Field> fields = super.getSingleDataPointFields(sig);
    String requestedName = sig.getAnnotation(FromDataPoints.class).value();
    List<Field> fieldsWithMatchingNames = new ArrayList<Field>();
    for (Field field : fields) {
        String[] fieldNames = field.getAnnotation(DataPoint.class).value();
        if (Arrays.asList(fieldNames).contains(requestedName)) {
            fieldsWithMatchingNames.add(field);
        }
    }
    return fieldsWithMatchingNames;
}
 [Lines 40 - 54 ] {
    Collection<Field> fields = super.getDataPointsFields(sig);
    String requestedName = sig.getAnnotation(FromDataPoints.class).value();
    List<Field> fieldsWithMatchingNames = new ArrayList<Field>();
    for (Field field : fields) {
        String[] fieldNames = field.getAnnotation(DataPoints.class).value();
        if (Arrays.asList(fieldNames).contains(requestedName)) {
            fieldsWithMatchingNames.add(field);
        }
    }
    return fieldsWithMatchingNames;
}
 [Lines 57 - 71 ] {
    Collection<FrameworkMethod> methods = super.getSingleDataPointMethods(sig);
    String requestedName = sig.getAnnotation(FromDataPoints.class).value();
    List<FrameworkMethod> methodsWithMatchingNames = new ArrayList<FrameworkMethod>();
    for (FrameworkMethod method : methods) {
        String[] methodNames = method.getAnnotation(DataPoint.class).value();
        if (Arrays.asList(methodNames).contains(requestedName)) {
            methodsWithMatchingNames.add(method);
        }
    }
    return methodsWithMatchingNames;
}
 [Lines 74 - 88 ] {
    Collection<FrameworkMethod> methods = super.getDataPointsMethods(sig);
    String requestedName = sig.getAnnotation(FromDataPoints.class).value();
    List<FrameworkMethod> methodsWithMatchingNames = new ArrayList<FrameworkMethod>();
    for (FrameworkMethod method : methods) {
        String[] methodNames = method.getAnnotation(DataPoints.class).value();
        if (Arrays.asList(methodNames).contains(requestedName)) {
            methodsWithMatchingNames.add(method);
        }
    }
    return methodsWithMatchingNames;
}

/src/main/java/org/junit/experimental/theories/internal/Assignments.java
========================================================================
 [Lines 29 - 33 ] {
    this.unassigned = unassigned;
    this.assigned = assigned;
    this.clazz = clazz;
}
 [Lines 40 - 47 ] {
    List<ParameterSignature> signatures;
    signatures = ParameterSignature.signatures(testClass.getOnlyConstructor());
    signatures.addAll(ParameterSignature.signatures(testMethod));
    return new Assignments(new ArrayList<PotentialAssignment>(), signatures, testClass);
}
 [Lines 49 - 51 ] {
    return unassigned.isEmpty();
}
 [Lines 53 - 55 ] {
    return unassigned.get(0);
}
 [Lines 57 - 63 ] {
    List<PotentialAssignment> potentialAssignments = new ArrayList<PotentialAssignment>(assigned);
    potentialAssignments.add(source);
    return new Assignments(potentialAssignments, unassigned.subList(1, unassigned.size()), clazz);
}
 [Lines 66 - 72 ] {
    Object[] values = new Object[stop - start];
    for (int i = start; i < stop; i++) {
        values[i - start] = assigned.get(i).getValue();
    }
    return values;
}
 [Lines 75 - 84 ] {
    ParameterSignature unassigned = nextUnassigned();
    List<PotentialAssignment> assignments = getSupplier(unassigned).getValueSources(unassigned);
    if (assignments.isEmpty()) {
        assignments = generateAssignmentsFromTypeAlone(unassigned);
    }
    return assignments;
}
 [Lines 86 - 96 ] {
    Class<?> paramType = unassigned.getType();
    if (paramType.isEnum()) {
        return new EnumSupplier(paramType).getValueSources(unassigned);
    } else if (paramType.equals(Boolean.class) || paramType.equals(boolean.class)) {
        return new BooleanSupplier().getValueSources(unassigned);
    } else {
        return emptyList();
    }
}
 [Lines 99 - 108 ] {
    ParametersSuppliedBy annotation = unassigned.findDeepAnnotation(ParametersSuppliedBy.class);
    if (annotation != null) {
        return buildParameterSupplierFromClass(annotation.value());
    } else {
        return new AllMembersSupplier(clazz);
    }
}
 [Lines 111 - 123 ] {
    Constructor<?>[] supplierConstructors = cls.getConstructors();
    for (Constructor<?> constructor : supplierConstructors) {
        Class<?>[] parameterTypes = constructor.getParameterTypes();
        if (parameterTypes.length == 1 && parameterTypes[0].equals(TestClass.class)) {
            return (ParameterSupplier) constructor.newInstance(clazz);
        }
    }
    return cls.newInstance();
}
 [Lines 126 - 128 ] {
    return getActualValues(0, getConstructorParameterCount());
}
 [Lines 130 - 132 ] {
    return getActualValues(getConstructorParameterCount(), assigned.size());
}
 [Lines 134 - 136 ] {
    return getActualValues(0, assigned.size());
}
 [Lines 138 - 143 ] {
    List<ParameterSignature> signatures = ParameterSignature.signatures(clazz.getOnlyConstructor());
    int constructorParameterCount = signatures.size();
    return constructorParameterCount;
}
 [Lines 146 - 152 ] {
    Object[] values = new Object[assigned.size()];
    for (int i = 0; i < values.length; i++) {
        values[i] = assigned.get(i).getDescription();
    }
    return values;
}

/src/main/java/org/junit/experimental/theories/ParameterSignature.java
======================================================================
 [Lines 17 - 30 ] {
    Map<Class<?>, Class<?>> map = new HashMap<Class<?>, Class<?>>();
    putSymmetrically(map, boolean.class, Boolean.class);
    putSymmetrically(map, byte.class, Byte.class);
    putSymmetrically(map, short.class, Short.class);
    putSymmetrically(map, char.class, Character.class);
    putSymmetrically(map, int.class, Integer.class);
    putSymmetrically(map, long.class, Long.class);
    putSymmetrically(map, float.class, Float.class);
    putSymmetrically(map, double.class, Double.class);
    return Collections.unmodifiableMap(map);
}
 [Lines 32 - 35 ] {
    map.put(a, b);
    map.put(b, a);
}
 [Lines 37 - 40 ] {
    return signatures(method.getParameterTypes(), method.getParameterAnnotations());
}
 [Lines 42 - 45 ] {
    return signatures(constructor.getParameterTypes(), constructor.getParameterAnnotations());
}
 [Lines 48 - 55 ] {
    ArrayList<ParameterSignature> sigs = new ArrayList<ParameterSignature>();
    for (int i = 0; i < parameterTypes.length; i++) {
        sigs.add(new ParameterSignature(parameterTypes[i], parameterAnnotations[i]));
    }
    return sigs;
}
 [Lines 61 - 64 ] {
    this.type = type;
    this.annotations = annotations;
}
 [Lines 66 - 68 ] {
    return (candidate == null) ? !type.isPrimitive() : canAcceptType(candidate.getClass());
}
 [Lines 70 - 73 ] {
    return type.isAssignableFrom(candidate) || isAssignableViaTypeConversion(type, candidate);
}
 [Lines 75 - 79 ] {
    return candidate.isAssignableFrom(type) || isAssignableViaTypeConversion(candidate, type) || canAcceptType(candidate);
}
 [Lines 81 - 88 ] {
    if (CONVERTABLE_TYPES_MAP.containsKey(candidate)) {
        Class<?> wrapperClass = CONVERTABLE_TYPES_MAP.get(candidate);
        return targetType.isAssignableFrom(wrapperClass);
    } else {
        return false;
    }
}
 [Lines 90 - 92 ] {
    return type;
}
 [Lines 94 - 96 ] {
    return Arrays.asList(annotations);
}
 [Lines 98 - 100 ] {
    return getAnnotation(type) != null;
}
 [Lines 102 - 105 ] {
    Annotation[] annotations2 = annotations;
    return findDeepAnnotation(annotations2, annotationType, 3);
}
 [Lines 108 - 124 ] {
    if (depth == 0) {
        return null;
    }
    for (Annotation each : annotations) {
        if (annotationType.isInstance(each)) {
            return annotationType.cast(each);
        }
        Annotation candidate = findDeepAnnotation(each.annotationType().getAnnotations(), annotationType, depth - 1);
        if (candidate != null) {
            return annotationType.cast(candidate);
        }
    }
    return null;
}
 [Lines 126 - 133 ] {
    for (Annotation each : getAnnotations()) {
        if (annotationType.isInstance(each)) {
            return annotationType.cast(each);
        }
    }
    return null;
}

/src/main/java/org/junit/experimental/theories/Theory.java
==========================================================

/src/main/java/org/junit/experimental/theories/ParametersSuppliedBy.java
========================================================================

/src/main/java/org/junit/experimental/theories/FromDataPoints.java
==================================================================

/src/main/java/org/junit/experimental/max/MaxCore.java
======================================================
 [Lines 41 - 43 ] {
    return storedLocally(new File(folderName));
}
 [Lines 48 - 50 ] {
    return new MaxCore(storedResults);
}
 [Lines 54 - 56 ] {
    history = MaxHistory.forFolder(storedResults);
}
 [Lines 63 - 65 ] {
    return run(Request.aClass(testClass));
}
 [Lines 73 - 75 ] {
    return run(request, new JUnitCore());
}
 [Lines 87 - 90 ] {
    core.addListener(history.listener());
    return core.run(sortRequest(request).getRunner());
}
 [Lines 95 - 103 ] {
    if (request instanceof SortingRequest) {
        // We'll pay big karma points for this
        return request;
    }
    List<Description> leaves = findLeaves(request);
    Collections.sort(leaves, history.testComparator());
    return constructLeafRequest(leaves);
}
 [Lines 105 - 121 ] {
    final List<Runner> runners = new ArrayList<Runner>();
    for (Description each : leaves) {
        runners.add(buildRunner(each));
    }
    return new Request() {

        @Override
        public Runner getRunner() {
            try {
                return new Suite((Class<?>) null, runners) {
                };
            } catch (InitializationError e) {
                return new ErrorReportingRunner(null, e);
            }
        }
    };
}
 [Lines 123 - 143 ] {
    if (each.toString().equals("TestSuite with 0 tests")) {
        return Suite.emptySuite();
    }
    if (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX)) {
        // thrown away which method the warning is for.
        return new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));
    }
    Class<?> type = each.getTestClass();
    if (type == null) {
        throw new RuntimeException("Can't build a runner from description [" + each + "]");
    }
    String methodName = each.getMethodName();
    if (methodName == null) {
        return Request.aClass(type).getRunner();
    }
    return Request.method(type, methodName).getRunner();
}
 [Lines 145 - 151 ] {
    try {
        return Class.forName(each.toString().replace(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX, ""));
    } catch (ClassNotFoundException e) {
        return null;
    }
}
 [Lines 158 - 160 ] {
    return findLeaves(sortRequest(request));
}
 [Lines 162 - 166 ] {
    List<Description> results = new ArrayList<Description>();
    findLeaves(null, request.getRunner().getDescription(), results);
    return results;
}
 [Lines 168 - 180 ] {
    if (description.getChildren().isEmpty()) {
        if (description.toString().equals("warning(junit.framework.TestSuite$1)")) {
            results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
        } else {
            results.add(description);
        }
    } else {
        for (Description each : description.getChildren()) {
            findLeaves(description, each, results);
        }
    }
}

/src/main/java/org/junit/experimental/max/CouldNotReadCoreException.java
========================================================================
 [Lines 12 - 14 ] {
    super(e);
}

/src/main/java/org/junit/experimental/max/MaxHistory.java
=========================================================
 [Lines 33 - 43 ] {
    if (file.exists()) {
        try {
            return readHistory(file);
        } catch (CouldNotReadCoreException e) {
            e.printStackTrace();
            file.delete();
        }
    }
    return new MaxHistory(file);
}
 [Lines 46 - 62 ] {
    try {
        FileInputStream file = new FileInputStream(storedResults);
        try {
            ObjectInputStream stream = new ObjectInputStream(file);
            try {
                return (MaxHistory) stream.readObject();
            } finally {
                stream.close();
            }
        } finally {
            file.close();
        }
    } catch (Exception e) {
        throw new CouldNotReadCoreException(e);
    }
}
 [Lines 73 - 75 ] {
    fHistoryStore = storedResults;
}
 [Lines 77 - 82 ] {
    ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(fHistoryStore));
    stream.writeObject(this);
    stream.close();
}
 [Lines 84 - 86 ] {
    return fFailureTimestamps.get(key.toString());
}
 [Lines 88 - 90 ] {
    fFailureTimestamps.put(key.toString(), end);
}
 [Lines 92 - 94 ] {
    return !fDurations.containsKey(key.toString());
}
 [Lines 96 - 98 ] {
    return fDurations.get(key.toString());
}
 [Lines 100 - 102 ] {
    fDurations.put(description.toString(), duration);
}
 [Lines 110 - 113 ] {
    // Get most accurate
    starts.put(description, System.nanoTime());
// possible time
}
 [Lines 116 - 120 ] {
    long end = System.nanoTime();
    long start = starts.get(description);
    putTestDuration(description, end - start);
}
 [Lines 123 - 125 ] {
    putTestFailureTimestamp(failure.getDescription(), overallStart);
}
 [Lines 128 - 130 ] {
    save();
}
 [Lines 134 - 147 ] {
    // Always prefer new tests
    if (isNewTest(o1)) {
        return -1;
    }
    if (isNewTest(o2)) {
        return 1;
    }
    // Then most recently failed first
    int result = getFailure(o2).compareTo(getFailure(o1));
    return result != 0 ? result : // Then shorter tests first
    getTestDuration(o1).compareTo(getTestDuration(o2));
}
 [Lines 149 - 155 ] {
    Long result = getFailureTimestamp(key);
    if (result == null) {
        // 0 = "never failed (that I know about)"
        return 0L;
    }
    return result;
}
 [Lines 162 - 164 ] {
    return new RememberingListener();
}
 [Lines 170 - 172 ] {
    return new TestComparator();
}

/src/main/java/org/junit/experimental/results/PrintableResult.java
==================================================================
 [Lines 28 - 30 ] {
    return testResult(Request.aClass(type));
}
 [Lines 35 - 37 ] {
    return new PrintableResult(new JUnitCore().run(request));
}
 [Lines 42 - 44 ] {
    this(new FailureList(failures).result());
}
 [Lines 46 - 48 ] {
    this.result = result;
}
 [Lines 53 - 55 ] {
    return result.getFailures().size();
}
 [Lines 58 - 62 ] {
    ByteArrayOutputStream stream = new ByteArrayOutputStream();
    new TextListener(new PrintStream(stream)).testRunFinished(result);
    return stream.toString();
}

/src/main/java/org/junit/experimental/results/FailureList.java
==============================================================
 [Lines 12 - 14 ] {
    this.failures = failures;
}
 [Lines 16 - 27 ] {
    Result result = new Result();
    RunListener listener = result.createListener();
    for (Failure failure : failures) {
        try {
            listener.testFailure(failure);
        } catch (Exception e) {
            throw new RuntimeException("I can't believe this happened");
        }
    }
    return result;
}

/src/main/java/org/junit/experimental/results/ResultMatchers.java
=================================================================
 [Lines 23 - 24 ] {
}
 [Lines 29 - 31 ] {
    return failureCountIs(0);
}
 [Lines 36 - 47 ] {
    return new TypeSafeMatcher<PrintableResult>() {

        public void describeTo(Description description) {
            description.appendText("has " + count + " failures");
        }

        @Override
        public boolean matchesSafely(PrintableResult item) {
            return item.failureCount() == count;
        }
    };
}
 [Lines 52 - 62 ] {
    return new BaseMatcher<Object>() {

        public boolean matches(Object item) {
            return item.toString().contains(string) && failureCountIs(1).matches(item);
        }

        public void describeTo(Description description) {
            description.appendText("has single failure containing " + string);
        }
    };
}
 [Lines 68 - 78 ] {
    return new BaseMatcher<PrintableResult>() {

        public boolean matches(Object item) {
            return item.toString().contains(string);
        }

        public void describeTo(Description description) {
            description.appendText("has failure containing " + string);
        }
    };
}

/src/main/java/org/junit/experimental/runners/Enclosed.java
===========================================================
 [Lines 30 - 32 ] {
    super(builder, klass, filterAbstractClasses(klass.getClasses()));
}
 [Lines 34 - 44 ] {
    final List<Class<?>> filteredList = new ArrayList<Class<?>>(classes.length);
    for (final Class<?> clazz : classes) {
        if (!Modifier.isAbstract(clazz.getModifiers())) {
            filteredList.add(clazz);
        }
    }
    return filteredList.toArray(new Class<?>[filteredList.size()]);
}

/src/main/java/org/junit/experimental/categories/IncludeCategories.java
=======================================================================
 [Lines 34 - 36 ] {
    return new IncludesAny(categories);
}
 [Lines 39 - 41 ] {
    this(new HashSet<Class<?>>(categories));
}
 [Lines 43 - 45 ] {
    super(true, categories, true, null);
}
 [Lines 48 - 50 ] {
    return "includes " + super.describe();
}

/src/main/java/org/junit/experimental/categories/Category.java
==============================================================

/src/main/java/org/junit/experimental/categories/CategoryValidator.java
=======================================================================
 [Lines 44 - 55 ] {
    List<Exception> errors = new ArrayList<Exception>();
    Annotation[] annotations = method.getAnnotations();
    for (Annotation annotation : annotations) {
        for (Class<?> clazz : INCOMPATIBLE_ANNOTATIONS) {
            if (annotation.annotationType().isAssignableFrom(clazz)) {
                addErrorMessage(errors, clazz);
            }
        }
    }
    return unmodifiableList(errors);
}
 [Lines 57 - 61 ] {
    String message = String.format("@%s can not be combined with @Category", clazz.getSimpleName());
    errors.add(new Exception(message));
}

/src/main/java/org/junit/experimental/categories/CategoryFilterFactory.java
===========================================================================
 [Lines 21 - 27 ] {
    try {
        return createFilter(parseCategories(params.getArgs()));
    } catch (ClassNotFoundException e) {
        throw new FilterNotCreatedException(e);
    }
}
 [Lines 36 - 46 ] {
    List<Class<?>> categoryClasses = new ArrayList<Class<?>>();
    for (String category : categories.split(",")) {
        Class<?> categoryClass = Classes.getClass(category);
        categoryClasses.add(categoryClass);
    }
    return categoryClasses;
}

/src/main/java/org/junit/experimental/categories/ExcludeCategories.java
=======================================================================
 [Lines 34 - 36 ] {
    return new ExcludesAny(categories);
}
 [Lines 39 - 41 ] {
    this(new HashSet<Class<?>>(categories));
}
 [Lines 43 - 45 ] {
    super(true, null, true, categories);
}
 [Lines 48 - 50 ] {
    return "excludes " + super.describe();
}

/src/main/java/org/junit/experimental/categories/Categories.java
================================================================
 [Lines 119 - 124 ] {
    if (hasNull(categories)) {
        throw new NullPointerException("has null category");
    }
    return categoryFilter(matchAny, createSet(categories), true, null);
}
 [Lines 126 - 128 ] {
    return include(true, category);
}
 [Lines 130 - 132 ] {
    return include(true, categories);
}
 [Lines 134 - 139 ] {
    if (hasNull(categories)) {
        throw new NullPointerException("has null category");
    }
    return categoryFilter(true, null, matchAny, createSet(categories));
}
 [Lines 141 - 143 ] {
    return exclude(true, category);
}
 [Lines 145 - 147 ] {
    return exclude(true, categories);
}
 [Lines 150 - 152 ] {
    return new CategoryFilter(matchAnyInclusions, inclusions, matchAnyExclusions, exclusions);
}
 [Lines 155 - 160 ] {
    includedAny = matchAnyIncludes;
    excludedAny = matchAnyExcludes;
    included = copyAndRefine(includes);
    excluded = copyAndRefine(excludes);
}
 [Lines 166 - 168 ] {
    return toString();
}
 [Lines 183 - 190 ] {
    StringBuilder description = new StringBuilder("categories ").append(included.isEmpty() ? "[all]" : included);
    if (!excluded.isEmpty()) {
        description.append(" - ").append(excluded);
    }
    return description.toString();
}
 [Lines 193 - 205 ] {
    if (hasCorrectCategoryAnnotation(description)) {
        return true;
    }
    for (Description each : description.getChildren()) {
        if (shouldRun(each)) {
            return true;
        }
    }
    return false;
}
 [Lines 207 - 237 ] {
    final Set<Class<?>> childCategories = categories(description);
    // If a child has no categories, immediately return.
    if (childCategories.isEmpty()) {
        return included.isEmpty();
    }
    if (!excluded.isEmpty()) {
        if (excludedAny) {
            if (matchesAnyParentCategories(childCategories, excluded)) {
                return false;
            }
        } else {
            if (matchesAllParentCategories(childCategories, excluded)) {
                return false;
            }
        }
    }
    if (included.isEmpty()) {
        // Couldn't be excluded, and with no suite's included categories treated as should run.
        return true;
    } else {
        if (includedAny) {
            return matchesAnyParentCategories(childCategories, included);
        } else {
            return matchesAllParentCategories(childCategories, included);
        }
    }
}
 [Lines 243 - 250 ] {
    for (Class<?> parentCategory : parentCategories) {
        if (hasAssignableTo(childCategories, parentCategory)) {
            return true;
        }
    }
    return false;
}
 [Lines 256 - 263 ] {
    for (Class<?> parentCategory : parentCategories) {
        if (!hasAssignableTo(childCategories, parentCategory)) {
            return false;
        }
    }
    return true;
}
 [Lines 265 - 270 ] {
    Set<Class<?>> categories = new HashSet<Class<?>>();
    Collections.addAll(categories, directCategories(description));
    Collections.addAll(categories, directCategories(parentDescription(description)));
    return categories;
}
 [Lines 272 - 275 ] {
    Class<?> testClass = description.getTestClass();
    return testClass == null ? null : Description.createSuiteDescription(testClass);
}
 [Lines 277 - 284 ] {
    if (description == null) {
        return new Class<?>[0];
    }
    Category annotation = description.getAnnotation(Category.class);
    return annotation == null ? new Class<?>[0] : annotation.value();
}
 [Lines 286 - 293 ] {
    Set<Class<?>> c = new HashSet<Class<?>>();
    if (classes != null) {
        c.addAll(classes);
    }
    c.remove(null);
    return c;
}
 [Lines 295 - 303 ] {
    if (classes == null)
        return false;
    for (Class<?> clazz : classes) {
        if (clazz == null) {
            return true;
        }
    }
    return false;
}
 [Lines 306 - 318 ] {
    super(klass, builder);
    try {
        Set<Class<?>> included = getIncludedCategory(klass);
        Set<Class<?>> excluded = getExcludedCategory(klass);
        boolean isAnyIncluded = isAnyIncluded(klass);
        boolean isAnyExcluded = isAnyExcluded(klass);
        filter(CategoryFilter.categoryFilter(isAnyIncluded, included, isAnyExcluded, excluded));
    } catch (NoTestsRemainException e) {
        throw new InitializationError(e);
    }
}
 [Lines 320 - 323 ] {
    IncludeCategory annotation = klass.getAnnotation(IncludeCategory.class);
    return createSet(annotation == null ? null : annotation.value());
}
 [Lines 325 - 328 ] {
    IncludeCategory annotation = klass.getAnnotation(IncludeCategory.class);
    return annotation == null || annotation.matchAny();
}
 [Lines 330 - 333 ] {
    ExcludeCategory annotation = klass.getAnnotation(ExcludeCategory.class);
    return createSet(annotation == null ? null : annotation.value());
}
 [Lines 335 - 338 ] {
    ExcludeCategory annotation = klass.getAnnotation(ExcludeCategory.class);
    return annotation == null || annotation.matchAny();
}
 [Lines 340 - 347 ] {
    for (final Class<?> from : assigns) {
        if (to.isAssignableFrom(from)) {
            return true;
        }
    }
    return false;
}
 [Lines 349 - 355 ] {
    final Set<Class<?>> set = new HashSet<Class<?>>();
    if (t != null) {
        Collections.addAll(set, t);
    }
    return set;
}

/src/main/java/org/junit/validator/AnnotationsValidator.java
============================================================
 [Lines 33 - 41 ] {
    List<Exception> validationErrors = new ArrayList<Exception>();
    for (AnnotatableValidator<?> validator : VALIDATORS) {
        List<Exception> additionalErrors = validator.validateTestClass(testClass);
        validationErrors.addAll(additionalErrors);
    }
    return validationErrors;
}
 [Lines 51 - 58 ] {
    List<Exception> validationErrors = new ArrayList<Exception>();
    for (T annotatable : getAnnotatablesForTestClass(testClass)) {
        List<Exception> additionalErrors = validateAnnotatable(annotatable);
        validationErrors.addAll(additionalErrors);
    }
    return validationErrors;
}
 [Lines 60 - 76 ] {
    List<Exception> validationErrors = new ArrayList<Exception>();
    for (Annotation annotation : annotatable.getAnnotations()) {
        Class<? extends Annotation> annotationType = annotation.annotationType();
        ValidateWith validateWith = annotationType.getAnnotation(ValidateWith.class);
        if (validateWith != null) {
            AnnotationValidator annotationValidator = ANNOTATION_VALIDATOR_FACTORY.createAnnotationValidator(validateWith);
            List<Exception> errors = validateAnnotatable(annotationValidator, annotatable);
            validationErrors.addAll(errors);
        }
    }
    return validationErrors;
}
 [Lines 81 - 83 ] {
    return singletonList(testClass);
}
 [Lines 87 - 89 ] {
    return validator.validateAnnotatedClass(testClass);
}
 [Lines 96 - 98 ] {
    return testClass.getAnnotatedMethods();
}
 [Lines 102 - 104 ] {
    return validator.validateAnnotatedMethod(method);
}
 [Lines 110 - 112 ] {
    return testClass.getAnnotatedFields();
}
 [Lines 116 - 118 ] {
    return validator.validateAnnotatedField(field);
}

/src/main/java/org/junit/validator/AnnotationValidatorFactory.java
==================================================================
 [Lines 23 - 37 ] {
    AnnotationValidator validator = VALIDATORS_FOR_ANNOTATION_TYPES.get(validateWithAnnotation);
    if (validator != null) {
        return validator;
    }
    Class<? extends AnnotationValidator> clazz = validateWithAnnotation.value();
    try {
        AnnotationValidator annotationValidator = clazz.newInstance();
        VALIDATORS_FOR_ANNOTATION_TYPES.putIfAbsent(validateWithAnnotation, annotationValidator);
        return VALIDATORS_FOR_ANNOTATION_TYPES.get(validateWithAnnotation);
    } catch (Exception e) {
        throw new RuntimeException("Exception received when creating AnnotationValidator class " + clazz.getName(), e);
    }
}

/src/main/java/org/junit/validator/AnnotationValidator.java
===========================================================
 [Lines 32 - 34 ] {
    return NO_VALIDATION_ERRORS;
}
 [Lines 44 - 47 ] {
    return NO_VALIDATION_ERRORS;
}
 [Lines 57 - 59 ] {
    return NO_VALIDATION_ERRORS;
}

/src/main/java/org/junit/validator/ValidateWith.java
====================================================

/src/main/java/org/junit/validator/TestClassValidator.java
==========================================================

/src/main/java/org/junit/validator/PublicClassValidator.java
============================================================
 [Lines 25 - 32 ] {
    if (testClass.isPublic()) {
        return NO_VALIDATION_ERRORS;
    } else {
        return singletonList(new Exception("The class " + testClass.getName() + " is not public."));
    }
}

/src/main/java/org/junit/BeforeClass.java
=========================================

/src/main/java/org/junit/ComparisonFailure.java
===============================================
 [Lines 36 - 40 ] {
    super(message);
    this.fExpected = expected;
    this.fActual = actual;
}
 [Lines 48 - 50 ] {
    return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());
}
 [Lines 57 - 59 ] {
    return fActual;
}
 [Lines 66 - 68 ] {
    return fExpected;
}
 [Lines 89 - 93 ] {
    this.contextLength = contextLength;
    this.expected = expected;
    this.actual = actual;
}
 [Lines 95 - 106 ] {
    if (expected == null || actual == null || expected.equals(actual)) {
        return Assert.format(message, expected, actual);
    } else {
        DiffExtractor extractor = new DiffExtractor();
        String compactedPrefix = extractor.compactPrefix();
        String compactedSuffix = extractor.compactSuffix();
        return Assert.format(message, compactedPrefix + extractor.expectedDiff() + compactedSuffix, compactedPrefix + extractor.actualDiff() + compactedSuffix);
    }
}
 [Lines 108 - 116 ] {
    int end = Math.min(expected.length(), actual.length());
    for (int i = 0; i < end; i++) {
        if (expected.charAt(i) != actual.charAt(i)) {
            return expected.substring(0, i);
        }
    }
    return expected.substring(0, end);
}
 [Lines 118 - 129 ] {
    int suffixLength = 0;
    int maxSuffixLength = Math.min(expected.length() - prefix.length(), actual.length() - prefix.length()) - 1;
    for (; suffixLength <= maxSuffixLength; suffixLength++) {
        if (expected.charAt(expected.length() - 1 - suffixLength) != actual.charAt(actual.length() - 1 - suffixLength)) {
            break;
        }
    }
    return expected.substring(expected.length() - suffixLength);
}
 [Lines 138 - 141 ] {
    sharedPrefix = sharedPrefix();
    sharedSuffix = sharedSuffix(sharedPrefix);
}
 [Lines 143 - 145 ] {
    return extractDiff(expected);
}
 [Lines 147 - 149 ] {
    return extractDiff(actual);
}
 [Lines 151 - 156 ] {
    if (sharedPrefix.length() <= contextLength) {
        return sharedPrefix;
    }
    return ELLIPSIS + sharedPrefix.substring(sharedPrefix.length() - contextLength);
}
 [Lines 158 - 163 ] {
    if (sharedSuffix.length() <= contextLength) {
        return sharedSuffix;
    }
    return sharedSuffix.substring(0, contextLength) + ELLIPSIS;
}
 [Lines 165 - 168 ] {
    return DIFF_START + source.substring(sharedPrefix.length(), source.length() - sharedSuffix.length()) + DIFF_END;
}

/src/main/java/org/junit/runner/FilterFactory.java
==================================================
 [Lines 21 - 23 ] {
    super(exception.getMessage(), exception);
}

/src/main/java/org/junit/runner/manipulation/Filterable.java
============================================================

/src/main/java/org/junit/runner/manipulation/Sortable.java
==========================================================

/src/main/java/org/junit/runner/manipulation/Sorter.java
========================================================
 [Lines 18 - 20 ] {
    return 0;
}
 [Lines 31 - 33 ] {
    this.comparator = comparator;
}
 [Lines 38 - 43 ] {
    if (object instanceof Sortable) {
        Sortable sortable = (Sortable) object;
        sortable.sort(this);
    }
}
 [Lines 45 - 47 ] {
    return comparator.compare(o1, o2);
}

/src/main/java/org/junit/runner/manipulation/package-info.java
==============================================================

/src/main/java/org/junit/runner/manipulation/Filter.java
========================================================
 [Lines 23 - 25 ] {
    return true;
}
 [Lines 28 - 30 ] {
    return "all tests";
}
 [Lines 33 - 35 ] {
// do nothing
}
 [Lines 38 - 40 ] {
    return second;
}
 [Lines 47 - 69 ] {
    return new Filter() {

        @Override
        public boolean shouldRun(Description description) {
            if (description.isTest()) {
                return desiredDescription.equals(description);
            }
            // explicitly check if any children want to run
            for (Description each : description.getChildren()) {
                if (shouldRun(each)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public String describe() {
            return String.format("Method %s", desiredDescription.getDisplayName());
        }
    };
}
 [Lines 92 - 98 ] {
    if (!(child instanceof Filterable)) {
        return;
    }
    Filterable filterable = (Filterable) child;
    filterable.filter(this);
}
 [Lines 104 - 121 ] {
    if (second == this || second == ALL) {
        return this;
    }
    final Filter first = this;
    return new Filter() {

        @Override
        public boolean shouldRun(Description description) {
            return first.shouldRun(description) && second.shouldRun(description);
        }

        @Override
        public String describe() {
            return first.describe() + " and " + second.describe();
        }
    };
}

/src/main/java/org/junit/runner/manipulation/NoTestsRemainException.java
========================================================================

/src/main/java/org/junit/runner/notification/Failure.java
=========================================================
 [Lines 35 - 38 ] {
    this.fThrownException = thrownException;
    this.fDescription = description;
}
 [Lines 43 - 45 ] {
    return fDescription.getDisplayName();
}
 [Lines 50 - 52 ] {
    return fDescription;
}
 [Lines 58 - 60 ] {
    return fThrownException;
}
 [Lines 63 - 65 ] {
    return getTestHeader() + ": " + fThrownException.getMessage();
}
 [Lines 72 - 77 ] {
    StringWriter stringWriter = new StringWriter();
    PrintWriter writer = new PrintWriter(stringWriter);
    getException().printStackTrace(writer);
    return stringWriter.toString();
}
 [Lines 84 - 86 ] {
    return getException().getMessage();
}

/src/main/java/org/junit/runner/notification/StoppedByUserException.java
========================================================================

/src/main/java/org/junit/runner/notification/SynchronizedRunListener.java
=========================================================================
 [Lines 27 - 30 ] {
    this.listener = listener;
    this.monitor = monitor;
}
 [Lines 33 - 37 ] {
    synchronized (monitor) {
        listener.testRunStarted(description);
    }
}
 [Lines 40 - 44 ] {
    synchronized (monitor) {
        listener.testRunFinished(result);
    }
}
 [Lines 47 - 51 ] {
    synchronized (monitor) {
        listener.testStarted(description);
    }
}
 [Lines 54 - 58 ] {
    synchronized (monitor) {
        listener.testFinished(description);
    }
}
 [Lines 61 - 65 ] {
    synchronized (monitor) {
        listener.testFailure(failure);
    }
}
 [Lines 68 - 72 ] {
    synchronized (monitor) {
        listener.testAssumptionFailure(failure);
    }
}
 [Lines 75 - 79 ] {
    synchronized (monitor) {
        listener.testIgnored(description);
    }
}
 [Lines 82 - 84 ] {
    return listener.hashCode();
}
 [Lines 87 - 97 ] {
    if (this == other) {
        return true;
    }
    if (!(other instanceof SynchronizedRunListener)) {
        return false;
    }
    SynchronizedRunListener that = (SynchronizedRunListener) other;
    return listener.equals(that.listener);
}
 [Lines 100 - 102 ] {
    return listener.toString() + " (with synchronization wrapper)";
}

/src/main/java/org/junit/runner/notification/RunListener.java
=============================================================
 [Lines 60 - 61 ] {
}
 [Lines 69 - 70 ] {
}
 [Lines 78 - 79 ] {
}
 [Lines 86 - 87 ] {
}
 [Lines 103 - 104 ] {
}
 [Lines 113 - 114 ] {
}
 [Lines 122 - 123 ] {
}

/src/main/java/org/junit/runner/notification/RunNotifier.java
=============================================================
 [Lines 28 - 33 ] {
    if (listener == null) {
        throw new NullPointerException("Cannot add a null listener");
    }
    listeners.add(wrapIfNotThreadSafe(listener));
}
 [Lines 38 - 43 ] {
    if (listener == null) {
        throw new NullPointerException("Cannot remove a null listener");
    }
    listeners.remove(wrapIfNotThreadSafe(listener));
}
 [Lines 49 - 52 ] {
    return listener.getClass().isAnnotationPresent(RunListener.ThreadSafe.class) ? listener : new SynchronizedRunListener(listener, this);
}
 [Lines 58 - 60 ] {
    this(listeners);
}
 [Lines 62 - 64 ] {
    this.currentListeners = currentListeners;
}
 [Lines 66 - 79 ] {
    int capacity = currentListeners.size();
    List<RunListener> safeListeners = new ArrayList<RunListener>(capacity);
    List<Failure> failures = new ArrayList<Failure>(capacity);
    for (RunListener listener : currentListeners) {
        try {
            notifyListener(listener);
            safeListeners.add(listener);
        } catch (Exception e) {
            failures.add(new Failure(Description.TEST_MECHANISM, e));
        }
    }
    fireTestFailures(safeListeners, failures);
}
 [Lines 87 - 94 ] {
    new SafeNotifier() {

        @Override
        protected void notifyListener(RunListener each) throws Exception {
            each.testRunStarted(description);
        }
    }.run();
}
 [Lines 99 - 106 ] {
    new SafeNotifier() {

        @Override
        protected void notifyListener(RunListener each) throws Exception {
            each.testRunFinished(result);
        }
    }.run();
}
 [Lines 114 - 124 ] {
    if (pleaseStop) {
        throw new StoppedByUserException();
    }
    new SafeNotifier() {

        @Override
        protected void notifyListener(RunListener each) throws Exception {
            each.testStarted(description);
        }
    }.run();
}
 [Lines 131 - 133 ] {
    fireTestFailures(listeners, asList(failure));
}
 [Lines 136 - 147 ] {
    if (!failures.isEmpty()) {
        new SafeNotifier(listeners) {

            @Override
            protected void notifyListener(RunListener listener) throws Exception {
                for (Failure each : failures) {
                    listener.testFailure(each);
                }
            }
        }.run();
    }
}
 [Lines 156 - 163 ] {
    new SafeNotifier() {

        @Override
        protected void notifyListener(RunListener each) throws Exception {
            each.testAssumptionFailure(failure);
        }
    }.run();
}
 [Lines 170 - 177 ] {
    new SafeNotifier() {

        @Override
        protected void notifyListener(RunListener each) throws Exception {
            each.testIgnored(description);
        }
    }.run();
}
 [Lines 186 - 193 ] {
    new SafeNotifier() {

        @Override
        protected void notifyListener(RunListener each) throws Exception {
            each.testFinished(description);
        }
    }.run();
}
 [Lines 201 - 203 ] {
    pleaseStop = true;
}
 [Lines 208 - 213 ] {
    if (listener == null) {
        throw new NullPointerException("Cannot add a null listener");
    }
    listeners.add(0, wrapIfNotThreadSafe(listener));
}

/src/main/java/org/junit/runner/notification/package-info.java
==============================================================

/src/main/java/org/junit/runner/Runner.java
===========================================
 [Lines 40 - 42 ] {
    return getDescription().testCount();
}

/src/main/java/org/junit/runner/Computer.java
=============================================
 [Lines 18 - 20 ] {
    return new Computer();
}
 [Lines 27 - 34 ] {
    return new Suite(new RunnerBuilder() {

        @Override
        public Runner runnerForClass(Class<?> testClass) throws Throwable {
            return getRunner(builder, testClass);
        }
    }, classes);
}
 [Lines 39 - 41 ] {
    return builder.runnerForClass(testClass);
}

/src/main/java/org/junit/runner/Description.java
================================================
 [Lines 44 - 46 ] {
    return new Description(null, name, annotations);
}
 [Lines 57 - 59 ] {
    return new Description(null, name, uniqueId, annotations);
}
 [Lines 72 - 74 ] {
    return new Description(null, formatDisplayName(name, className), annotations);
}
 [Lines 85 - 87 ] {
    return new Description(clazz, formatDisplayName(name, clazz.getName()), annotations);
}
 [Lines 98 - 100 ] {
    return new Description(clazz, formatDisplayName(name, clazz.getName()));
}
 [Lines 109 - 111 ] {
    return new Description(null, formatDisplayName(name, className), uniqueId);
}
 [Lines 113 - 115 ] {
    return String.format("%s(%s)", name, className);
}
 [Lines 123 - 125 ] {
    return new Description(testClass, testClass.getName(), testClass.getAnnotations());
}
 [Lines 150 - 152 ] {
    this(clazz, displayName, displayName, annotations);
}
 [Lines 154 - 167 ] {
    if ((displayName == null) || (displayName.length() == 0)) {
        throw new IllegalArgumentException("The display name must not be empty.");
    }
    if ((uniqueId == null)) {
        throw new IllegalArgumentException("The unique id must not be null.");
    }
    this.fTestClass = testClass;
    this.fDisplayName = displayName;
    this.fUniqueId = uniqueId;
    this.fAnnotations = annotations;
}
 [Lines 172 - 174 ] {
    return fDisplayName;
}
 [Lines 181 - 183 ] {
    fChildren.add(description);
}
 [Lines 189 - 191 ] {
    return new ArrayList<Description>(fChildren);
}
 [Lines 196 - 198 ] {
    return !isTest();
}
 [Lines 203 - 205 ] {
    return fChildren.isEmpty();
}
 [Lines 210 - 219 ] {
    if (isTest()) {
        return 1;
    }
    int result = 0;
    for (Description child : fChildren) {
        result += child.testCount();
    }
    return result;
}
 [Lines 222 - 224 ] {
    return fUniqueId.hashCode();
}
 [Lines 227 - 233 ] {
    if (!(obj instanceof Description)) {
        return false;
    }
    Description d = (Description) obj;
    return fUniqueId.equals(d.fUniqueId);
}
 [Lines 236 - 238 ] {
    return getDisplayName();
}
 [Lines 243 - 245 ] {
    return equals(EMPTY);
}
 [Lines 251 - 253 ] {
    return new Description(fTestClass, fDisplayName, fAnnotations);
}
 [Lines 259 - 266 ] {
    for (Annotation each : fAnnotations) {
        if (each.annotationType().equals(annotationType)) {
            return annotationType.cast(each);
        }
    }
    return null;
}
 [Lines 271 - 273 ] {
    return Arrays.asList(fAnnotations);
}
 [Lines 279 - 293 ] {
    if (fTestClass != null) {
        return fTestClass;
    }
    String name = getClassName();
    if (name == null) {
        return null;
    }
    try {
        fTestClass = Class.forName(name, false, getClass().getClassLoader());
        return fTestClass;
    } catch (ClassNotFoundException e) {
        return null;
    }
}
 [Lines 299 - 301 ] {
    return fTestClass != null ? fTestClass.getName() : methodAndClassNamePatternGroupOrDefault(2, toString());
}
 [Lines 307 - 309 ] {
    return methodAndClassNamePatternGroupOrDefault(1, null);
}
 [Lines 312 - 315 ] {
    Matcher matcher = METHOD_AND_CLASS_NAME_PATTERN.matcher(toString());
    return matcher.matches() ? matcher.group(group) : defaultString;
}

/src/main/java/org/junit/runner/RunWith.java
============================================

/src/main/java/org/junit/runner/FilterFactories.java
====================================================
 [Lines 22 - 33 ] {
    Description topLevelDescription = request.getRunner().getDescription();
    String[] tuple;
    if (filterSpec.contains("=")) {
        tuple = filterSpec.split("=", 2);
    } else {
        tuple = new String[] { filterSpec, "" };
    }
    return createFilter(tuple[0], new FilterFactoryParams(topLevelDescription, tuple[1]));
}
 [Lines 42 - 46 ] {
    FilterFactory filterFactory = createFilterFactory(filterFactoryFqcn);
    return filterFactory.createFilter(params);
}
 [Lines 56 - 60 ] {
    FilterFactory filterFactory = createFilterFactory(filterFactoryClass);
    return filterFactory.createFilter(params);
}
 [Lines 62 - 72 ] {
    Class<? extends FilterFactory> filterFactoryClass;
    try {
        filterFactoryClass = Classes.getClass(filterFactoryFqcn).asSubclass(FilterFactory.class);
    } catch (Exception e) {
        throw new FilterNotCreatedException(e);
    }
    return createFilterFactory(filterFactoryClass);
}
 [Lines 75 - 81 ] {
    try {
        return filterFactoryClass.getConstructor().newInstance();
    } catch (Exception e) {
        throw new FilterNotCreatedException(e);
    }
}

/src/main/java/org/junit/runner/FilterFactoryParams.java
========================================================
 [Lines 7 - 14 ] {
    if (args == null || topLevelDescription == null) {
        throw new NullPointerException();
    }
    this.topLevelDescription = topLevelDescription;
    this.args = args;
}
 [Lines 16 - 18 ] {
    return args;
}
 [Lines 20 - 22 ] {
    return topLevelDescription;
}

/src/main/java/org/junit/runner/JUnitCommandLineParseResult.java
================================================================
 [Lines 20 - 20 ] {
}
 [Lines 25 - 27 ] {
    return Collections.unmodifiableList(filterSpecs);
}
 [Lines 32 - 34 ] {
    return Collections.unmodifiableList(classes);
}
 [Lines 41 - 47 ] {
    JUnitCommandLineParseResult result = new JUnitCommandLineParseResult();
    result.parseArgs(args);
    return result;
}
 [Lines 49 - 51 ] {
    parseParameters(parseOptions(args));
}
 [Lines 53 - 85 ] {
    for (int i = 0; i != args.length; ++i) {
        String arg = args[i];
        if (arg.equals("--")) {
            return copyArray(args, i + 1, args.length);
        } else if (arg.startsWith("--")) {
            if (arg.startsWith("--filter=") || arg.equals("--filter")) {
                String filterSpec;
                if (arg.equals("--filter")) {
                    ++i;
                    if (i < args.length) {
                        filterSpec = args[i];
                    } else {
                        parserErrors.add(new CommandLineParserError(arg + " value not specified"));
                        break;
                    }
                } else {
                    filterSpec = arg.substring(arg.indexOf('=') + 1);
                }
                filterSpecs.add(filterSpec);
            } else {
                parserErrors.add(new CommandLineParserError("JUnit knows nothing about the " + arg + " option"));
            }
        } else {
            return copyArray(args, i, args.length);
        }
    }
    return new String[] {};
}
 [Lines 87 - 95 ] {
    ArrayList<String> result = new ArrayList<String>();
    for (int j = from; j != to; ++j) {
        result.add(args[j]);
    }
    return result.toArray(new String[result.size()]);
}
 [Lines 97 - 105 ] {
    for (String arg : args) {
        try {
            classes.add(Classes.getClass(arg));
        } catch (ClassNotFoundException e) {
            parserErrors.add(new IllegalArgumentException("Could not find class [" + arg + "]", e));
        }
    }
}
 [Lines 107 - 109 ] {
    return Request.errorReport(JUnitCommandLineParseResult.class, cause);
}
 [Lines 116 - 124 ] {
    if (parserErrors.isEmpty()) {
        Request request = Request.classes(computer, classes.toArray(new Class<?>[classes.size()]));
        return applyFilterSpecs(request);
    } else {
        return errorReport(new InitializationError(parserErrors));
    }
}
 [Lines 126 - 137 ] {
    try {
        for (String filterSpec : filterSpecs) {
            Filter filter = FilterFactories.createFilterFromFilterSpec(request, filterSpec);
            request = request.filterWith(filter);
        }
        return request;
    } catch (FilterNotCreatedException e) {
        return errorReport(e);
    }
}
 [Lines 145 - 147 ] {
    super(message);
}

/src/main/java/org/junit/runner/Describable.java
================================================

/src/main/java/org/junit/runner/JUnitCore.java
==============================================
 [Lines 35 - 38 ] {
    Result result = new JUnitCore().runMain(new RealSystem(), args);
    System.exit(result.wasSuccessful() ? 0 : 1);
}
 [Lines 48 - 50 ] {
    return runClasses(defaultComputer(), classes);
}
 [Lines 61 - 63 ] {
    return new JUnitCore().run(computer, classes);
}
 [Lines 69 - 78 ] {
    system.out().println("JUnit version " + Version.id());
    JUnitCommandLineParseResult jUnitCommandLineParseResult = JUnitCommandLineParseResult.parse(args);
    RunListener listener = new TextListener(system);
    addListener(listener);
    return run(jUnitCommandLineParseResult.createRequest(defaultComputer()));
}
 [Lines 83 - 85 ] {
    return Version.id();
}
 [Lines 93 - 95 ] {
    return run(defaultComputer(), classes);
}
 [Lines 104 - 106 ] {
    return run(Request.classes(computer, classes));
}
 [Lines 114 - 116 ] {
    return run(request.getRunner());
}
 [Lines 124 - 126 ] {
    return run(new JUnit38ClassRunner(test));
}
 [Lines 131 - 143 ] {
    Result result = new Result();
    RunListener listener = result.createListener();
    notifier.addFirstListener(listener);
    try {
        notifier.fireTestRunStarted(runner.getDescription());
        runner.run(notifier);
        notifier.fireTestRunFinished(result);
    } finally {
        removeListener(listener);
    }
    return result;
}
 [Lines 151 - 153 ] {
    notifier.addListener(listener);
}
 [Lines 160 - 162 ] {
    notifier.removeListener(listener);
}
 [Lines 164 - 166 ] {
    return new Computer();
}

/src/main/java/org/junit/runner/Result.java
===========================================
 [Lines 38 - 44 ] {
    count = new AtomicInteger();
    ignoreCount = new AtomicInteger();
    failures = new CopyOnWriteArrayList<Failure>();
    runTime = new AtomicLong();
    startTime = new AtomicLong();
}
 [Lines 46 - 52 ] {
    count = serializedForm.fCount;
    ignoreCount = serializedForm.fIgnoreCount;
    failures = new CopyOnWriteArrayList<Failure>(serializedForm.fFailures);
    runTime = new AtomicLong(serializedForm.fRunTime);
    startTime = new AtomicLong(serializedForm.fStartTime);
}
 [Lines 57 - 59 ] {
    return count.get();
}
 [Lines 64 - 66 ] {
    return failures.size();
}
 [Lines 71 - 73 ] {
    return runTime.get();
}
 [Lines 78 - 80 ] {
    return failures;
}
 [Lines 85 - 87 ] {
    return ignoreCount.get();
}
 [Lines 92 - 94 ] {
    return getFailureCount() == 0;
}
 [Lines 96 - 99 ] {
    SerializedForm serializedForm = new SerializedForm(this);
    serializedForm.serialize(s);
}
 [Lines 102 - 104 ] {
    serializedForm = SerializedForm.deserialize(s);
}
 [Lines 106 - 108 ] {
    return new Result(serializedForm);
}
 [Lines 113 - 115 ] {
    startTime.set(System.currentTimeMillis());
}
 [Lines 118 - 121 ] {
    long endTime = System.currentTimeMillis();
    runTime.addAndGet(endTime - startTime.get());
}
 [Lines 124 - 126 ] {
    count.getAndIncrement();
}
 [Lines 129 - 131 ] {
    failures.add(failure);
}
 [Lines 134 - 136 ] {
    ignoreCount.getAndIncrement();
}
 [Lines 139 - 141 ] {
// do nothing: same as passing (for 4.5; may change in 4.6)
}
 [Lines 147 - 149 ] {
    return new Listener();
}
 [Lines 163 - 169 ] {
    fCount = result.count;
    fIgnoreCount = result.ignoreCount;
    fFailures = Collections.synchronizedList(new ArrayList<Failure>(result.failures));
    fRunTime = result.runTime.longValue();
    fStartTime = result.startTime.longValue();
}
 [Lines 172 - 178 ] {
    fCount = (AtomicInteger) fields.get("fCount", null);
    fIgnoreCount = (AtomicInteger) fields.get("fIgnoreCount", null);
    fFailures = (List<Failure>) fields.get("fFailures", null);
    fRunTime = fields.get("fRunTime", 0L);
    fStartTime = fields.get("fStartTime", 0L);
}
 [Lines 180 - 188 ] {
    ObjectOutputStream.PutField fields = s.putFields();
    fields.put("fCount", fCount);
    fields.put("fIgnoreCount", fIgnoreCount);
    fields.put("fFailures", fFailures);
    fields.put("fRunTime", fRunTime);
    fields.put("fStartTime", fStartTime);
    s.writeFields();
}
 [Lines 191 - 194 ] {
    ObjectInputStream.GetField fields = s.readFields();
    return new SerializedForm(fields);
}

/src/main/java/org/junit/runner/package-info.java
=================================================

/src/main/java/org/junit/runner/Request.java
============================================
 [Lines 37 - 40 ] {
    Description method = Description.createTestDescription(clazz, methodName);
    return Request.aClass(clazz).filterWith(method);
}
 [Lines 49 - 51 ] {
    return new ClassRequest(clazz);
}
 [Lines 60 - 62 ] {
    return new ClassRequest(clazz, false);
}
 [Lines 72 - 80 ] {
    try {
        AllDefaultPossibilitiesBuilder builder = new AllDefaultPossibilitiesBuilder(true);
        Runner suite = computer.getSuite(builder, classes);
        return runner(suite);
    } catch (InitializationError e) {
        return runner(new ErrorReportingRunner(e, classes));
    }
}
 [Lines 89 - 91 ] {
    return classes(JUnitCore.defaultComputer(), classes);
}
 [Lines 98 - 100 ] {
    return runner(new ErrorReportingRunner(klass, cause));
}
 [Lines 106 - 113 ] {
    return new Request() {

        @Override
        public Runner getRunner() {
            return runner;
        }
    };
}
 [Lines 129 - 131 ] {
    return new FilterRequest(this, filter);
}
 [Lines 140 - 142 ] {
    return filterWith(Filter.matchMethodDescription(desiredDescription));
}
 [Lines 166 - 168 ] {
    return new SortingRequest(this, comparator);
}

/src/main/java/org/junit/Ignore.java
====================================

/src/main/java/org/junit/internal/builders/JUnit4Builder.java
=============================================================
 [Lines 9 - 11 ] {
    return new BlockJUnit4ClassRunner(testClass);
}

/src/main/java/org/junit/internal/builders/IgnoredClassRunner.java
==================================================================
 [Lines 10 - 12 ] {
    clazz = testClass;
}
 [Lines 15 - 17 ] {
    notifier.fireTestIgnored(getDescription());
}
 [Lines 20 - 22 ] {
    return Description.createSuiteDescription(clazz);
}

/src/main/java/org/junit/internal/builders/AnnotatedBuilder.java
================================================================
 [Lines 76 - 78 ] {
    this.suiteBuilder = suiteBuilder;
}
 [Lines 81 - 91 ] {
    for (Class<?> currentTestClass = testClass; currentTestClass != null; currentTestClass = getEnclosingClassForNonStaticMemberClass(currentTestClass)) {
        RunWith annotation = currentTestClass.getAnnotation(RunWith.class);
        if (annotation != null) {
            return buildRunner(annotation.value(), testClass);
        }
    }
    return null;
}
 [Lines 93 - 99 ] {
    if (currentTestClass.isMemberClass() && !Modifier.isStatic(currentTestClass.getModifiers())) {
        return currentTestClass.getEnclosingClass();
    } else {
        return null;
    }
}
 [Lines 102 - 115 ] {
    try {
        return runnerClass.getConstructor(Class.class).newInstance(testClass);
    } catch (NoSuchMethodException e) {
        try {
            return runnerClass.getConstructor(Class.class, RunnerBuilder.class).newInstance(testClass, suiteBuilder);
        } catch (NoSuchMethodException e2) {
            String simpleName = runnerClass.getSimpleName();
            throw new InitializationError(String.format(CONSTRUCTOR_ERROR_FORMAT, simpleName, simpleName));
        }
    }
}

/src/main/java/org/junit/internal/builders/NullBuilder.java
===========================================================
 [Lines 8 - 10 ] {
    return null;
}

/src/main/java/org/junit/internal/builders/IgnoredBuilder.java
==============================================================
 [Lines 9 - 14 ] {
    if (testClass.getAnnotation(Ignore.class) != null) {
        return new IgnoredClassRunner(testClass);
    }
    return null;
}

/src/main/java/org/junit/internal/builders/AllDefaultPossibilitiesBuilder.java
==============================================================================
 [Lines 12 - 14 ] {
    this.canUseSuiteMethod = canUseSuiteMethod;
}
 [Lines 17 - 32 ] {
    List<RunnerBuilder> builders = Arrays.asList(ignoredBuilder(), annotatedBuilder(), suiteMethodBuilder(), junit3Builder(), junit4Builder());
    for (RunnerBuilder each : builders) {
        Runner runner = each.safeRunnerForClass(testClass);
        if (runner != null) {
            return runner;
        }
    }
    return null;
}
 [Lines 34 - 36 ] {
    return new JUnit4Builder();
}
 [Lines 38 - 40 ] {
    return new JUnit3Builder();
}
 [Lines 42 - 44 ] {
    return new AnnotatedBuilder(this);
}
 [Lines 46 - 48 ] {
    return new IgnoredBuilder();
}
 [Lines 50 - 55 ] {
    if (canUseSuiteMethod) {
        return new SuiteMethodBuilder();
    }
    return new NullBuilder();
}

/src/main/java/org/junit/internal/builders/JUnit3Builder.java
=============================================================
 [Lines 9 - 14 ] {
    if (isPre4Test(testClass)) {
        return new JUnit38ClassRunner(testClass);
    }
    return null;
}
 [Lines 16 - 18 ] {
    return junit.framework.TestCase.class.isAssignableFrom(testClass);
}

/src/main/java/org/junit/internal/builders/SuiteMethodBuilder.java
==================================================================
 [Lines 9 - 14 ] {
    if (hasSuiteMethod(each)) {
        return new SuiteMethod(each);
    }
    return null;
}
 [Lines 16 - 23 ] {
    try {
        testClass.getMethod("suite");
    } catch (NoSuchMethodException e) {
        return false;
    }
    return true;
}

/src/main/java/org/junit/internal/InexactComparisonCriteria.java
================================================================
 [Lines 8 - 10 ] {
    fDelta = delta;
}
 [Lines 12 - 14 ] {
    fDelta = delta;
}
 [Lines 17 - 23 ] {
    if (expected instanceof Double) {
        Assert.assertEquals((Double) expected, (Double) actual, (Double) fDelta);
    } else {
        Assert.assertEquals((Float) expected, (Float) actual, (Float) fDelta);
    }
}

/src/main/java/org/junit/internal/ArrayComparisonFailure.java
=============================================================
 [Lines 33 - 37 ] {
    this.fMessage = message;
    initCause(cause);
    addDimension(index);
}
 [Lines 39 - 41 ] {
    fIndices.add(0, index);
}
 [Lines 44 - 58 ] {
    StringBuilder sb = new StringBuilder();
    if (fMessage != null) {
        sb.append(fMessage);
    }
    sb.append("arrays first differed at element ");
    for (int each : fIndices) {
        sb.append("[");
        sb.append(each);
        sb.append("]");
    }
    sb.append("; ");
    sb.append(getCause().getMessage());
    return sb.toString();
}
 [Lines 64 - 66 ] {
    return getMessage();
}

/src/main/java/org/junit/internal/requests/ClassRequest.java
============================================================
 [Lines 19 - 22 ] {
    this.fTestClass = testClass;
    this.canUseSuiteMethod = canUseSuiteMethod;
}
 [Lines 24 - 26 ] {
    this(testClass, true);
}
 [Lines 29 - 38 ] {
    if (runner == null) {
        synchronized (runnerLock) {
            if (runner == null) {
                runner = new AllDefaultPossibilitiesBuilder(canUseSuiteMethod).safeRunnerForClass(fTestClass);
            }
        }
    }
    return runner;
}

/src/main/java/org/junit/internal/requests/SortingRequest.java
==============================================================
 [Lines 14 - 17 ] {
    this.request = request;
    this.comparator = comparator;
}
 [Lines 20 - 24 ] {
    Runner runner = request.getRunner();
    new Sorter(comparator).apply(runner);
    return runner;
}

/src/main/java/org/junit/internal/requests/FilterRequest.java
=============================================================
 [Lines 28 - 31 ] {
    this.request = request;
    this.fFilter = filter;
}
 [Lines 34 - 44 ] {
    try {
        Runner runner = request.getRunner();
        fFilter.apply(runner);
        return runner;
    } catch (NoTestsRemainException e) {
        return new ErrorReportingRunner(Filter.class, new Exception(String.format("No tests found matching %s from %s", fFilter.describe(), request.toString())));
    }
}

/src/main/java/org/junit/internal/requests/package-info.java
============================================================

/src/main/java/org/junit/internal/Throwables.java
=================================================
 [Lines 11 - 12 ] {
}
 [Lines 33 - 36 ] {
    Throwables.<Exception>rethrow(e);
    // we never get here
    return null;
}
 [Lines 39 - 41 ] {
    throw (T) e;
}

/src/main/java/org/junit/internal/JUnitSystem.java
==================================================

/src/main/java/org/junit/internal/RealSystem.java
=================================================
 [Lines 11 - 13 ] {
    System.exit(code);
}
 [Lines 15 - 17 ] {
    return System.out;
}

/src/main/java/org/junit/internal/MethodSorter.java
===================================================
 [Lines 14 - 21 ] {
    int i1 = m1.getName().hashCode();
    int i2 = m2.getName().hashCode();
    if (i1 != i2) {
        return i1 < i2 ? -1 : 1;
    }
    return NAME_ASCENDING.compare(m1, m2);
}
 [Lines 28 - 34 ] {
    final int comparison = m1.getName().compareTo(m2.getName());
    if (comparison != 0) {
        return comparison;
    }
    return m1.toString().compareTo(m2.toString());
}
 [Lines 51 - 60 ] {
    Comparator<Method> comparator = getSorter(clazz.getAnnotation(FixMethodOrder.class));
    Method[] methods = clazz.getDeclaredMethods();
    if (comparator != null) {
        Arrays.sort(methods, comparator);
    }
    return methods;
}
 [Lines 62 - 63 ] {
}
 [Lines 65 - 71 ] {
    if (fixMethodOrder == null) {
        return DEFAULT;
    }
    return fixMethodOrder.value().getComparator();
}

/src/main/java/org/junit/internal/ComparisonCriteria.java
=========================================================
 [Lines 27 - 29 ] {
    arrayEquals(message, expecteds, actuals, true);
}
 [Lines 32 - 68 ] {
    if (expecteds == actuals || Arrays.deepEquals(new Object[] { expecteds }, new Object[] { actuals })) {
        // the arrays are exactly equal.
        return;
    }
    String header = message == null ? "" : message + ": ";
    // Only include the user-provided message in the outer exception.
    String exceptionMessage = outer ? header : "";
    int expectedsLength = assertArraysAreSameLength(expecteds, actuals, exceptionMessage);
    for (int i = 0; i < expectedsLength; i++) {
        Object expected = Array.get(expecteds, i);
        Object actual = Array.get(actuals, i);
        if (isArray(expected) && isArray(actual)) {
            try {
                arrayEquals(message, expected, actual, false);
            } catch (ArrayComparisonFailure e) {
                e.addDimension(i);
                throw e;
            } catch (AssertionError e) {
                // Array lengths differed.
                throw new ArrayComparisonFailure(header, e, i);
            }
        } else {
            try {
                assertElementsEqual(expected, actual);
            } catch (AssertionError e) {
                throw new ArrayComparisonFailure(header, e, i);
            }
        }
    }
}
 [Lines 70 - 72 ] {
    return expected != null && expected.getClass().isArray();
}
 [Lines 75 - 89 ] {
    if (expecteds == null) {
        Assert.fail(header + "expected array was null");
    }
    if (actuals == null) {
        Assert.fail(header + "actual array was null");
    }
    int actualsLength = Array.getLength(actuals);
    int expectedsLength = Array.getLength(expecteds);
    if (actualsLength != expectedsLength) {
        Assert.fail(header + "array lengths differed, expected.length=" + expectedsLength + " actual.length=" + actualsLength);
    }
    return expectedsLength;
}

/src/main/java/org/junit/internal/Classes.java
==============================================
 [Lines 15 - 16 ] {
}
 [Lines 24 - 26 ] {
    return Class.forName(className, true, currentThread().getContextClassLoader());
}

/src/main/java/org/junit/internal/TextListener.java
===================================================
 [Lines 16 - 18 ] {
    this(system.out());
}
 [Lines 20 - 22 ] {
    this.writer = writer;
}
 [Lines 25 - 29 ] {
    printHeader(result.getRunTime());
    printFailures(result);
    printFooter(result);
}
 [Lines 32 - 34 ] {
    writer.append('.');
}
 [Lines 37 - 39 ] {
    writer.append('E');
}
 [Lines 42 - 44 ] {
    writer.append('I');
}
 [Lines 50 - 52 ] {
    return writer;
}
 [Lines 54 - 57 ] {
    getWriter().println();
    getWriter().println("Time: " + elapsedTimeAsString(runTime));
}
 [Lines 59 - 73 ] {
    List<Failure> failures = result.getFailures();
    if (failures.isEmpty()) {
        return;
    }
    if (failures.size() == 1) {
        getWriter().println("There was " + failures.size() + " failure:");
    } else {
        getWriter().println("There were " + failures.size() + " failures:");
    }
    int i = 1;
    for (Failure each : failures) {
        printFailure(each, "" + i++);
    }
}
 [Lines 75 - 78 ] {
    getWriter().println(prefix + ") " + each.getTestHeader());
    getWriter().print(each.getTrace());
}
 [Lines 80 - 92 ] {
    if (result.wasSuccessful()) {
        getWriter().println();
        getWriter().print("OK");
        getWriter().println(" (" + result.getRunCount() + " test" + (result.getRunCount() == 1 ? "" : "s") + ")");
    } else {
        getWriter().println();
        getWriter().println("FAILURES!!!");
        getWriter().println("Tests run: " + result.getRunCount() + ",  Failures: " + result.getFailureCount());
    }
    getWriter().println();
}
 [Lines 98 - 100 ] {
    return NumberFormat.getInstance().format((double) runTime / 1000);
}

/src/main/java/org/junit/internal/AssumptionViolatedException.java
==================================================================
 [Lines 32 - 41 ] {
    this.fAssumption = assumption;
    this.fValue = value;
    this.fMatcher = matcher;
    this.fValueMatcher = hasValue;
    if (value instanceof Throwable) {
        initCause((Throwable) value);
    }
}
 [Lines 50 - 52 ] {
    this(null, true, value, matcher);
}
 [Lines 61 - 63 ] {
    this(assumption, true, value, matcher);
}
 [Lines 71 - 73 ] {
    this(assumption, false, null, null);
}
 [Lines 81 - 84 ] {
    this(assumption, false, null, null);
    initCause(e);
}
 [Lines 87 - 89 ] {
    return StringDescription.asString(this);
}
 [Lines 91 - 110 ] {
    if (fAssumption != null) {
        description.appendText(fAssumption);
    }
    if (fValueMatcher) {
        // a value was passed in when this instance was constructed; print it
        if (fAssumption != null) {
            description.appendText(": ");
        }
        description.appendText("got: ");
        description.appendValue(fValue);
        if (fMatcher != null) {
            description.appendText(", expected: ");
            description.appendDescriptionOf(fMatcher);
        }
    }
}

/src/main/java/org/junit/internal/runners/TestClass.java
========================================================
 [Lines 26 - 28 ] {
    this.klass = klass;
}
 [Lines 30 - 32 ] {
    return getAnnotatedMethods(Test.class);
}
 [Lines 34 - 36 ] {
    return getAnnotatedMethods(BeforeClass.class);
}
 [Lines 38 - 40 ] {
    return getAnnotatedMethods(AfterClass.class);
}
 [Lines 42 - 57 ] {
    List<Method> results = new ArrayList<Method>();
    for (Class<?> eachClass : getSuperClasses(klass)) {
        Method[] methods = MethodSorter.getDeclaredMethods(eachClass);
        for (Method eachMethod : methods) {
            Annotation annotation = eachMethod.getAnnotation(annotationClass);
            if (annotation != null && !isShadowed(eachMethod, results)) {
                results.add(eachMethod);
            }
        }
    }
    if (runsTopToBottom(annotationClass)) {
        Collections.reverse(results);
    }
    return results;
}
 [Lines 59 - 61 ] {
    return annotation.equals(Before.class) || annotation.equals(BeforeClass.class);
}
 [Lines 63 - 70 ] {
    for (Method each : results) {
        if (isShadowed(method, each)) {
            return true;
        }
    }
    return false;
}
 [Lines 72 - 85 ] {
    if (!previous.getName().equals(current.getName())) {
        return false;
    }
    if (previous.getParameterTypes().length != current.getParameterTypes().length) {
        return false;
    }
    for (int i = 0; i < previous.getParameterTypes().length; i++) {
        if (!previous.getParameterTypes()[i].equals(current.getParameterTypes()[i])) {
            return false;
        }
    }
    return true;
}
 [Lines 87 - 95 ] {
    List<Class<?>> results = new ArrayList<Class<?>>();
    Class<?> current = testClass;
    while (current != null) {
        results.add(current);
        current = current.getSuperclass();
    }
    return results;
}
 [Lines 97 - 99 ] {
    return klass.getConstructor();
}
 [Lines 101 - 103 ] {
    return klass;
}
 [Lines 105 - 107 ] {
    return klass.getName();
}

/src/main/java/org/junit/internal/runners/TestMethod.java
=========================================================
 [Lines 24 - 27 ] {
    this.method = method;
    this.testClass = testClass;
}
 [Lines 29 - 31 ] {
    return method.getAnnotation(Ignore.class) != null;
}
 [Lines 33 - 40 ] {
    Test annotation = method.getAnnotation(Test.class);
    if (annotation == null) {
        return 0;
    }
    long timeout = annotation.timeout();
    return timeout;
}
 [Lines 42 - 49 ] {
    Test annotation = method.getAnnotation(Test.class);
    if (annotation == null || annotation.expected() == None.class) {
        return null;
    } else {
        return annotation.expected();
    }
}
 [Lines 51 - 53 ] {
    return !getExpectedException().isAssignableFrom(exception.getClass());
}
 [Lines 55 - 57 ] {
    return getExpectedException() != null;
}
 [Lines 59 - 61 ] {
    return testClass.getAnnotatedMethods(Before.class);
}
 [Lines 63 - 65 ] {
    return testClass.getAnnotatedMethods(After.class);
}
 [Lines 67 - 69 ] {
    method.invoke(test);
}

/src/main/java/org/junit/internal/runners/MethodRoadie.java
===========================================================
 [Lines 32 - 37 ] {
    this.test = test;
    this.notifier = notifier;
    this.description = description;
    testMethod = method;
}
 [Lines 39 - 55 ] {
    if (testMethod.isIgnored()) {
        notifier.fireTestIgnored(description);
        return;
    }
    notifier.fireTestStarted(description);
    try {
        long timeout = testMethod.getTimeout();
        if (timeout > 0) {
            runWithTimeout(timeout);
        } else {
            runTest();
        }
    } finally {
        notifier.fireTestFinished(description);
    }
}
 [Lines 57 - 84 ] {
    runBeforesThenTestThenAfters(new Runnable() {

        public void run() {
            ExecutorService service = Executors.newSingleThreadExecutor();
            Callable<Object> callable = new Callable<Object>() {

                public Object call() throws Exception {
                    runTestMethod();
                    return null;
                }
            };
            Future<Object> result = service.submit(callable);
            service.shutdown();
            try {
                boolean terminated = service.awaitTermination(timeout, TimeUnit.MILLISECONDS);
                if (!terminated) {
                    service.shutdownNow();
                }
                // throws the exception if one occurred during the invocation
                result.get(0, TimeUnit.MILLISECONDS);
            } catch (TimeoutException e) {
                addFailure(new TestTimedOutException(timeout, TimeUnit.MILLISECONDS));
            } catch (Exception e) {
                addFailure(e);
            }
        }
    });
}
 [Lines 86 - 92 ] {
    runBeforesThenTestThenAfters(new Runnable() {

        public void run() {
            runTestMethod();
        }
    });
}
 [Lines 94 - 104 ] {
    try {
        runBefores();
        test.run();
    } catch (FailedBefore e) {
    } catch (Exception e) {
        throw new RuntimeException("test should never throw an exception to this level");
    } finally {
        runAfters();
    }
}
 [Lines 106 - 126 ] {
    try {
        testMethod.invoke(test);
        if (testMethod.expectsException()) {
            addFailure(new AssertionError("Expected exception: " + testMethod.getExpectedException().getName()));
        }
    } catch (InvocationTargetException e) {
        Throwable actual = e.getTargetException();
        if (actual instanceof AssumptionViolatedException) {
            return;
        } else if (!testMethod.expectsException()) {
            addFailure(actual);
        } else if (testMethod.isUnexpected(actual)) {
            String message = "Unexpected exception, expected<" + testMethod.getExpectedException().getName() + "> but was<" + actual.getClass().getName() + ">";
            addFailure(new Exception(message, actual));
        }
    } catch (Throwable e) {
        addFailure(e);
    }
}
 [Lines 128 - 144 ] {
    try {
        try {
            List<Method> befores = testMethod.getBefores();
            for (Method before : befores) {
                before.invoke(test);
            }
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    } catch (AssumptionViolatedException e) {
        throw new FailedBefore();
    } catch (Throwable e) {
        addFailure(e);
        throw new FailedBefore();
    }
}
 [Lines 146 - 157 ] {
    List<Method> afters = testMethod.getAfters();
    for (Method after : afters) {
        try {
            after.invoke(test);
        } catch (InvocationTargetException e) {
            addFailure(e.getTargetException());
        } catch (Throwable e) {
            // Untested, but seems impossible
            addFailure(e);
        }
    }
}
 [Lines 159 - 161 ] {
    notifier.fireTestFailure(new Failure(description, e));
}

/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java
=================================================================
 [Lines 28 - 30 ] {
    this.notifier = notifier;
}
 [Lines 32 - 34 ] {
    notifier.fireTestFinished(asDescription(test));
}
 [Lines 36 - 38 ] {
    notifier.fireTestStarted(asDescription(test));
}
 [Lines 41 - 44 ] {
    Failure failure = new Failure(asDescription(test), e);
    notifier.fireTestFailure(failure);
}
 [Lines 46 - 52 ] {
    if (test instanceof Describable) {
        Describable facade = (Describable) test;
        return facade.getDescription();
    }
    return Description.createTestDescription(getEffectiveClass(test), getName(test));
}
 [Lines 54 - 56 ] {
    return test.getClass();
}
 [Lines 58 - 64 ] {
    if (test instanceof TestCase) {
        return ((TestCase) test).getName();
    } else {
        return test.toString();
    }
}
 [Lines 66 - 68 ] {
    addError(test, t);
}
 [Lines 73 - 75 ] {
    this(new TestSuite(klass.asSubclass(TestCase.class)));
}
 [Lines 77 - 80 ] {
    super();
    setTest(test);
}
 [Lines 83 - 87 ] {
    TestResult result = new TestResult();
    result.addListener(createAdaptingListener(notifier));
    getTest().run(result);
}
 [Lines 89 - 91 ] {
    return new OldTestClassAdaptingListener(notifier);
}
 [Lines 94 - 96 ] {
    return makeDescription(getTest());
}
 [Lines 98 - 123 ] {
    if (test instanceof TestCase) {
        TestCase tc = (TestCase) test;
        return Description.createTestDescription(tc.getClass(), tc.getName(), getAnnotations(tc));
    } else if (test instanceof TestSuite) {
        TestSuite ts = (TestSuite) test;
        String name = ts.getName() == null ? createSuiteDescription(ts) : ts.getName();
        Description description = Description.createSuiteDescription(name);
        int n = ts.testCount();
        for (int i = 0; i < n; i++) {
            Description made = makeDescription(ts.testAt(i));
            description.addChild(made);
        }
        return description;
    } else if (test instanceof Describable) {
        Describable adapter = (Describable) test;
        return adapter.getDescription();
    } else if (test instanceof TestDecorator) {
        TestDecorator decorator = (TestDecorator) test;
        return makeDescription(decorator.getTest());
    } else {
        // This is the best we can do in this case
        return Description.createSuiteDescription(test.getClass());
    }
}
 [Lines 129 - 137 ] {
    try {
        Method m = test.getClass().getMethod(test.getName());
        return m.getDeclaredAnnotations();
    } catch (SecurityException e) {
    } catch (NoSuchMethodException e) {
    }
    return new Annotation[0];
}
 [Lines 139 - 143 ] {
    int count = ts.countTestCases();
    String example = count == 0 ? "" : String.format(" [example: %s]", ts.testAt(0));
    return String.format("TestSuite with %s tests%s", count, example);
}
 [Lines 145 - 164 ] {
    if (getTest() instanceof Filterable) {
        Filterable adapter = (Filterable) getTest();
        adapter.filter(filter);
    } else if (getTest() instanceof TestSuite) {
        TestSuite suite = (TestSuite) getTest();
        TestSuite filtered = new TestSuite(suite.getName());
        int n = suite.testCount();
        for (int i = 0; i < n; i++) {
            Test test = suite.testAt(i);
            if (filter.shouldRun(makeDescription(test))) {
                filtered.addTest(test);
            }
        }
        setTest(filtered);
        if (filtered.testCount() == 0) {
            throw new NoTestsRemainException();
        }
    }
}
 [Lines 166 - 171 ] {
    if (getTest() instanceof Sortable) {
        Sortable adapter = (Sortable) getTest();
        adapter.sort(sorter);
    }
}
 [Lines 173 - 175 ] {
    this.test = test;
}
 [Lines 177 - 179 ] {
    return test;
}

/src/main/java/org/junit/internal/runners/JUnit4ClassRunner.java
================================================================
 [Lines 32 - 36 ] {
    testClass = new TestClass(klass);
    testMethods = getTestMethods();
    validate();
}
 [Lines 38 - 40 ] {
    return testClass.getTestMethods();
}
 [Lines 42 - 46 ] {
    MethodValidator methodValidator = new MethodValidator(testClass);
    methodValidator.validateMethodsForDefaultRunner();
    methodValidator.assertValid();
}
 [Lines 49 - 55 ] {
    new ClassRoadie(notifier, testClass, getDescription(), new Runnable() {

        public void run() {
            runMethods(notifier);
        }
    }).runProtected();
}
 [Lines 57 - 61 ] {
    for (Method method : testMethods) {
        invokeTestMethod(method, notifier);
    }
}
 [Lines 64 - 71 ] {
    Description spec = Description.createSuiteDescription(getName(), classAnnotations());
    List<Method> testMethods = this.testMethods;
    for (Method method : testMethods) {
        spec.addChild(methodDescription(method));
    }
    return spec;
}
 [Lines 73 - 75 ] {
    return testClass.getJavaClass().getAnnotations();
}
 [Lines 77 - 79 ] {
    return getTestClass().getName();
}
 [Lines 81 - 83 ] {
    return getTestClass().getConstructor().newInstance();
}
 [Lines 85 - 99 ] {
    Description description = methodDescription(method);
    Object test;
    try {
        test = createTest();
    } catch (InvocationTargetException e) {
        testAborted(notifier, description, e.getCause());
        return;
    } catch (Exception e) {
        testAborted(notifier, description, e);
        return;
    }
    TestMethod testMethod = wrapMethod(method);
    new MethodRoadie(test, testMethod, notifier, description).run();
}
 [Lines 102 - 106 ] {
    notifier.fireTestStarted(description);
    notifier.fireTestFailure(new Failure(description, e));
    notifier.fireTestFinished(description);
}
 [Lines 108 - 110 ] {
    return new TestMethod(method, testClass);
}
 [Lines 112 - 114 ] {
    return method.getName();
}
 [Lines 116 - 118 ] {
    return Description.createTestDescription(getTestClass().getJavaClass(), testName(method), testAnnotations(method));
}
 [Lines 120 - 122 ] {
    return method.getAnnotations();
}
 [Lines 124 - 134 ] {
    for (Iterator<Method> iter = testMethods.iterator(); iter.hasNext(); ) {
        Method method = iter.next();
        if (!filter.shouldRun(methodDescription(method))) {
            iter.remove();
        }
    }
    if (testMethods.isEmpty()) {
        throw new NoTestsRemainException();
    }
}
 [Lines 136 - 142 ] {
    Collections.sort(testMethods, new Comparator<Method>() {

        public int compare(Method o1, Method o2) {
            return sorter.compare(methodDescription(o1), methodDescription(o2));
        }
    });
}
 [Lines 144 - 146 ] {
    return testClass;
}

/src/main/java/org/junit/internal/runners/MethodValidator.java
==============================================================
 [Lines 28 - 30 ] {
    this.testClass = testClass;
}
 [Lines 32 - 41 ] {
    validateTestMethods(After.class, false);
    validateTestMethods(Before.class, false);
    validateTestMethods(Test.class, false);
    List<Method> methods = testClass.getAnnotatedMethods(Test.class);
    if (methods.size() == 0) {
        errors.add(new Exception("No runnable methods"));
    }
}
 [Lines 43 - 46 ] {
    validateTestMethods(BeforeClass.class, true);
    validateTestMethods(AfterClass.class, true);
}
 [Lines 48 - 53 ] {
    validateNoArgConstructor();
    validateStaticMethods();
    validateInstanceMethods();
    return errors;
}
 [Lines 55 - 59 ] {
    if (!errors.isEmpty()) {
        throw new InitializationError(errors);
    }
}
 [Lines 61 - 67 ] {
    try {
        testClass.getConstructor();
    } catch (Exception e) {
        errors.add(new Exception("Test class should have public zero-argument constructor", e));
    }
}
 [Lines 70 - 96 ] {
    List<Method> methods = testClass.getAnnotatedMethods(annotation);
    for (Method each : methods) {
        if (Modifier.isStatic(each.getModifiers()) != isStatic) {
            String state = isStatic ? "should" : "should not";
            errors.add(new Exception("Method " + each.getName() + "() " + state + " be static"));
        }
        if (!Modifier.isPublic(each.getDeclaringClass().getModifiers())) {
            errors.add(new Exception("Class " + each.getDeclaringClass().getName() + " should be public"));
        }
        if (!Modifier.isPublic(each.getModifiers())) {
            errors.add(new Exception("Method " + each.getName() + " should be public"));
        }
        if (each.getReturnType() != Void.TYPE) {
            errors.add(new Exception("Method " + each.getName() + "should have a return type of void"));
        }
        if (each.getParameterTypes().length != 0) {
            errors.add(new Exception("Method " + each.getName() + " should have no parameters"));
        }
    }
}

/src/main/java/org/junit/internal/runners/FailedBefore.java
===========================================================

/src/main/java/org/junit/internal/runners/ErrorReportingRunner.java
===================================================================
 [Lines 18 - 20 ] {
    this(cause, new Class<?>[] { testClass });
}
 [Lines 22 - 33 ] {
    if (testClasses == null || testClasses.length == 0) {
        throw new NullPointerException("Test classes cannot be null or empty");
    }
    for (Class<?> testClass : testClasses) {
        if (testClass == null) {
            throw new NullPointerException("Test class cannot be null");
        }
    }
    classNames = getClassNames(testClasses);
    causes = getCauses(cause);
}
 [Lines 36 - 42 ] {
    Description description = Description.createSuiteDescription(classNames);
    for (Throwable each : causes) {
        description.addChild(describeCause(each));
    }
    return description;
}
 [Lines 45 - 49 ] {
    for (Throwable each : causes) {
        runCause(each, notifier);
    }
}
 [Lines 51 - 60 ] {
    final StringBuilder builder = new StringBuilder();
    for (Class<?> testClass : testClasses) {
        if (builder.length() != 0) {
            builder.append(", ");
        }
        builder.append(testClass.getName());
    }
    return builder.toString();
}
 [Lines 63 - 75 ] {
    if (cause instanceof InvocationTargetException) {
        return getCauses(cause.getCause());
    }
    if (cause instanceof InitializationError) {
        return ((InitializationError) cause).getCauses();
    }
    if (cause instanceof org.junit.internal.runners.InitializationError) {
        return ((org.junit.internal.runners.InitializationError) cause).getCauses();
    }
    return Arrays.asList(cause);
}
 [Lines 77 - 79 ] {
    return Description.createTestDescription(classNames, "initializationError");
}
 [Lines 81 - 86 ] {
    Description description = describeCause(child);
    notifier.fireTestStarted(description);
    notifier.fireTestFailure(new Failure(description, child));
    notifier.fireTestFinished(description);
}

/src/main/java/org/junit/internal/runners/statements/Fail.java
==============================================================
 [Lines 8 - 10 ] {
    error = e;
}
 [Lines 13 - 15 ] {
    throw error;
}

/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java
=======================================================================
 [Lines 30 - 32 ] {
    return new Builder();
}
 [Lines 42 - 44 ] {
    this(builder().withTimeout(timeoutMillis, TimeUnit.MILLISECONDS), statement);
}
 [Lines 46 - 51 ] {
    originalStatement = statement;
    timeout = builder.timeout;
    timeUnit = builder.unit;
    lookForStuckThread = builder.lookForStuckThread;
}
 [Lines 63 - 64 ] {
}
 [Lines 79 - 89 ] {
    if (timeout < 0) {
        throw new IllegalArgumentException("timeout must be non-negative");
    }
    if (unit == null) {
        throw new NullPointerException("TimeUnit cannot be null");
    }
    this.timeout = timeout;
    this.unit = unit;
    return this;
}
 [Lines 100 - 103 ] {
    this.lookForStuckThread = enable;
    return this;
}
 [Lines 111 - 116 ] {
    if (statement == null) {
        throw new NullPointerException("statement cannot be null");
    }
    return new FailOnTimeout(this, statement);
}
 [Lines 120 - 132 ] {
    CallableStatement callable = new CallableStatement();
    FutureTask<Throwable> task = new FutureTask<Throwable>(callable);
    ThreadGroup threadGroup = new ThreadGroup("FailOnTimeoutGroup");
    Thread thread = new Thread(threadGroup, task, "Time-limited test");
    thread.setDaemon(true);
    thread.start();
    callable.awaitStarted();
    Throwable throwable = getResult(task, thread);
    if (throwable != null) {
        throw throwable;
    }
}
 [Lines 139 - 154 ] {
    try {
        if (timeout > 0) {
            return task.get(timeout, timeUnit);
        } else {
            return task.get();
        }
    } catch (InterruptedException e) {
        // caller will re-throw; no need to call Thread.interrupt()
        return e;
    } catch (ExecutionException e) {
        // test failed; have caller re-throw the exception thrown by the test
        return e.getCause();
    } catch (TimeoutException e) {
        return createTimeoutException(thread);
    }
}
 [Lines 156 - 174 ] {
    StackTraceElement[] stackTrace = thread.getStackTrace();
    final Thread stuckThread = lookForStuckThread ? getStuckThread(thread) : null;
    Exception currThreadException = new TestTimedOutException(timeout, timeUnit);
    if (stackTrace != null) {
        currThreadException.setStackTrace(stackTrace);
        thread.interrupt();
    }
    if (stuckThread != null) {
        Exception stuckThreadException = new Exception("Appears to be stuck in thread " + stuckThread.getName());
        stuckThreadException.setStackTrace(getStackTrace(stuckThread));
        return new MultipleFailureException(Arrays.<Throwable>asList(currThreadException, stuckThreadException));
    } else {
        return currThreadException;
    }
}
 [Lines 182 - 188 ] {
    try {
        return thread.getStackTrace();
    } catch (SecurityException e) {
        return new StackTraceElement[0];
    }
}
 [Lines 200 - 223 ] {
    List<Thread> threadsInGroup = getThreadsInGroup(mainThread.getThreadGroup());
    if (threadsInGroup.isEmpty()) {
        return null;
    }
    // Now that we have all the threads in the test's thread group: Assume that
    // any thread we're "stuck" in is RUNNABLE.  Look for all RUNNABLE threads. 
    // If just one, we return that (unless it equals threadMain).  If there's more
    // than one, pick the one that's using the most CPU time, if this feature is
    // supported.
    Thread stuckThread = null;
    long maxCpuTime = 0;
    for (Thread thread : threadsInGroup) {
        if (thread.getState() == Thread.State.RUNNABLE) {
            long threadCpuTime = cpuTime(thread);
            if (stuckThread == null || threadCpuTime > maxCpuTime) {
                stuckThread = thread;
                maxCpuTime = threadCpuTime;
            }
        }
    }
    return (stuckThread == mainThread) ? null : stuckThread;
}
 [Lines 233 - 250 ] {
    // this is just an estimate
    final int activeThreadCount = group.activeCount();
    int threadArraySize = Math.max(activeThreadCount * 2, 100);
    for (int loopCount = 0; loopCount < 5; loopCount++) {
        Thread[] threads = new Thread[threadArraySize];
        int enumCount = group.enumerate(threads);
        if (enumCount < threadArraySize) {
            return Arrays.asList(threads).subList(0, enumCount);
        }
        // if there are too many threads to fit into the array, enumerate's result
        // is >= the array's length; therefore we can't trust that it returned all
        // the threads.  Try again.
        threadArraySize += 100;
    }
    // trouble.
    return Collections.emptyList();
}
 [Lines 257 - 266 ] {
    ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();
    if (mxBean.isThreadCpuTimeSupported()) {
        try {
            return mxBean.getThreadCpuTime(thr.getId());
        } catch (UnsupportedOperationException e) {
        }
    }
    return 0;
}
 [Lines 271 - 281 ] {
    try {
        startLatch.countDown();
        originalStatement.evaluate();
    } catch (Exception e) {
        throw e;
    } catch (Throwable e) {
        return e;
    }
    return null;
}
 [Lines 283 - 285 ] {
    startLatch.await();
}

/src/main/java/org/junit/internal/runners/statements/RunBefores.java
====================================================================
 [Lines 15 - 19 ] {
    this.next = next;
    this.befores = befores;
    this.target = target;
}
 [Lines 22 - 27 ] {
    for (FrameworkMethod before : befores) {
        before.invokeExplosively(target);
    }
    next.evaluate();
}

/src/main/java/org/junit/internal/runners/statements/InvokeMethod.java
======================================================================
 [Lines 10 - 13 ] {
    this.testMethod = testMethod;
    this.target = target;
}
 [Lines 16 - 18 ] {
    testMethod.invokeExplosively(target);
}

/src/main/java/org/junit/internal/runners/statements/ExpectException.java
=========================================================================
 [Lines 10 - 13 ] {
    this.next = next;
    this.expected = expected;
}
 [Lines 16 - 35 ] {
    boolean complete = false;
    try {
        next.evaluate();
        complete = true;
    } catch (AssumptionViolatedException e) {
        throw e;
    } catch (Throwable e) {
        if (!expected.isAssignableFrom(e.getClass())) {
            String message = "Unexpected exception, expected<" + expected.getName() + "> but was<" + e.getClass().getName() + ">";
            throw new Exception(message, e);
        }
    }
    if (complete) {
        throw new AssertionError("Expected exception: " + expected.getName());
    }
}

/src/main/java/org/junit/internal/runners/statements/RunAfters.java
===================================================================
 [Lines 17 - 21 ] {
    this.next = next;
    this.afters = afters;
    this.target = target;
}
 [Lines 24 - 40 ] {
    List<Throwable> errors = new ArrayList<Throwable>();
    try {
        next.evaluate();
    } catch (Throwable e) {
        errors.add(e);
    } finally {
        for (FrameworkMethod each : afters) {
            try {
                each.invokeExplosively(target);
            } catch (Throwable e) {
                errors.add(e);
            }
        }
    }
    MultipleFailureException.assertEmpty(errors);
}

/src/main/java/org/junit/internal/runners/ClassRoadie.java
==========================================================
 [Lines 26 - 31 ] {
    this.notifier = notifier;
    this.testClass = testClass;
    this.description = description;
    this.runnable = runnable;
}
 [Lines 33 - 35 ] {
    runnable.run();
}
 [Lines 37 - 39 ] {
    notifier.fireTestFailure(new Failure(description, targetException));
}
 [Lines 41 - 49 ] {
    try {
        runBefores();
        runUnprotected();
    } catch (FailedBefore e) {
    } finally {
        runAfters();
    }
}
 [Lines 51 - 67 ] {
    try {
        try {
            List<Method> befores = testClass.getBefores();
            for (Method before : befores) {
                before.invoke(null);
            }
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    } catch (AssumptionViolatedException e) {
        throw new FailedBefore();
    } catch (Throwable e) {
        addFailure(e);
        throw new FailedBefore();
    }
}
 [Lines 69 - 80 ] {
    List<Method> afters = testClass.getAfters();
    for (Method after : afters) {
        try {
            after.invoke(null);
        } catch (InvocationTargetException e) {
            addFailure(e.getTargetException());
        } catch (Throwable e) {
            // Untested, but seems impossible
            addFailure(e);
        }
    }
}

/src/main/java/org/junit/internal/runners/model/ReflectiveCallable.java
=======================================================================
 [Lines 10 - 16 ] {
    try {
        return runReflectiveCall();
    } catch (InvocationTargetException e) {
        throw e.getTargetException();
    }
}

/src/main/java/org/junit/internal/runners/model/EachTestNotifier.java
=====================================================================
 [Lines 14 - 17 ] {
    this.notifier = notifier;
    this.description = description;
}
 [Lines 19 - 25 ] {
    if (targetException instanceof MultipleFailureException) {
        addMultipleFailureException((MultipleFailureException) targetException);
    } else {
        notifier.fireTestFailure(new Failure(description, targetException));
    }
}
 [Lines 27 - 31 ] {
    for (Throwable each : mfe.getFailures()) {
        addFailure(each);
    }
}
 [Lines 33 - 35 ] {
    notifier.fireTestAssumptionFailed(new Failure(description, e));
}
 [Lines 37 - 39 ] {
    notifier.fireTestFinished(description);
}
 [Lines 41 - 43 ] {
    notifier.fireTestStarted(description);
}
 [Lines 45 - 47 ] {
    notifier.fireTestIgnored(description);
}

/src/main/java/org/junit/internal/runners/model/MultipleFailureException.java
=============================================================================
 [Lines 9 - 11 ] {
    super(errors);
}

/src/main/java/org/junit/internal/runners/SuiteMethod.java
==========================================================
 [Lines 23 - 25 ] {
    super(testFromSuiteMethod(klass));
}
 [Lines 27 - 40 ] {
    Method suiteMethod = null;
    Test suite = null;
    try {
        suiteMethod = klass.getMethod("suite");
        if (!Modifier.isStatic(suiteMethod.getModifiers())) {
            throw new Exception(klass.getName() + ".suite() must be static");
        }
        // static method
        suite = (Test) suiteMethod.invoke(null);
    } catch (InvocationTargetException e) {
        throw e.getCause();
    }
    return suite;
}

/src/main/java/org/junit/internal/runners/rules/RuleMemberValidator.java
========================================================================
 [Lines 75 - 79 ] {
    this.annotation = builder.annotation;
    this.methods = builder.methods;
    this.validatorStrategies = builder.validators;
}
 [Lines 88 - 95 ] {
    List<? extends FrameworkMember<?>> members = methods ? target.getAnnotatedMethods(annotation) : target.getAnnotatedFields(annotation);
    for (FrameworkMember<?> each : members) {
        validateMember(each, errors);
    }
}
 [Lines 97 - 101 ] {
    for (RuleValidator strategy : validatorStrategies) {
        strategy.validate(member, annotation, errors);
    }
}
 [Lines 103 - 105 ] {
    return new Builder(ClassRule.class);
}
 [Lines 107 - 109 ] {
    return new Builder(Rule.class);
}
 [Lines 116 - 120 ] {
    this.annotation = annotation;
    this.methods = false;
    this.validators = new ArrayList<RuleValidator>();
}
 [Lines 122 - 125 ] {
    methods = true;
    return this;
}
 [Lines 127 - 130 ] {
    validators.add(validator);
    return this;
}
 [Lines 132 - 134 ] {
    return new RuleMemberValidator(this);
}
 [Lines 137 - 139 ] {
    return isMethodRule(member) || isTestRule(member);
}
 [Lines 141 - 143 ] {
    return TestRule.class.isAssignableFrom(member.getType());
}
 [Lines 145 - 147 ] {
    return MethodRule.class.isAssignableFrom(member.getType());
}
 [Lines 167 - 185 ] {
    boolean isMethodRuleMember = isMethodRule(member);
    boolean isClassRuleAnnotated = (member.getAnnotation(ClassRule.class) != null);
    // Note that MethodRule cannot be annotated with @ClassRule
    if (member.isStatic() && (isMethodRuleMember || !isClassRuleAnnotated)) {
        String message;
        if (isMethodRule(member)) {
            message = "must not be static.";
        } else {
            message = "must not be static or it must be annotated with @ClassRule.";
        }
        errors.add(new ValidationError(member, annotation, message));
    }
}
 [Lines 192 - 197 ] {
    if (!member.isStatic()) {
        errors.add(new ValidationError(member, annotation, "must be static."));
    }
}
 [Lines 204 - 209 ] {
    if (!isDeclaringClassPublic(member)) {
        errors.add(new ValidationError(member, annotation, "must be declared in a public class."));
    }
}
 [Lines 211 - 213 ] {
    return Modifier.isPublic(member.getDeclaringClass().getModifiers());
}
 [Lines 220 - 225 ] {
    if (!member.isPublic()) {
        errors.add(new ValidationError(member, annotation, "must be public."));
    }
}
 [Lines 232 - 237 ] {
    if (!isRuleType(member)) {
        errors.add(new ValidationError(member, annotation, "must implement MethodRule or TestRule."));
    }
}
 [Lines 245 - 250 ] {
    if (!isRuleType(member)) {
        errors.add(new ValidationError(member, annotation, "must return an implementation of MethodRule or TestRule."));
    }
}
 [Lines 258 - 263 ] {
    if (!isTestRule(member)) {
        errors.add(new ValidationError(member, annotation, "must return an implementation of TestRule."));
    }
}
 [Lines 272 - 277 ] {
    if (!isTestRule(member)) {
        errors.add(new ValidationError(member, annotation, "must implement TestRule."));
    }
}

/src/main/java/org/junit/internal/runners/rules/ValidationError.java
====================================================================
 [Lines 11 - 13 ] {
    super(String.format("The @%s '%s' %s", annotation.getSimpleName(), member.getName(), suffix));
}

/src/main/java/org/junit/internal/runners/InitializationError.java
==================================================================
 [Lines 22 - 24 ] {
    this.fErrors = errors;
}
 [Lines 26 - 28 ] {
    this(Arrays.asList(errors));
}
 [Lines 30 - 32 ] {
    this(new Exception(string));
}
 [Lines 34 - 36 ] {
    return fErrors;
}

/src/main/java/org/junit/internal/runners/package-info.java
===========================================================

/src/main/java/org/junit/internal/ExactComparisonCriteria.java
==============================================================
 [Lines 7 - 9 ] {
    Assert.assertEquals(expected, actual);
}

/src/main/java/org/junit/internal/matchers/StacktracePrintingMatcher.java
=========================================================================
 [Lines 23 - 25 ] {
    this.throwableMatcher = throwableMatcher;
}
 [Lines 27 - 29 ] {
    throwableMatcher.describeTo(description);
}
 [Lines 32 - 34 ] {
    return throwableMatcher.matches(item);
}
 [Lines 37 - 41 ] {
    throwableMatcher.describeMismatch(item, description);
    description.appendText("\nStacktrace was: ");
    description.appendText(readStacktrace(item));
}
 [Lines 43 - 47 ] {
    StringWriter stringWriter = new StringWriter();
    throwable.printStackTrace(new PrintWriter(stringWriter));
    return stringWriter.toString();
}
 [Lines 51 - 53 ] {
    return new StacktracePrintingMatcher<T>(throwableMatcher);
}
 [Lines 57 - 59 ] {
    return new StacktracePrintingMatcher<T>(exceptionMatcher);
}

/src/main/java/org/junit/internal/matchers/ThrowableCauseMatcher.java
=====================================================================
 [Lines 21 - 23 ] {
    this.causeMatcher = causeMatcher;
}
 [Lines 25 - 28 ] {
    description.appendText("exception with cause ");
    description.appendDescriptionOf(causeMatcher);
}
 [Lines 31 - 33 ] {
    return causeMatcher.matches(item.getCause());
}
 [Lines 36 - 39 ] {
    description.appendText("cause ");
    causeMatcher.describeMismatch(item.getCause(), description);
}
 [Lines 49 - 51 ] {
    return new ThrowableCauseMatcher<T>(matcher);
}

/src/main/java/org/junit/internal/matchers/ThrowableMessageMatcher.java
=======================================================================
 [Lines 13 - 15 ] {
    this.matcher = matcher;
}
 [Lines 17 - 20 ] {
    description.appendText("exception with message ");
    description.appendDescriptionOf(matcher);
}
 [Lines 23 - 25 ] {
    return matcher.matches(item.getMessage());
}
 [Lines 28 - 31 ] {
    description.appendText("message ");
    matcher.describeMismatch(item.getMessage(), description);
}
 [Lines 34 - 36 ] {
    return new ThrowableMessageMatcher<T>(matcher);
}

/src/main/java/org/junit/internal/matchers/TypeSafeMatcher.java
===============================================================
 [Lines 26 - 28 ] {
    expectedType = findExpectedType(getClass());
}
 [Lines 30 - 40 ] {
    for (Class<?> c = fromClass; c != Object.class; c = c.getSuperclass()) {
        for (Method method : MethodSorter.getDeclaredMethods(c)) {
            if (isMatchesSafelyMethod(method)) {
                return method.getParameterTypes()[0];
            }
        }
    }
    throw new Error("Cannot determine correct type for matchesSafely() method.");
}
 [Lines 42 - 46 ] {
    return "matchesSafely".equals(method.getName()) && method.getParameterTypes().length == 1 && !method.isSynthetic();
}
 [Lines 48 - 50 ] {
    this.expectedType = expectedType;
}
 [Lines 58 - 62 ] {
    return item != null && expectedType.isInstance(item) && matchesSafely((T) item);
}

/src/main/java/org/junit/FixMethodOrder.java
============================================

/src/main/java/org/junit/Assert.java
====================================
 [Lines 28 - 29 ] {
}
 [Lines 39 - 43 ] {
    if (!condition) {
        fail(message);
    }
}
 [Lines 51 - 53 ] {
    assertTrue(null, condition);
}
 [Lines 63 - 65 ] {
    assertTrue(message, !condition);
}
 [Lines 73 - 75 ] {
    assertFalse(null, condition);
}
 [Lines 84 - 89 ] {
    if (message == null) {
        throw new AssertionError();
    }
    throw new AssertionError(message);
}
 [Lines 94 - 96 ] {
    fail(null);
}
 [Lines 110 - 121 ] {
    if (equalsRegardingNull(expected, actual)) {
        return;
    }
    if (expected instanceof String && actual instanceof String) {
        String cleanMessage = message == null ? "" : message;
        throw new ComparisonFailure(cleanMessage, (String) expected, (String) actual);
    } else {
        failNotEquals(message, expected, actual);
    }
}
 [Lines 123 - 129 ] {
    if (expected == null) {
        return actual == null;
    }
    return isEquals(expected, actual);
}
 [Lines 131 - 133 ] {
    return expected.equals(actual);
}
 [Lines 144 - 146 ] {
    assertEquals(null, expected, actual);
}
 [Lines 160 - 164 ] {
    if (equalsRegardingNull(unexpected, actual)) {
        failEquals(message, actual);
    }
}
 [Lines 175 - 177 ] {
    assertNotEquals(null, unexpected, actual);
}
 [Lines 179 - 187 ] {
    String formatted = "Values should be different. ";
    if (message != null) {
        formatted = message + ". ";
    }
    formatted += "Actual: " + actual;
    fail(formatted);
}
 [Lines 198 - 202 ] {
    if (unexpected == actual) {
        failEquals(message, Long.valueOf(actual));
    }
}
 [Lines 211 - 213 ] {
    assertNotEquals(null, unexpected, actual);
}
 [Lines 231 - 235 ] {
    if (!doubleIsDifferent(unexpected, actual, delta)) {
        failEquals(message, Double.valueOf(actual));
    }
}
 [Lines 249 - 251 ] {
    assertNotEquals(null, unexpected, actual, delta);
}
 [Lines 265 - 267 ] {
    assertNotEquals(null, unexpected, actual, delta);
}
 [Lines 283 - 285 ] {
    internalArrayEquals(message, expecteds, actuals);
}
 [Lines 298 - 300 ] {
    assertArrayEquals(null, expecteds, actuals);
}
 [Lines 314 - 316 ] {
    internalArrayEquals(message, expecteds, actuals);
}
 [Lines 327 - 329 ] {
    assertArrayEquals(null, expecteds, actuals);
}
 [Lines 341 - 343 ] {
    internalArrayEquals(message, expecteds, actuals);
}
 [Lines 352 - 354 ] {
    assertArrayEquals(null, expecteds, actuals);
}
 [Lines 366 - 368 ] {
    internalArrayEquals(message, expecteds, actuals);
}
 [Lines 377 - 379 ] {
    assertArrayEquals(null, expecteds, actuals);
}
 [Lines 391 - 393 ] {
    internalArrayEquals(message, expecteds, actuals);
}
 [Lines 402 - 404 ] {
    assertArrayEquals(null, expecteds, actuals);
}
 [Lines 416 - 418 ] {
    internalArrayEquals(message, expecteds, actuals);
}
 [Lines 427 - 429 ] {
    assertArrayEquals(null, expecteds, actuals);
}
 [Lines 441 - 443 ] {
    internalArrayEquals(message, expecteds, actuals);
}
 [Lines 452 - 454 ] {
    assertArrayEquals(null, expecteds, actuals);
}
 [Lines 469 - 471 ] {
    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);
}
 [Lines 483 - 485 ] {
    assertArrayEquals(null, expecteds, actuals, delta);
}
 [Lines 500 - 502 ] {
    new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);
}
 [Lines 514 - 516 ] {
    assertArrayEquals(null, expecteds, actuals, delta);
}
 [Lines 532 - 534 ] {
    new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);
}
 [Lines 552 - 556 ] {
    if (doubleIsDifferent(expected, actual, delta)) {
        failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));
    }
}
 [Lines 574 - 578 ] {
    if (floatIsDifferent(expected, actual, delta)) {
        failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));
    }
}
 [Lines 596 - 600 ] {
    if (!floatIsDifferent(unexpected, actual, delta)) {
        failEquals(message, actual);
    }
}
 [Lines 602 - 611 ] {
    if (Double.compare(d1, d2) == 0) {
        return false;
    }
    if ((Math.abs(d1 - d2) <= delta)) {
        return false;
    }
    return true;
}
 [Lines 613 - 622 ] {
    if (Float.compare(f1, f2) == 0) {
        return false;
    }
    if ((Math.abs(f1 - f2) <= delta)) {
        return false;
    }
    return true;
}
 [Lines 631 - 633 ] {
    assertEquals(null, expected, actual);
}
 [Lines 644 - 648 ] {
    if (expected != actual) {
        failNotEquals(message, Long.valueOf(expected), Long.valueOf(actual));
    }
}
 [Lines 656 - 658 ] {
    assertEquals(null, expected, actual);
}
 [Lines 667 - 669 ] {
    fail("Use assertEquals(expected, actual, delta) to compare floating-point numbers");
}
 [Lines 683 - 685 ] {
    assertEquals(null, expected, actual, delta);
}
 [Lines 699 - 701 ] {
    assertEquals(null, expected, actual, delta);
}
 [Lines 711 - 713 ] {
    assertTrue(message, object != null);
}
 [Lines 721 - 723 ] {
    assertNotNull(null, object);
}
 [Lines 733 - 738 ] {
    if (object == null) {
        return;
    }
    failNotNull(message, object);
}
 [Lines 746 - 748 ] {
    assertNull(null, object);
}
 [Lines 750 - 756 ] {
    String formatted = "";
    if (message != null) {
        formatted = message + " ";
    }
    fail(formatted + "expected null, but was:<" + actual + ">");
}
 [Lines 767 - 772 ] {
    if (expected == actual) {
        return;
    }
    failNotSame(message, expected, actual);
}
 [Lines 781 - 783 ] {
    assertSame(null, expected, actual);
}
 [Lines 796 - 800 ] {
    if (unexpected == actual) {
        failSame(message);
    }
}
 [Lines 810 - 812 ] {
    assertNotSame(null, unexpected, actual);
}
 [Lines 814 - 820 ] {
    String formatted = "";
    if (message != null) {
        formatted = message + " ";
    }
    fail(formatted + "expected not same");
}
 [Lines 823 - 830 ] {
    String formatted = "";
    if (message != null) {
        formatted = message + " ";
    }
    fail(formatted + "expected same:<" + expected + "> was not:<" + actual + ">");
}
 [Lines 833 - 835 ] {
    fail(format(message, expected, actual));
}
 [Lines 837 - 852 ] {
    String formatted = "";
    if (message != null && !"".equals(message)) {
        formatted = message + " ";
    }
    String expectedString = String.valueOf(expected);
    String actualString = String.valueOf(actual);
    if (expectedString.equals(actualString)) {
        return formatted + "expected: " + formatClassAndValue(expected, expectedString) + " but was: " + formatClassAndValue(actual, actualString);
    } else {
        return formatted + "expected:<" + expectedString + "> but was:<" + actualString + ">";
    }
}
 [Lines 854 - 857 ] {
    String className = value == null ? "null" : value.getClass().getName();
    return className + "<" + valueString + ">";
}
 [Lines 875 - 877 ] {
    assertArrayEquals(message, expecteds, actuals);
}
 [Lines 892 - 894 ] {
    assertArrayEquals(expecteds, actuals);
}
 [Lines 924 - 926 ] {
    assertThat("", actual, matcher);
}
 [Lines 959 - 961 ] {
    MatcherAssert.assertThat(reason, actual, matcher);
}
 [Lines 985 - 987 ] {
    expectThrows(expectedThrowable, runnable);
}
 [Lines 1001 - 1021 ] {
    try {
        runnable.run();
    } catch (Throwable actualThrown) {
        if (expectedThrowable.isInstance(actualThrown)) {
            @SuppressWarnings("unchecked") T retVal = (T) actualThrown;
            return retVal;
        } else {
            String mismatchMessage = format("unexpected exception type thrown;", expectedThrowable.getSimpleName(), actualThrown.getClass().getSimpleName());
            // The AssertionError(String, Throwable) ctor is only available on JDK7.
            AssertionError assertionError = new AssertionError(mismatchMessage);
            assertionError.initCause(actualThrown);
            throw assertionError;
        }
    }
    String message = String.format("expected %s to be thrown, but nothing was thrown", expectedThrowable.getSimpleName());
    throw new AssertionError(message);
}

/src/main/java/org/junit/After.java
===================================

/src/main/java/org/junit/Test.java
==================================
 [Lines 74 - 75 ] {
}

/src/main/java/org/junit/Assume.java
====================================
 [Lines 43 - 44 ] {
}
 [Lines 49 - 51 ] {
    assumeThat(b, is(true));
}
 [Lines 56 - 58 ] {
    assumeTrue(!b);
}
 [Lines 67 - 69 ] {
    if (!b)
        throw new AssumptionViolatedException(message);
}
 [Lines 74 - 76 ] {
    assumeTrue(message, !b);
}
 [Lines 81 - 83 ] {
    assumeThat(asList(objects), everyItem(notNullValue()));
}
 [Lines 104 - 108 ] {
    if (!matcher.matches(actual)) {
        throw new AssumptionViolatedException(actual, matcher);
    }
}
 [Lines 129 - 133 ] {
    if (!matcher.matches(actual)) {
        throw new AssumptionViolatedException(message, actual, matcher);
    }
}
 [Lines 154 - 156 ] {
    assumeThat(e, nullValue());
}
 [Lines 168 - 170 ] {
    assumeThat(message, e, nullValue());
}

/src/main/java/org/junit/rules/TestRule.java
============================================

/src/main/java/org/junit/rules/Verifier.java
============================================
 [Lines 31 - 39 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            base.evaluate();
            verify();
        }
    };
}
 [Lines 45 - 46 ] {
}

/src/main/java/org/junit/rules/Stopwatch.java
=============================================
 [Lines 84 - 86 ] {
    this(new Clock());
}
 [Lines 88 - 90 ] {
    this.clock = clock;
}
 [Lines 98 - 100 ] {
    return unit.convert(getNanos(), TimeUnit.NANOSECONDS);
}
 [Lines 105 - 106 ] {
}
 [Lines 111 - 112 ] {
}
 [Lines 117 - 118 ] {
}
 [Lines 123 - 124 ] {
}
 [Lines 126 - 136 ] {
    if (startNanos == 0) {
        throw new IllegalStateException("Test has not started");
    }
    // volatile read happens here
    long currentEndNanos = endNanos;
    if (currentEndNanos == 0) {
        currentEndNanos = clock.nanoTime();
    }
    return currentEndNanos - startNanos;
}
 [Lines 138 - 141 ] {
    startNanos = clock.nanoTime();
    endNanos = 0;
}
 [Lines 143 - 145 ] {
    endNanos = clock.nanoTime();
}
 [Lines 147 - 149 ] {
    return new InternalWatcher().apply(base, description);
}
 [Lines 153 - 155 ] {
    Stopwatch.this.starting();
}
 [Lines 157 - 159 ] {
    Stopwatch.this.finished(getNanos(), description);
}
 [Lines 161 - 164 ] {
    Stopwatch.this.stopping();
    Stopwatch.this.succeeded(getNanos(), description);
}
 [Lines 166 - 169 ] {
    Stopwatch.this.stopping();
    Stopwatch.this.failed(getNanos(), e, description);
}
 [Lines 171 - 174 ] {
    Stopwatch.this.stopping();
    Stopwatch.this.skipped(getNanos(), e, description);
}
 [Lines 179 - 181 ] {
    return System.nanoTime();
}

/src/main/java/org/junit/rules/RunRules.java
============================================
 [Lines 14 - 16 ] {
    statement = applyAll(base, rules, description);
}
 [Lines 19 - 21 ] {
    statement.evaluate();
}
 [Lines 24 - 29 ] {
    for (TestRule each : rules) {
        result = each.apply(result, description);
    }
    return result;
}

/src/main/java/org/junit/rules/TestName.java
============================================
 [Lines 31 - 33 ] {
    name = d.getMethodName();
}
 [Lines 38 - 40 ] {
    return name;
}

/src/main/java/org/junit/rules/RuleChain.java
=============================================
 [Lines 55 - 57 ] {
    return EMPTY_CHAIN;
}
 [Lines 66 - 68 ] {
    return emptyRuleChain().around(outerRule);
}
 [Lines 70 - 72 ] {
    this.rulesStartingWithInnerMost = rules;
}
 [Lines 81 - 86 ] {
    List<TestRule> rulesOfNewChain = new ArrayList<TestRule>();
    rulesOfNewChain.add(enclosedRule);
    rulesOfNewChain.addAll(rulesStartingWithInnerMost);
    return new RuleChain(rulesOfNewChain);
}
 [Lines 91 - 96 ] {
    for (TestRule each : rulesStartingWithInnerMost) {
        base = each.apply(base, description);
    }
    return base;
}

/src/main/java/org/junit/rules/ErrorCollector.java
==================================================
 [Lines 38 - 40 ] {
    MultipleFailureException.assertEmpty(errors);
}
 [Lines 45 - 47 ] {
    errors.add(error);
}
 [Lines 56 - 58 ] {
    checkThat("", value, matcher);
}
 [Lines 68 - 75 ] {
    checkSucceeds(new Callable<Object>() {

        public Object call() throws Exception {
            assertThat(reason, value, matcher);
            return value;
        }
    });
}
 [Lines 82 - 89 ] {
    try {
        return callable.call();
    } catch (Throwable e) {
        addError(e);
        return null;
    }
}

/src/main/java/org/junit/rules/ExpectedExceptionMatcherBuilder.java
===================================================================
 [Lines 18 - 20 ] {
    matchers.add(matcher);
}
 [Lines 22 - 24 ] {
    return !matchers.isEmpty();
}
 [Lines 26 - 28 ] {
    return isThrowable(allOfTheMatchers());
}
 [Lines 30 - 35 ] {
    if (matchers.size() == 1) {
        return cast(matchers.get(0));
    }
    return allOf(castedMatchers());
}
 [Lines 38 - 40 ] {
    return new ArrayList<Matcher<? super Throwable>>((List) matchers);
}
 [Lines 43 - 45 ] {
    return (Matcher<Throwable>) singleMatcher;
}

/src/main/java/org/junit/rules/Timeout.java
===========================================
 [Lines 50 - 52 ] {
    return new Builder();
}
 [Lines 67 - 69 ] {
    this(millis, TimeUnit.MILLISECONDS);
}
 [Lines 80 - 84 ] {
    this.timeout = timeout;
    this.timeUnit = timeUnit;
    lookForStuckThread = false;
}
 [Lines 92 - 96 ] {
    timeout = builder.getTimeout();
    timeUnit = builder.getTimeUnit();
    lookForStuckThread = builder.getLookingForStuckThread();
}
 [Lines 104 - 106 ] {
    return new Timeout(millis, TimeUnit.MILLISECONDS);
}
 [Lines 114 - 116 ] {
    return new Timeout(seconds, TimeUnit.SECONDS);
}
 [Lines 123 - 125 ] {
    return unit.convert(timeout, timeUnit);
}
 [Lines 133 - 135 ] {
    return lookForStuckThread;
}
 [Lines 146 - 151 ] {
    return FailOnTimeout.builder().withTimeout(timeout, timeUnit).withLookingForStuckThread(lookForStuckThread).build(statement);
}
 [Lines 153 - 163 ] {
    try {
        return createFailOnTimeoutStatement(base);
    } catch (final Exception e) {
        return new Statement() {

            @Override
            public void evaluate() throws Throwable {
                throw new RuntimeException("Invalid parameters for Timeout", e);
            }
        };
    }
}
 [Lines 175 - 176 ] {
}
 [Lines 193 - 197 ] {
    this.timeout = timeout;
    this.timeUnit = unit;
    return this;
}
 [Lines 199 - 201 ] {
    return timeout;
}
 [Lines 203 - 205 ] {
    return timeUnit;
}
 [Lines 216 - 219 ] {
    this.lookForStuckThread = enable;
    return this;
}
 [Lines 221 - 223 ] {
    return lookForStuckThread;
}
 [Lines 229 - 231 ] {
    return new Timeout(this);
}

/src/main/java/org/junit/rules/TestWatchman.java
================================================
 [Lines 47 - 65 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            starting(method);
            try {
                base.evaluate();
                succeeded(method);
            } catch (AssumptionViolatedException e) {
                throw e;
            } catch (Throwable e) {
                failed(e, method);
                throw e;
            } finally {
                finished(method);
            }
        }
    };
}
 [Lines 70 - 71 ] {
}
 [Lines 76 - 77 ] {
}
 [Lines 82 - 83 ] {
}
 [Lines 89 - 90 ] {
}

/src/main/java/org/junit/rules/TemporaryFolder.java
===================================================
 [Lines 51 - 53 ] {
    this((File) null);
}
 [Lines 62 - 65 ] {
    this.parentFolder = parentFolder;
    this.assureDeletion = false;
}
 [Lines 71 - 74 ] {
    this.parentFolder = builder.parentFolder;
    this.assureDeletion = builder.assureDeletion;
}
 [Lines 81 - 83 ] {
    return new Builder();
}
 [Lines 94 - 94 ] {
}
 [Lines 103 - 106 ] {
    this.parentFolder = parentFolder;
    return this;
}
 [Lines 115 - 118 ] {
    this.assureDeletion = true;
    return this;
}
 [Lines 123 - 125 ] {
    return new TemporaryFolder(this);
}
 [Lines 129 - 131 ] {
    create();
}
 [Lines 134 - 136 ] {
    delete();
}
 [Lines 143 - 145 ] {
    folder = createTemporaryFolderIn(parentFolder);
}
 [Lines 150 - 157 ] {
    File file = new File(getRoot(), fileName);
    if (!file.createNewFile()) {
        throw new IOException("a file with the name \'" + fileName + "\' already exists in the test folder");
    }
    return file;
}
 [Lines 162 - 164 ] {
    return File.createTempFile("junit", null, getRoot());
}
 [Lines 170 - 172 ] {
    return newFolder(new String[] { folder });
}
 [Lines 178 - 190 ] {
    File file = getRoot();
    for (int i = 0; i < folderNames.length; i++) {
        String folderName = folderNames[i];
        validateFolderName(folderName);
        file = new File(file, folderName);
        if (!file.mkdir() && isLastElementInArray(i, folderNames)) {
            throw new IOException("a folder with the name \'" + folderName + "\' already exists");
        }
    }
    return file;
}
 [Lines 198 - 205 ] {
    File tempFile = new File(folderName);
    if (tempFile.getParent() != null) {
        String errorMsg = "Folder name cannot consist of multiple path components separated by a file separator." + " Please use newFolder('MyParentFolder','MyFolder') to create hierarchies of folders";
        throw new IOException(errorMsg);
    }
}
 [Lines 207 - 209 ] {
    return index == array.length - 1;
}
 [Lines 214 - 216 ] {
    return createTemporaryFolderIn(getRoot());
}
 [Lines 218 - 223 ] {
    File createdFolder = File.createTempFile("junit", "", parentFolder);
    createdFolder.delete();
    createdFolder.mkdir();
    return createdFolder;
}
 [Lines 228 - 234 ] {
    if (folder == null) {
        throw new IllegalStateException("the temporary folder has not yet been created");
    }
    return folder;
}
 [Lines 243 - 249 ] {
    if (!tryDelete()) {
        if (assureDeletion) {
            fail("Unable to clean up temporary folder " + folder);
        }
    }
}
 [Lines 258 - 264 ] {
    if (folder == null) {
        return true;
    }
    return recursiveDelete(folder);
}
 [Lines 266 - 275 ] {
    boolean result = true;
    File[] files = file.listFiles();
    if (files != null) {
        for (File each : files) {
            result = result && recursiveDelete(each);
        }
    }
    return result && file.delete();
}

/src/main/java/org/junit/rules/DisableOnDebug.java
==================================================
 [Lines 56 - 59 ] {
    this(rule, ManagementFactory.getRuntimeMXBean().getInputArguments());
}
 [Lines 68 - 71 ] {
    this.rule = rule;
    debugging = isDebugging(inputArguments);
}
 [Lines 76 - 82 ] {
    if (debugging) {
        return base;
    } else {
        return rule.apply(base, description);
    }
}
 [Lines 104 - 113 ] {
    for (final String argument : arguments) {
        if ("-Xdebug".equals(argument)) {
            return true;
        } else if (argument.startsWith("-agentlib:jdwp")) {
            return true;
        }
    }
    return false;
}
 [Lines 123 - 125 ] {
    return debugging;
}

/src/main/java/org/junit/rules/ExpectedException.java
=====================================================
 [Lines 110 - 112 ] {
    return new ExpectedException();
}
 [Lines 118 - 119 ] {
}
 [Lines 127 - 129 ] {
    return this;
}
 [Lines 137 - 139 ] {
    return this;
}
 [Lines 151 - 154 ] {
    missingExceptionMessage = message;
    return this;
}
 [Lines 157 - 159 ] {
    return new ExpectedExceptionStatement(base);
}
 [Lines 174 - 176 ] {
    matcherBuilder.add(matcher);
}
 [Lines 187 - 189 ] {
    expect(instanceOf(type));
}
 [Lines 200 - 202 ] {
    expectMessage(containsString(substring));
}
 [Lines 216 - 218 ] {
    expect(hasMessage(matcher));
}
 [Lines 233 - 235 ] {
    expect(hasCause(expectedCause));
}
 [Lines 240 - 242 ] {
    next = base;
}
 [Lines 245 - 255 ] {
    try {
        next.evaluate();
    } catch (Throwable e) {
        handleException(e);
        return;
    }
    if (isAnyExceptionExpected()) {
        failDueToMissingException();
    }
}
 [Lines 258 - 264 ] {
    if (isAnyExceptionExpected()) {
        assertThat(e, matcherBuilder.build());
    } else {
        throw e;
    }
}
 [Lines 266 - 268 ] {
    return matcherBuilder.expectsThrowable();
}
 [Lines 270 - 272 ] {
    fail(missingExceptionMessage());
}
 [Lines 274 - 277 ] {
    String expectation = StringDescription.toString(matcherBuilder.build());
    return format(missingExceptionMessage, expectation);
}

/src/main/java/org/junit/rules/MethodRule.java
==============================================

/src/main/java/org/junit/rules/ExternalResource.java
====================================================
 [Lines 38 - 40 ] {
    return statement(base);
}
 [Lines 42 - 54 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            before();
            try {
                base.evaluate();
            } finally {
                after();
            }
        }
    };
}
 [Lines 61 - 63 ] {
// do nothing
}
 [Lines 68 - 70 ] {
// do nothing
}

/src/main/java/org/junit/rules/TestWatcher.java
===============================================
 [Lines 47 - 70 ] {
    return new Statement() {

        @Override
        public void evaluate() throws Throwable {
            List<Throwable> errors = new ArrayList<Throwable>();
            startingQuietly(description, errors);
            try {
                base.evaluate();
                succeededQuietly(description, errors);
            } catch (org.junit.internal.AssumptionViolatedException e) {
                errors.add(e);
                skippedQuietly(e, description, errors);
            } catch (Throwable e) {
                errors.add(e);
                failedQuietly(e, description, errors);
            } finally {
                finishedQuietly(description, errors);
            }
            MultipleFailureException.assertEmpty(errors);
        }
    };
}
 [Lines 73 - 79 ] {
    try {
        succeeded(description);
    } catch (Throwable e) {
        errors.add(e);
    }
}
 [Lines 82 - 88 ] {
    try {
        failed(e, description);
    } catch (Throwable e1) {
        errors.add(e1);
    }
}
 [Lines 92 - 102 ] {
    try {
        if (e instanceof AssumptionViolatedException) {
            skipped((AssumptionViolatedException) e, description);
        } else {
            skipped(e, description);
        }
    } catch (Throwable e1) {
        errors.add(e1);
    }
}
 [Lines 105 - 111 ] {
    try {
        starting(description);
    } catch (Throwable e) {
        errors.add(e);
    }
}
 [Lines 114 - 120 ] {
    try {
        finished(description);
    } catch (Throwable e) {
        errors.add(e);
    }
}
 [Lines 125 - 126 ] {
}
 [Lines 131 - 132 ] {
}
 [Lines 137 - 141 ] {
    // For backwards compatibility with JUnit 4.11 and earlier, call the legacy version
    org.junit.internal.AssumptionViolatedException asInternalException = e;
    skipped(asInternalException, description);
}
 [Lines 150 - 151 ] {
}
 [Lines 156 - 157 ] {
}
 [Lines 162 - 163 ] {
}

/src/main/java/org/junit/AssumptionViolatedException.java
=========================================================
 [Lines 22 - 24 ] {
    super(actual, matcher);
}
 [Lines 31 - 33 ] {
    super(message, expected, matcher);
}
 [Lines 38 - 40 ] {
    super(message);
}
 [Lines 45 - 47 ] {
    super(assumption, t);
}

/src/main/java/org/junit/runners/AllTests.java
==============================================
 [Lines 24 - 26 ] {
    super(klass);
}

/src/main/java/org/junit/runners/parameterized/BlockJUnit4ClassRunnerWithParametersFactory.java
===============================================================================================
 [Lines 15 - 17 ] {
    return new BlockJUnit4ClassRunnerWithParameters(test);
}

/src/main/java/org/junit/runners/parameterized/ParametersRunnerFactory.java
===========================================================================

/src/main/java/org/junit/runners/parameterized/TestWithParameters.java
======================================================================
 [Lines 25 - 32 ] {
    notNull(name, "The name is missing.");
    notNull(testClass, "The test class is missing.");
    notNull(parameters, "The parameters are missing.");
    this.name = name;
    this.testClass = testClass;
    this.parameters = unmodifiableList(new ArrayList<Object>(parameters));
}
 [Lines 34 - 36 ] {
    return name;
}
 [Lines 38 - 40 ] {
    return testClass;
}
 [Lines 42 - 44 ] {
    return parameters;
}
 [Lines 47 - 52 ] {
    int prime = 14747;
    int result = prime + name.hashCode();
    result = prime * result + testClass.hashCode();
    return prime * result + parameters.hashCode();
}
 [Lines 55 - 69 ] {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    TestWithParameters other = (TestWithParameters) obj;
    return name.equals(other.name) && parameters.equals(other.parameters) && testClass.equals(other.testClass);
}
 [Lines 72 - 75 ] {
    return testClass.getName() + " '" + name + "' with parameters " + parameters;
}
 [Lines 77 - 81 ] {
    if (value == null) {
        throw new NullPointerException(message);
    }
}

/src/main/java/org/junit/runners/parameterized/BlockJUnit4ClassRunnerWithParameters.java
========================================================================================
 [Lines 31 - 36 ] {
    super(test.getTestClass().getJavaClass());
    parameters = test.getParameters().toArray(new Object[test.getParameters().size()]);
    name = test.getName();
}
 [Lines 39 - 50 ] {
    InjectionType injectionType = getInjectionType();
    switch(injectionType) {
        case CONSTRUCTOR:
            return createTestUsingConstructorInjection();
        case FIELD:
            return createTestUsingFieldInjection();
        default:
            throw new IllegalStateException("The injection type " + injectionType + " is not supported.");
    }
}
 [Lines 52 - 54 ] {
    return getTestClass().getOnlyConstructor().newInstance(parameters);
}
 [Lines 56 - 84 ] {
    List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();
    if (annotatedFieldsByParameter.size() != parameters.length) {
        throw new Exception("Wrong number of parameters and @Parameter fields." + " @Parameter fields counted: " + annotatedFieldsByParameter.size() + ", available parameters: " + parameters.length + ".");
    }
    Object testClassInstance = getTestClass().getJavaClass().newInstance();
    for (FrameworkField each : annotatedFieldsByParameter) {
        Field field = each.getField();
        Parameter annotation = field.getAnnotation(Parameter.class);
        int index = annotation.value();
        try {
            field.set(testClassInstance, parameters[index]);
        } catch (IllegalArgumentException iare) {
            throw new Exception(getTestClass().getName() + ": Trying to set " + field.getName() + " with the value " + parameters[index] + " that is not the right type (" + parameters[index].getClass().getSimpleName() + " instead of " + field.getType().getSimpleName() + ").", iare);
        }
    }
    return testClassInstance;
}
 [Lines 87 - 89 ] {
    return name;
}
 [Lines 92 - 94 ] {
    return method.getName() + getName();
}
 [Lines 97 - 102 ] {
    validateOnlyOneConstructor(errors);
    if (getInjectionType() != InjectionType.CONSTRUCTOR) {
        validateZeroArgConstructor(errors);
    }
}
 [Lines 105 - 134 ] {
    super.validateFields(errors);
    if (getInjectionType() == InjectionType.FIELD) {
        List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();
        int[] usedIndices = new int[annotatedFieldsByParameter.size()];
        for (FrameworkField each : annotatedFieldsByParameter) {
            int index = each.getField().getAnnotation(Parameter.class).value();
            if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {
                errors.add(new Exception("Invalid @Parameter value: " + index + ". @Parameter fields counted: " + annotatedFieldsByParameter.size() + ". Please use an index between 0 and " + (annotatedFieldsByParameter.size() - 1) + "."));
            } else {
                usedIndices[index]++;
            }
        }
        for (int index = 0; index < usedIndices.length; index++) {
            int numberOfUse = usedIndices[index];
            if (numberOfUse == 0) {
                errors.add(new Exception("@Parameter(" + index + ") is never used."));
            } else if (numberOfUse > 1) {
                errors.add(new Exception("@Parameter(" + index + ") is used more than once (" + numberOfUse + ")."));
            }
        }
    }
}
 [Lines 137 - 139 ] {
    return childrenInvoker(notifier);
}
 [Lines 142 - 153 ] {
    Annotation[] allAnnotations = super.getRunnerAnnotations();
    Annotation[] annotationsWithoutRunWith = new Annotation[allAnnotations.length - 1];
    int i = 0;
    for (Annotation annotation : allAnnotations) {
        if (!annotation.annotationType().equals(RunWith.class)) {
            annotationsWithoutRunWith[i] = annotation;
            ++i;
        }
    }
    return annotationsWithoutRunWith;
}
 [Lines 155 - 157 ] {
    return getTestClass().getAnnotatedFields(Parameter.class);
}
 [Lines 159 - 165 ] {
    if (fieldsAreAnnotated()) {
        return InjectionType.FIELD;
    } else {
        return InjectionType.CONSTRUCTOR;
    }
}
 [Lines 167 - 169 ] {
    return !getAnnotatedFieldsByParameter().isEmpty();
}

/src/main/java/org/junit/runners/Parameterized.java
===================================================
 [Lines 240 - 242 ] {
    super(klass, RunnersFactory.createRunnersForClass(klass));
}
 [Lines 250 - 252 ] {
    return new RunnersFactory(klass).createRunners();
}
 [Lines 254 - 256 ] {
    testClass = new TestClass(klass);
}
 [Lines 258 - 264 ] {
    Parameters parameters = getParametersMethod().getAnnotation(Parameters.class);
    return Collections.unmodifiableList(createRunnersForParameters(allParameters(), parameters.name(), getParametersRunnerFactory()));
}
 [Lines 267 - 277 ] {
    UseParametersRunnerFactory annotation = testClass.getAnnotation(UseParametersRunnerFactory.class);
    if (annotation == null) {
        return DEFAULT_FACTORY;
    } else {
        Class<? extends ParametersRunnerFactory> factoryClass = annotation.value();
        return factoryClass.newInstance();
    }
}
 [Lines 280 - 285 ] {
    Object[] parameters = (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter : new Object[] { parametersOrSingleParameter };
    return createTestWithParameters(testClass, pattern, index, parameters);
}
 [Lines 288 - 297 ] {
    Object parameters = getParametersMethod().invokeExplosively(null);
    if (parameters instanceof Iterable) {
        return (Iterable<Object>) parameters;
    } else if (parameters instanceof Object[]) {
        return Arrays.asList((Object[]) parameters);
    } else {
        throw parametersMethodReturnedWrongType();
    }
}
 [Lines 299 - 310 ] {
    List<FrameworkMethod> methods = testClass.getAnnotatedMethods(Parameters.class);
    for (FrameworkMethod each : methods) {
        if (each.isStatic() && each.isPublic()) {
            return each;
        }
    }
    throw new Exception("No public static parameters method on class " + testClass.getName());
}
 [Lines 314 - 327 ] {
    try {
        List<TestWithParameters> tests = createTestsForParameters(allParameters, namePattern);
        List<Runner> runners = new ArrayList<Runner>();
        for (TestWithParameters test : tests) {
            runners.add(runnerFactory.createRunnerForTestWithParameters(test));
        }
        return runners;
    } catch (ClassCastException e) {
        throw parametersMethodReturnedWrongType();
    }
}
 [Lines 331 - 339 ] {
    int i = 0;
    List<TestWithParameters> children = new ArrayList<TestWithParameters>();
    for (Object parametersOfSingleTest : allParameters) {
        children.add(createTestWithNotNormalizedParameters(namePattern, i++, parametersOfSingleTest));
    }
    return children;
}
 [Lines 341 - 348 ] {
    String className = testClass.getName();
    String methodName = getParametersMethod().getName();
    String message = MessageFormat.format("{0}.{1}() must return an Iterable of arrays.", className, methodName);
    return new Exception(message);
}
 [Lines 352 - 358 ] {
    String finalPattern = pattern.replaceAll("\\{index\\}", Integer.toString(index));
    String name = MessageFormat.format(finalPattern, parameters);
    return new TestWithParameters("[" + name + "]", testClass, Arrays.asList(parameters));
}

/src/main/java/org/junit/runners/Suite.java
===========================================
 [Lines 31 - 37 ] {
    try {
        return new Suite((Class<?>) null, new Class<?>[0]);
    } catch (InitializationError e) {
        throw new RuntimeException("This shouldn't be possible");
    }
}
 [Lines 53 - 59 ] {
    SuiteClasses annotation = klass.getAnnotation(SuiteClasses.class);
    if (annotation == null) {
        throw new InitializationError(String.format("class '%s' must have a SuiteClasses annotation", klass.getName()));
    }
    return annotation.value();
}
 [Lines 69 - 71 ] {
    this(builder, klass, getAnnotatedClasses(klass));
}
 [Lines 80 - 82 ] {
    this(null, builder.runners(null, classes));
}
 [Lines 90 - 92 ] {
    this(new AllDefaultPossibilitiesBuilder(true), klass, suiteClasses);
}
 [Lines 101 - 103 ] {
    this(klass, builder.runners(klass, suiteClasses));
}
 [Lines 111 - 114 ] {
    super(klass);
    this.runners = Collections.unmodifiableList(runners);
}
 [Lines 117 - 119 ] {
    return runners;
}
 [Lines 122 - 124 ] {
    return child.getDescription();
}
 [Lines 127 - 129 ] {
    runner.run(notifier);
}

/src/main/java/org/junit/runners/model/TestClass.java
=====================================================
 [Lines 45 - 61 ] {
    this.clazz = clazz;
    if (clazz != null && clazz.getConstructors().length > 1) {
        throw new IllegalArgumentException("Test class can only have one constructor");
    }
    Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations = new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();
    Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations = new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();
    scanAnnotatedMembers(methodsForAnnotations, fieldsForAnnotations);
    this.methodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);
    this.fieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);
}
 [Lines 63 - 74 ] {
    for (Class<?> eachClass : getSuperClasses(clazz)) {
        for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {
            addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);
        }
        // and read from fieldForAnnotations in a deterministic order
        for (Field eachField : getSortedDeclaredFields(eachClass)) {
            addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);
        }
    }
}
 [Lines 76 - 80 ] {
    Field[] declaredFields = clazz.getDeclaredFields();
    Arrays.sort(declaredFields, FIELD_COMPARATOR);
    return declaredFields;
}
 [Lines 83 - 96 ] {
    for (Annotation each : member.getAnnotations()) {
        Class<? extends Annotation> type = each.annotationType();
        List<T> members = getAnnotatedMembers(map, type, true);
        if (member.isShadowedBy(members)) {
            return;
        }
        if (runsTopToBottom(type)) {
            members.add(0, member);
        } else {
            members.add(member);
        }
    }
}
 [Lines 99 - 106 ] {
    Map<Class<? extends Annotation>, List<T>> copy = new LinkedHashMap<Class<? extends Annotation>, List<T>>();
    for (Map.Entry<Class<? extends Annotation>, List<T>> entry : source.entrySet()) {
        copy.put(entry.getKey(), Collections.unmodifiableList(entry.getValue()));
    }
    return Collections.unmodifiableMap(copy);
}
 [Lines 114 - 118 ] {
    List<FrameworkMethod> methods = collectValues(methodsForAnnotations);
    Collections.sort(methods, METHOD_COMPARATOR);
    return methods;
}
 [Lines 125 - 127 ] {
    return Collections.unmodifiableList(getAnnotatedMembers(methodsForAnnotations, annotationClass, false));
}
 [Lines 135 - 137 ] {
    return collectValues(fieldsForAnnotations);
}
 [Lines 144 - 146 ] {
    return Collections.unmodifiableList(getAnnotatedMembers(fieldsForAnnotations, annotationClass, false));
}
 [Lines 148 - 154 ] {
    Set<T> values = new LinkedHashSet<T>();
    for (List<T> additionalValues : map.values()) {
        values.addAll(additionalValues);
    }
    return new ArrayList<T>(values);
}
 [Lines 157 - 163 ] {
    if (!map.containsKey(type) && fillIfAbsent) {
        map.put(type, new ArrayList<T>());
    }
    List<T> members = map.get(type);
    return members == null ? Collections.<T>emptyList() : members;
}
 [Lines 165 - 168 ] {
    return annotation.equals(Before.class) || annotation.equals(BeforeClass.class);
}
 [Lines 170 - 178 ] {
    List<Class<?>> results = new ArrayList<Class<?>>();
    Class<?> current = testClass;
    while (current != null) {
        results.add(current);
        current = current.getSuperclass();
    }
    return results;
}
 [Lines 183 - 185 ] {
    return clazz;
}
 [Lines 190 - 195 ] {
    if (clazz == null) {
        return "null";
    }
    return clazz.getName();
}
 [Lines 202 - 206 ] {
    Constructor<?>[] constructors = clazz.getConstructors();
    Assert.assertEquals(1, constructors.length);
    return constructors[0];
}
 [Lines 211 - 216 ] {
    if (clazz == null) {
        return new Annotation[0];
    }
    return clazz.getAnnotations();
}
 [Lines 218 - 223 ] {
    if (clazz == null) {
        return null;
    }
    return clazz.getAnnotation(annotationType);
}
 [Lines 226 - 240 ] {
    List<T> results = new ArrayList<T>();
    for (FrameworkField each : getAnnotatedFields(annotationClass)) {
        try {
            Object fieldValue = each.get(test);
            if (valueClass.isInstance(fieldValue)) {
                results.add(valueClass.cast(fieldValue));
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException("How did getFields return a field we couldn't access?", e);
        }
    }
    return results;
}
 [Lines 243 - 265 ] {
    List<T> results = new ArrayList<T>();
    for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {
        try {
            /*
                 * A method annotated with @Rule may return a @TestRule or a @MethodRule,
                 * we cannot call the method to check whether the return type matches our
                 * expectation i.e. subclass of valueClass. If we do that then the method 
                 * will be invoked twice and we do not want to do that. So we first check
                 * whether return type matches our expectation and only then call the method
                 * to fetch the MethodRule
                 */
            if (valueClass.isAssignableFrom(each.getReturnType())) {
                Object fieldValue = each.invokeExplosively(test);
                results.add(valueClass.cast(fieldValue));
            }
        } catch (Throwable e) {
            throw new RuntimeException("Exception in " + each.getName(), e);
        }
    }
    return results;
}
 [Lines 267 - 269 ] {
    return Modifier.isPublic(clazz.getModifiers());
}
 [Lines 271 - 273 ] {
    return clazz.isMemberClass() && !isStatic(clazz.getModifiers());
}
 [Lines 276 - 278 ] {
    return (clazz == null) ? 0 : clazz.hashCode();
}
 [Lines 281 - 293 ] {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    TestClass other = (TestClass) obj;
    return clazz == other.clazz;
}
 [Lines 299 - 301 ] {
    return left.getName().compareTo(right.getName());
}
 [Lines 309 - 311 ] {
    return NAME_ASCENDING.compare(left.getMethod(), right.getMethod());
}

/src/main/java/org/junit/runners/model/FrameworkMember.java
===========================================================
 [Lines 15 - 22 ] {
    for (T each : members) {
        if (isShadowedBy(each)) {
            return true;
        }
    }
    return false;
}
 [Lines 29 - 31 ] {
    return Modifier.isStatic(getModifiers());
}
 [Lines 36 - 38 ] {
    return Modifier.isPublic(getModifiers());
}

/src/main/java/org/junit/runners/model/Statement.java
=====================================================

/src/main/java/org/junit/runners/model/Annotatable.java
=======================================================

/src/main/java/org/junit/runners/model/FrameworkField.java
==========================================================
 [Lines 17 - 23 ] {
    if (field == null) {
        throw new NullPointerException("FrameworkField cannot be created without an underlying field.");
    }
    this.field = field;
}
 [Lines 26 - 28 ] {
    return getField().getName();
}
 [Lines 30 - 32 ] {
    return field.getAnnotations();
}
 [Lines 34 - 36 ] {
    return field.getAnnotation(annotationType);
}
 [Lines 39 - 41 ] {
    return otherMember.getName().equals(getName());
}
 [Lines 44 - 46 ] {
    return field.getModifiers();
}
 [Lines 51 - 53 ] {
    return field;
}
 [Lines 60 - 62 ] {
    return field.getType();
}
 [Lines 65 - 67 ] {
    return field.getDeclaringClass();
}
 [Lines 72 - 74 ] {
    return field.get(target);
}
 [Lines 77 - 79 ] {
    return field.toString();
}

/src/main/java/org/junit/runners/model/FrameworkMethod.java
===========================================================
 [Lines 25 - 31 ] {
    if (method == null) {
        throw new NullPointerException("FrameworkMethod cannot be created without an underlying method.");
    }
    this.method = method;
}
 [Lines 36 - 38 ] {
    return method;
}
 [Lines 46 - 53 ] {
    return new ReflectiveCallable() {

        @Override
        protected Object runReflectiveCall() throws Throwable {
            return method.invoke(target, params);
        }
    }.run();
}
 [Lines 59 - 61 ] {
    return method.getName();
}
 [Lines 73 - 78 ] {
    validatePublicVoid(isStatic, errors);
    if (method.getParameterTypes().length != 0) {
        errors.add(new Exception("Method " + method.getName() + " should have no parameters"));
    }
}
 [Lines 90 - 101 ] {
    if (isStatic() != isStatic) {
        String state = isStatic ? "should" : "should not";
        errors.add(new Exception("Method " + method.getName() + "() " + state + " be static"));
    }
    if (!isPublic()) {
        errors.add(new Exception("Method " + method.getName() + "() should be public"));
    }
    if (method.getReturnType() != Void.TYPE) {
        errors.add(new Exception("Method " + method.getName() + "() should be void"));
    }
}
 [Lines 104 - 106 ] {
    return method.getModifiers();
}
 [Lines 111 - 113 ] {
    return method.getReturnType();
}
 [Lines 119 - 121 ] {
    return getReturnType();
}
 [Lines 127 - 129 ] {
    return method.getDeclaringClass();
}
 [Lines 131 - 133 ] {
    new NoGenericTypeParametersValidator(method).validate(errors);
}
 [Lines 136 - 149 ] {
    if (!other.getName().equals(getName())) {
        return false;
    }
    if (other.getParameterTypes().length != getParameterTypes().length) {
        return false;
    }
    for (int i = 0; i < other.getParameterTypes().length; i++) {
        if (!other.getParameterTypes()[i].equals(getParameterTypes()[i])) {
            return false;
        }
    }
    return true;
}
 [Lines 152 - 157 ] {
    if (!FrameworkMethod.class.isInstance(obj)) {
        return false;
    }
    return ((FrameworkMethod) obj).method.equals(method);
}
 [Lines 160 - 162 ] {
    return method.hashCode();
}
 [Lines 174 - 177 ] {
    return getParameterTypes().length == 0 && type instanceof Class<?> && ((Class<?>) type).isAssignableFrom(method.getReturnType());
}
 [Lines 179 - 181 ] {
    return method.getParameterTypes();
}
 [Lines 186 - 188 ] {
    return method.getAnnotations();
}
 [Lines 194 - 196 ] {
    return method.getAnnotation(annotationType);
}
 [Lines 199 - 201 ] {
    return method.toString();
}

/src/main/java/org/junit/runners/model/InitializationError.java
===============================================================
 [Lines 25 - 27 ] {
    this.fErrors = errors;
}
 [Lines 29 - 31 ] {
    this(Arrays.asList(error));
}
 [Lines 37 - 39 ] {
    this(new Exception(string));
}
 [Lines 44 - 46 ] {
    return fErrors;
}

/src/main/java/org/junit/runners/model/RunnerBuilder.java
=========================================================
 [Lines 57 - 63 ] {
    try {
        return runnerForClass(testClass);
    } catch (Throwable e) {
        return new ErrorReportingRunner(testClass, e);
    }
}
 [Lines 65 - 70 ] {
    if (!parents.add(parent)) {
        throw new InitializationError(String.format("class '%s' (possibly indirectly) contains itself as a SuiteClass", parent.getName()));
    }
    return parent;
}
 [Lines 72 - 74 ] {
    parents.remove(klass);
}
 [Lines 83 - 91 ] {
    addParent(parent);
    try {
        return runners(children);
    } finally {
        removeParent(parent);
    }
}
 [Lines 94 - 96 ] {
    return runners(parent, children.toArray(new Class<?>[0]));
}
 [Lines 98 - 107 ] {
    List<Runner> runners = new ArrayList<Runner>();
    for (Class<?> each : children) {
        Runner childRunner = safeRunnerForClass(each);
        if (childRunner != null) {
            runners.add(childRunner);
        }
    }
    return runners;
}

/src/main/java/org/junit/runners/model/NoGenericTypeParametersValidator.java
============================================================================
 [Lines 14 - 16 ] {
    this.method = method;
}
 [Lines 18 - 22 ] {
    for (Type each : method.getGenericParameterTypes()) {
        validateNoTypeParameterOnType(each, errors);
    }
}
 [Lines 24 - 35 ] {
    if (type instanceof TypeVariable<?>) {
        errors.add(new Exception("Method " + method.getName() + "() contains unresolved type variable " + type));
    } else if (type instanceof ParameterizedType) {
        validateNoTypeParameterOnParameterizedType((ParameterizedType) type, errors);
    } else if (type instanceof WildcardType) {
        validateNoTypeParameterOnWildcardType((WildcardType) type, errors);
    } else if (type instanceof GenericArrayType) {
        validateNoTypeParameterOnGenericArrayType((GenericArrayType) type, errors);
    }
}
 [Lines 38 - 42 ] {
    for (Type each : parameterized.getActualTypeArguments()) {
        validateNoTypeParameterOnType(each, errors);
    }
}
 [Lines 45 - 52 ] {
    for (Type each : wildcard.getUpperBounds()) {
        validateNoTypeParameterOnType(each, errors);
    }
    for (Type each : wildcard.getLowerBounds()) {
        validateNoTypeParameterOnType(each, errors);
    }
}
 [Lines 55 - 57 ] {
    validateNoTypeParameterOnType(arrayType.getGenericComponentType(), errors);
}

/src/main/java/org/junit/runners/model/RunnerScheduler.java
===========================================================

/src/main/java/org/junit/runners/model/TestTimedOutException.java
=================================================================
 [Lines 24 - 29 ] {
    super(String.format("test timed out after %d %s", timeout, timeUnit.name().toLowerCase()));
    this.timeUnit = timeUnit;
    this.timeout = timeout;
}
 [Lines 34 - 36 ] {
    return timeout;
}
 [Lines 41 - 43 ] {
    return timeUnit;
}

/src/main/java/org/junit/runners/model/MultipleFailureException.java
====================================================================
 [Lines 24 - 26 ] {
    this.fErrors = new ArrayList<Throwable>(errors);
}
 [Lines 28 - 30 ] {
    return Collections.unmodifiableList(fErrors);
}
 [Lines 33 - 40 ] {
    StringBuilder sb = new StringBuilder(String.format("There were %d errors:", fErrors.size()));
    for (Throwable e : fErrors) {
        sb.append(String.format("\n  %s(%s)", e.getClass().getName(), e.getMessage()));
    }
    return sb.toString();
}
 [Lines 52 - 68 ] {
    if (errors.isEmpty()) {
        return;
    }
    if (errors.size() == 1) {
        throw Throwables.rethrowAsException(errors.get(0));
    }
    /*
           * Many places in the code are documented to throw
           * org.junit.internal.runners.model.MultipleFailureException.
           * That class now extends this one, so we throw the internal
           * exception in case developers have tests that catch
           * MultipleFailureException.
           */
    throw new org.junit.internal.runners.model.MultipleFailureException(errors);
}

/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java
============================================================
 [Lines 67 - 69 ] {
    super(testClass);
}
 [Lines 76 - 90 ] {
    Description description = describeChild(method);
    if (isIgnored(method)) {
        notifier.fireTestIgnored(description);
    } else {
        Statement statement;
        try {
            statement = methodBlock(method);
        } catch (Throwable ex) {
            statement = new Fail(ex);
        }
        runLeaf(statement, description, notifier);
    }
}
 [Lines 97 - 99 ] {
    return child.getAnnotation(Ignore.class) != null;
}
 [Lines 102 - 112 ] {
    Description description = methodDescriptions.get(method);
    if (description == null) {
        description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations());
        methodDescriptions.putIfAbsent(method, description);
    }
    return description;
}
 [Lines 115 - 117 ] {
    return computeTestMethods();
}
 [Lines 128 - 130 ] {
    return getTestClass().getAnnotatedMethods(Test.class);
}
 [Lines 133 - 141 ] {
    super.collectInitializationErrors(errors);
    validateNoNonStaticInnerClass(errors);
    validateConstructor(errors);
    validateInstanceMethods(errors);
    validateFields(errors);
    validateMethods(errors);
}
 [Lines 143 - 149 ] {
    if (getTestClass().isANonStaticInnerClass()) {
        String gripe = "The inner class " + getTestClass().getName() + " is not static.";
        errors.add(new Exception(gripe));
    }
}
 [Lines 156 - 159 ] {
    validateOnlyOneConstructor(errors);
    validateZeroArgConstructor(errors);
}
 [Lines 165 - 170 ] {
    if (!hasOneConstructor()) {
        String gripe = "Test class should have exactly one public constructor";
        errors.add(new Exception(gripe));
    }
}
 [Lines 176 - 183 ] {
    if (!getTestClass().isANonStaticInnerClass() && hasOneConstructor() && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {
        String gripe = "Test class should have exactly one public zero-argument constructor";
        errors.add(new Exception(gripe));
    }
}
 [Lines 185 - 187 ] {
    return getTestClass().getJavaClass().getConstructors().length == 1;
}
 [Lines 196 - 204 ] {
    validatePublicVoidNoArgMethods(After.class, false, errors);
    validatePublicVoidNoArgMethods(Before.class, false, errors);
    validateTestMethods(errors);
    if (computeTestMethods().isEmpty()) {
        errors.add(new Exception("No runnable methods"));
    }
}
 [Lines 206 - 208 ] {
    RULE_VALIDATOR.validate(getTestClass(), errors);
}
 [Lines 210 - 212 ] {
    RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
}
 [Lines 218 - 220 ] {
    validatePublicVoidNoArgMethods(Test.class, false, errors);
}
 [Lines 227 - 229 ] {
    return getTestClass().getOnlyConstructor().newInstance();
}
 [Lines 237 - 239 ] {
    return createTest();
}
 [Lines 245 - 247 ] {
    return method.getName();
}
 [Lines 281 - 301 ] {
    Object test;
    try {
        test = new ReflectiveCallable() {

            @Override
            protected Object runReflectiveCall() throws Throwable {
                return createTest(method);
            }
        }.run();
    } catch (Throwable e) {
        return new Fail(e);
    }
    Statement statement = methodInvoker(method, test);
    statement = possiblyExpectingExceptions(method, test, statement);
    statement = withPotentialTimeout(method, test, statement);
    statement = withBefores(method, test, statement);
    statement = withAfters(method, test, statement);
    statement = withRules(method, test, statement);
    return statement;
}
 [Lines 310 - 312 ] {
    return new InvokeMethod(method, test);
}
 [Lines 321 - 325 ] {
    Test annotation = method.getAnnotation(Test.class);
    return expectsException(annotation) ? new ExpectException(next, getExpectedException(annotation)) : next;
}
 [Lines 335 - 343 ] {
    long timeout = getTimeout(method.getAnnotation(Test.class));
    if (timeout <= 0) {
        return next;
    }
    return FailOnTimeout.builder().withTimeout(timeout, TimeUnit.MILLISECONDS).build(next);
}
 [Lines 351 - 356 ] {
    List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(Before.class);
    return befores.isEmpty() ? statement : new RunBefores(statement, befores, target);
}
 [Lines 366 - 371 ] {
    List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(After.class);
    return afters.isEmpty() ? statement : new RunAfters(statement, afters, target);
}
 [Lines 374 - 381 ] {
    List<TestRule> testRules = getTestRules(target);
    Statement result = statement;
    result = withMethodRules(method, testRules, target, result);
    result = withTestRules(method, testRules, result);
    return result;
}
 [Lines 384 - 392 ] {
    Statement withMethodRules = result;
    for (org.junit.rules.MethodRule each : getMethodRules(target)) {
        if (!(each instanceof TestRule && testRules.contains(each))) {
            withMethodRules = each.apply(withMethodRules, method, target);
        }
    }
    return withMethodRules;
}
 [Lines 394 - 396 ] {
    return rules(target);
}
 [Lines 403 - 411 ] {
    List<MethodRule> rules = getTestClass().getAnnotatedMethodValues(target, Rule.class, MethodRule.class);
    rules.addAll(getTestClass().getAnnotatedFieldValues(target, Rule.class, MethodRule.class));
    return rules;
}
 [Lines 422 - 425 ] {
    return testRules.isEmpty() ? statement : new RunRules(statement, testRules, describeChild(method));
}
 [Lines 432 - 440 ] {
    List<TestRule> result = getTestClass().getAnnotatedMethodValues(target, Rule.class, TestRule.class);
    result.addAll(getTestClass().getAnnotatedFieldValues(target, Rule.class, TestRule.class));
    return result;
}
 [Lines 442 - 448 ] {
    if (annotation == null || annotation.expected() == None.class) {
        return null;
    } else {
        return annotation.expected();
    }
}
 [Lines 450 - 452 ] {
    return getExpectedException(annotation) != null;
}
 [Lines 454 - 459 ] {
    if (annotation == null) {
        return 0;
    }
    return annotation.timeout();
}

/src/main/java/org/junit/runners/ParentRunner.java
==================================================
 [Lines 70 - 72 ] {
    childStatement.run();
}
 [Lines 74 - 76 ] {
// do nothing
}
 [Lines 82 - 85 ] {
    this.testClass = createTestClass(testClass);
    validate();
}
 [Lines 87 - 89 ] {
    return new TestClass(testClass);
}
 [Lines 124 - 129 ] {
    validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);
    validatePublicVoidNoArgMethods(AfterClass.class, true, errors);
    validateClassRules(errors);
    applyValidators(errors);
}
 [Lines 131 - 137 ] {
    if (getTestClass().getJavaClass() != null) {
        for (TestClassValidator each : VALIDATORS) {
            errors.addAll(each.validateTestClass(getTestClass()));
        }
    }
}
 [Lines 151 - 157 ] {
    List<FrameworkMethod> methods = getTestClass().getAnnotatedMethods(annotation);
    for (FrameworkMethod eachTestMethod : methods) {
        eachTestMethod.validatePublicVoidNoArg(isStatic, errors);
    }
}
 [Lines 159 - 162 ] {
    CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);
    CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
}
 [Lines 189 - 197 ] {
    Statement statement = childrenInvoker(notifier);
    if (!areAllChildrenIgnored()) {
        statement = withBeforeClasses(statement);
        statement = withAfterClasses(statement);
        statement = withClassRules(statement);
    }
    return statement;
}
 [Lines 199 - 206 ] {
    for (T child : getFilteredChildren()) {
        if (!isIgnored(child)) {
            return false;
        }
    }
    return true;
}
 [Lines 213 - 218 ] {
    List<FrameworkMethod> befores = testClass.getAnnotatedMethods(BeforeClass.class);
    return befores.isEmpty() ? statement : new RunBefores(statement, befores, null);
}
 [Lines 227 - 232 ] {
    List<FrameworkMethod> afters = testClass.getAnnotatedMethods(AfterClass.class);
    return afters.isEmpty() ? statement : new RunAfters(statement, afters, null);
}
 [Lines 243 - 247 ] {
    List<TestRule> classRules = classRules();
    return classRules.isEmpty() ? statement : new RunRules(statement, classRules, getDescription());
}
 [Lines 253 - 257 ] {
    List<TestRule> result = testClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);
    result.addAll(testClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));
    return result;
}
 [Lines 264 - 271 ] {
    return new Statement() {

        @Override
        public void evaluate() {
            runChildren(notifier);
        }
    };
}
 [Lines 280 - 282 ] {
    return false;
}
 [Lines 284 - 297 ] {
    final RunnerScheduler currentScheduler = scheduler;
    try {
        for (final T each : getFilteredChildren()) {
            currentScheduler.schedule(new Runnable() {

                public void run() {
                    ParentRunner.this.runChild(each, notifier);
                }
            });
        }
    } finally {
        currentScheduler.finished();
    }
}
 [Lines 302 - 304 ] {
    return testClass.getName();
}
 [Lines 313 - 315 ] {
    return testClass;
}
 [Lines 321 - 333 ] {
    EachTestNotifier eachNotifier = new EachTestNotifier(notifier, description);
    eachNotifier.fireTestStarted();
    try {
        statement.evaluate();
    } catch (AssumptionViolatedException e) {
        eachNotifier.addFailedAssumption(e);
    } catch (Throwable e) {
        eachNotifier.addFailure(e);
    } finally {
        eachNotifier.fireTestFinished();
    }
}
 [Lines 339 - 341 ] {
    return testClass.getAnnotations();
}
 [Lines 348 - 355 ] {
    Description description = Description.createSuiteDescription(getName(), getRunnerAnnotations());
    for (T child : getFilteredChildren()) {
        description.addChild(describeChild(child));
    }
    return description;
}
 [Lines 358 - 371 ] {
    EachTestNotifier testNotifier = new EachTestNotifier(notifier, getDescription());
    try {
        Statement statement = classBlock(notifier);
        statement.evaluate();
    } catch (AssumptionViolatedException e) {
        testNotifier.addFailedAssumption(e);
    } catch (StoppedByUserException e) {
        throw e;
    } catch (Throwable e) {
        testNotifier.addFailure(e);
    }
}
 [Lines 377 - 397 ] {
    synchronized (childrenLock) {
        List<T> children = new ArrayList<T>(getFilteredChildren());
        for (Iterator<T> iter = children.iterator(); iter.hasNext(); ) {
            T each = iter.next();
            if (shouldRun(filter, each)) {
                try {
                    filter.apply(each);
                } catch (NoTestsRemainException e) {
                    iter.remove();
                }
            } else {
                iter.remove();
            }
        }
        filteredChildren = Collections.unmodifiableCollection(children);
        if (filteredChildren.isEmpty()) {
            throw new NoTestsRemainException();
        }
    }
}
 [Lines 399 - 408 ] {
    synchronized (childrenLock) {
        for (T each : getFilteredChildren()) {
            sorter.apply(each);
        }
        List<T> sortedChildren = new ArrayList<T>(getFilteredChildren());
        Collections.sort(sortedChildren, comparator(sorter));
        filteredChildren = Collections.unmodifiableCollection(sortedChildren);
    }
}
 [Lines 414 - 420 ] {
    List<Throwable> errors = new ArrayList<Throwable>();
    collectInitializationErrors(errors);
    if (!errors.isEmpty()) {
        throw new InitializationError(errors);
    }
}
 [Lines 422 - 431 ] {
    if (filteredChildren == null) {
        synchronized (childrenLock) {
            if (filteredChildren == null) {
                filteredChildren = Collections.unmodifiableCollection(getChildren());
            }
        }
    }
    return filteredChildren;
}
 [Lines 433 - 435 ] {
    return filter.shouldRun(describeChild(each));
}
 [Lines 437 - 443 ] {
    return new Comparator<T>() {

        public int compare(T o1, T o2) {
            return sorter.compare(describeChild(o1), describeChild(o2));
        }
    };
}
 [Lines 449 - 451 ] {
    this.scheduler = scheduler;
}

/src/main/java/org/junit/runners/MethodSorters.java
===================================================
 [Lines 34 - 36 ] {
    this.comparator = comparator;
}
 [Lines 38 - 40 ] {
    return comparator;
}

/src/main/java/org/junit/runners/JUnit4.java
============================================
 [Lines 21 - 23 ] {
    super(klass);
}

/src/main/java/org/junit/runners/package-info.java
==================================================

/src/main/java/org/junit/matchers/JUnitMatchers.java
====================================================
 [Lines 23 - 25 ] {
    return CoreMatchers.hasItem(element);
}
 [Lines 32 - 34 ] {
    return CoreMatchers.<T>hasItem(elementMatcher);
}
 [Lines 41 - 43 ] {
    return CoreMatchers.hasItems(elements);
}
 [Lines 52 - 54 ] {
    return CoreMatchers.hasItems(elementMatchers);
}
 [Lines 61 - 63 ] {
    return CoreMatchers.everyItem(elementMatcher);
}
 [Lines 70 - 72 ] {
    return CoreMatchers.containsString(substring);
}
 [Lines 83 - 85 ] {
    return CoreMatchers.both(matcher);
}
 [Lines 96 - 98 ] {
    return CoreMatchers.either(matcher);
}
 [Lines 104 - 106 ] {
    return StacktracePrintingMatcher.isThrowable(throwableMatcher);
}
 [Lines 112 - 114 ] {
    return StacktracePrintingMatcher.isException(exceptionMatcher);
}

/src/main/java/org/junit/matchers/package-info.java
===================================================

/src/main/java/org/junit/AfterClass.java
========================================

/src/main/java/org/junit/Rule.java
==================================

/src/main/java/org/junit/package-info.java
==========================================

/src/main/java/org/junit/Before.java
====================================

